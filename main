---@diagnostic disable
package.preload['polys.engine'] = (function (...)
local engine = _G.engine or {}

function engine.log(message, r, g, b, a)

    if r == 255 and g == 0 and b == 0 then
        log_error(tostring(message))
    else
        log(tostring(message))
    end
end



function engine.register_on_engine_tick(callback)
    table.insert(_G.Polyfill_TickCallbacks, callback)
end


function engine.unregister_on_engine_tick(id)
    if id and _G.Polyfill_TickCallbacks[id] then
        _G.Polyfill_TickCallbacks[id] = nil
    end
end

function engine.register_onunload(callback)
    table.insert(_G.Polyfill_UnloadCallbacks, callback)
end

function engine.register_on_network_callback(callback)
    table.insert(_G.Polyfill_NetCallbacks, callback)
end

function engine.get_username()
    return "User" 
end

_G.engine = engine
return engine
 end)

package.preload['polys.fs'] = (function (...)
local fs = _G.fs or {}
local m = _G.m

function fs.does_file_exist(file_name)
    return does_file_exist(file_name)
end

function fs.read_from_file(file_name)
    local ok, data = read_file(file_name)
    if ok then return data end
    return ""
end

function fs.write_to_file(file_name, data)
    return create_file(file_name, data)
end

function fs.delete_file(file_name)
    return delete_file(file_name)
end

function fs.get_file_size(file_name)
    local ok, data = read_file(file_name)
    if ok then return #data end
    return 0
end

function fs.write_to_file_from_buffer(file_name, buffer_handle)
    local data = ""
    if buffer_handle then
        if buffer_handle._type == "ffi_buffer" and buffer_handle.ptr then
            local ffi = require("ffi")
            data = ffi.string(buffer_handle.ptr, buffer_handle.size)
        elseif buffer_handle._type == "lua_buffer" and buffer_handle.data then
            for i=1, buffer_handle.size do
                data = data .. string.char(buffer_handle.data[i])
            end
        end
    end
    return fs.write_to_file(file_name, data)
end

function fs.read_from_file_to_buffer(file_name, buffer_handle)
    local data = fs.read_from_file(file_name)
    if not data or not buffer_handle then return false end

    if buffer_handle._type == "ffi_buffer" then
        local ffi = require("ffi")
        ffi.copy(buffer_handle.ptr, data, math.min(#data, buffer_handle.size))
    elseif buffer_handle._type == "lua_buffer" then
        for i=1, math.min(#data, buffer_handle.size) do
            buffer_handle.data[i] = string.byte(data, i)
        end
    end
    return true
end

function fs.compress(str)
    return str
end

function fs.decompress(str)
    return str
end

_G.fs = fs
return fs
 end)

package.preload['polys.gui'] = (function (...)
local gui = _G.gui or {}

local TAB_INDICES = {
    ["aimbot"] = 0,
    ["visuals"] = 1,
    ["lua"] = 4, 
    ["settings"] = 3,
}


local PanelWrapper = {}
PanelWrapper.__index = PanelWrapper

function PanelWrapper.new(panel_obj)
    local self = setmetatable({}, PanelWrapper)
    self.panel = panel_obj
    return self
end

function PanelWrapper:add_checkbox(label)
    local cb = self.panel:add_checkbox(label, false)
    return cb
end

function PanelWrapper:add_slider_int(label, postfix, default, min, max, step)
    local s = self.panel:add_slider_int(label, postfix or "", default, min, max, step or 1)
    return s
end

function PanelWrapper:add_slider_float(label, postfix, value, min, max, step)
    local s = self.panel:add_slider_double(label, postfix or "", value, min, max, step or 1)
    return s
end

function PanelWrapper:add_button(label, callback)
    local btn = self.panel:add_button(label, callback)
    return btn
end

function PanelWrapper:add_text(label)

    self.panel:add_button(label, function() end)
end

function PanelWrapper:add_input_text(label, default)
    local inp = self.panel:add_input(label, default)
    return inp
end

function PanelWrapper:add_color_picker(label, r, g, b, a)
    local col = self.panel:add_color(label, {r, g, b, a})
    return col
end

function PanelWrapper:add_keybind(label, key, mode)

    local kb = self.panel:add_keybind(label, key, mode)
    return kb
end

function PanelWrapper:add_single_select(name, options_table, initial_index, is_expandable)
    local ss = self.panel:add_single_select(name, options_table, initial_index or 0, is_expandable or false)
    return ss
end

function PanelWrapper:add_multi_select(label, list)
    local options = {}
    for i, v in ipairs(list) do
        table.insert(options, {v, true}) 
    end
    local ms = self.panel:add_multi_select(label, options, false)
    return ms
end

local TabWrapper = {}
TabWrapper.__index = TabWrapper

function TabWrapper.new(index)
    local self = setmetatable({}, TabWrapper)
    self.index = index
    return self
end

function TabWrapper:create_panel(label, small_panel)

    local subtab = ui.create_subtab(self.index, label)
    local panel = subtab:add_panel(label, small_panel or false)
    return PanelWrapper.new(panel)
end

function TabWrapper:create_subtab(label)
    local subtab = ui.create_subtab(self.index, label)
    return SubTabWrapper.new(subtab)
end

local SubTabWrapper = {}
SubTabWrapper.__index = SubTabWrapper

function SubTabWrapper.new(subtab_obj)
    local self = setmetatable({}, SubTabWrapper)
    self.subtab = subtab_obj
    return self
end

function SubTabWrapper:create_panel(label, small_panel)
    local panel = self.subtab:add_panel(label, small_panel or false)
    return PanelWrapper.new(panel)
end

function gui.get_tab(name)
    local idx = TAB_INDICES[string.lower(name)] or 4
    return TabWrapper.new(idx)
end


_G.gui = gui
_G.SubTabWrapper = SubTabWrapper

return gui
 end)

package.preload['polys.input'] = (function (...)
local input = _G.input or {}

function input.simulate_mouse(dx, dy, flag)
    if flag == 1 then
        mouse_move_relative(dx, dy)
    elseif flag == 2 then

        mouse_left_click()
    elseif flag == 4 then

    else
        mouse_move_relative(dx, dy)
    end
end

function input.simulate_keyboard(key, flag)
    if not flag or flag == 0 then win_key_press(key)
    elseif flag == 1 then win_key_down(key)
    elseif flag == 2 then win_key_up(key) end
end

function input.is_key_pressed(key) return key_fired(key) end
function input.is_key_down(key) return key_down(key) end
function input.is_key_toggled(key) return key_toggle(key) end
function input.get_mouse_position() return get_mouse_pos() end
function input.get_mouse_move_delta() return get_mouse_delta() end
function input.get_scroll_delta() return get_scroll_delta() end
function input.get_clipboard() return copy_from_clipboard() end
function input.set_clipboard(text) copy_to_clipboard(text) end
function input.is_menu_open() return false end

_G.input = input
return input
 end)

package.preload['polys.m'] = (function (...)
local m = _G.m or {}
local has_ffi, ffi = pcall(require, "ffi")

function m.alloc(size)
    if has_ffi then
        local ptr = ffi.new("uint8_t[?]", size)
        return { _type = "ffi_buffer", ptr = ptr, size = size }
    else
        local t = {}
        for i=1, size do t[i] = 0 end
        return { _type = "lua_buffer", data = t, size = size }
    end
end

function m.free(handle)
    if handle then
        handle.ptr = nil
        handle.data = nil
    end
end

function m.get_size(handle)
    return handle and handle.size or 0
end

local function check_bounds(handle, offset, type_size)
    if not handle or offset < 0 or (offset + type_size) > handle.size then
        return false
    end
    return true
end

function m.read_int8(handle, offset)
    if not check_bounds(handle, offset, 1) then return 0 end
    if handle._type == "ffi_buffer" then
        return handle.ptr[offset]
    else
        return handle.data[offset + 1] or 0
    end
end

function m.read_int16(handle, offset)
    if not check_bounds(handle, offset, 2) then return 0 end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("int16_t*", handle.ptr + offset)
        return ptr[0]
    else
        local b1 = handle.data[offset + 1]
        local b2 = handle.data[offset + 2]
        local val = b1 + (b2 * 256)
        if val > 32767 then val = val - 65536 end
        return val
    end
end

function m.read_int32(handle, offset)
    if not check_bounds(handle, offset, 4) then return 0 end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("int32_t*", handle.ptr + offset)
        return ptr[0]
    else
        local b1 = handle.data[offset + 1]
        local b2 = handle.data[offset + 2]
        local b3 = handle.data[offset + 3]
        local b4 = handle.data[offset + 4]
        local val = b1 + (b2 * 256) + (b3 * 65536) + (b4 * 16777216)

        if val > 2147483647 then val = val - 4294967296 end
        return val
    end
end

function m.read_int64(handle, offset)
    if not check_bounds(handle, offset, 8) then return 0 end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("int64_t*", handle.ptr + offset)
        return tonumber(ptr[0]) 
    else
        return m.read_int32(handle, offset)
    end
end

function m.read_float(handle, offset)
    if not check_bounds(handle, offset, 4) then return 0.0 end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("float*", handle.ptr + offset)
        return tonumber(ptr[0])
    else
        return 0.0 
    end
end

function m.read_double(handle, offset)
    if not check_bounds(handle, offset, 8) then return 0.0 end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("double*", handle.ptr + offset)
        return tonumber(ptr[0])
    else
        return 0.0
    end
end

function m.read_string(handle, offset)
    if not handle then return "" end
    local str = ""
    if handle._type == "ffi_buffer" then
        local ptr = handle.ptr + offset
        return ffi.string(ptr)
    else
        for i = offset + 1, handle.size do
            local b = handle.data[i]
            if b == 0 then break end
            str = str .. string.char(b)
        end
    end
    return str
end

function m.write_int8(handle, offset, value)
    if not check_bounds(handle, offset, 1) then return end
    if handle._type == "ffi_buffer" then
        handle.ptr[offset] = value
    else
        handle.data[offset + 1] = value % 256
    end
end

function m.write_int16(handle, offset, value)
    if not check_bounds(handle, offset, 2) then return end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("int16_t*", handle.ptr + offset)
        ptr[0] = value
    else
        handle.data[offset + 1] = value % 256
        handle.data[offset + 2] = math.floor(value / 256) % 256
    end
end

function m.write_int32(handle, offset, value)
    if not check_bounds(handle, offset, 4) then return end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("int32_t*", handle.ptr + offset)
        ptr[0] = value
    else
        handle.data[offset + 1] = value % 256
        handle.data[offset + 2] = math.floor(value / 256) % 256
        handle.data[offset + 3] = math.floor(value / 65536) % 256
        handle.data[offset + 4] = math.floor(value / 16777216) % 256
    end
end

function m.write_float(handle, offset, value)
    if not check_bounds(handle, offset, 4) then return end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("float*", handle.ptr + offset)
        ptr[0] = value
    end
end

function m.write_double(handle, offset, value)
    if not check_bounds(handle, offset, 8) then return end
    if handle._type == "ffi_buffer" then
        local ptr = ffi.cast("double*", handle.ptr + offset)
        ptr[0] = value
    end
end

function m.write_string(handle, offset, str)
    if not handle then return end
    if handle._type == "ffi_buffer" then
        ffi.copy(handle.ptr + offset, str)
    else
        for i = 1, #str do
            if offset + i <= handle.size then
                handle.data[offset + i] = string.byte(str, i)
            end
        end
        if offset + #str + 1 <= handle.size then
            handle.data[offset + #str + 1] = 0 
        end
    end
end

_G.m = m
return m
 end)

package.preload['polys.math'] = (function (...)
local m = math

function m.clamp(x, min, max)
    if x < min then return min end
    if x > max then return max end
    return x
end

function m.lerp(a, b, t)
    return a + (b - a) * t
end

function m.round(x)
    return math.floor(x + 0.5)
end

function m.round_up(x)
    return math.ceil(x)
end

function m.round_down(x)
    return math.floor(x)
end

function m.round_to_nearest(x, step)
    if step == 0 then return x end
    return math.floor(x / step + 0.5) * step
end

function m.sign(x)
    if x > 0 then return 1 end
    if x < 0 then return -1 end
    return 0
end

function m.map(x, in_min, in_max, out_min, out_max)
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
end

function m.saturate(x)
    return m.clamp(x, 0, 1)
end

function m.is_nan(x)
    return x ~= x
end

function m.is_inf(x)
    return x == math.huge or x == -math.huge
end

function m.smoothstep(edge0, edge1, x)
    x = m.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0)
    return x * x * (3 - 2 * x)
end

function m.inverse_lerp(a, b, x)
    return (x - a) / (b - a)
end

function m.fract(x)
    return x - math.floor(x)
end

function m.wrap(x, min, max)
    return min + (x - min) % (max - min)
end



return m
 end)

package.preload['polys.net'] = (function (...)
local net = _G.net or {}

function net.send_request(url, headers, post_fields)


    if post_fields and post_fields ~= "" then

        local ctype = "application/x-www-form-urlencoded"
        if headers and type(headers) == "table" then
            for k, v in pairs(headers) do
                if string.lower(k) == "content-type" then ctype = v break end
            end
        end

        local ok, status, body = net_http_post(url, ctype, post_fields, 5000)
        return body or "" 
    else
        local ok, status, body = net_http_get(url, 5000)
        return body or ""
    end
end

function net.resolve(hostname)
    return "127.0.0.1" 
end

function net.create_socket(ip, port)
    return {
        send = function() return 0 end,
        receive = function() return nil, "not supported" end,
        close = function() end
    }
end

function net.base64_encode(str)
    return util.base64_encode(str)
end

function net.base64_decode(str)
    return util.base64_decode(str)
end

_G.net = net
return net
 end)

package.preload['polys.process'] = (function (...)
local proc = _G.proc or {}

local _Internal_CurrentProcess = nil
local _Internal_AttachedName = nil

function proc.attach_by_pid(process_id, has_corrupt_cr3)
    if _Internal_CurrentProcess then
        deref_process(_Internal_CurrentProcess)
    end
    _Internal_CurrentProcess = ref_process(process_id)
    _Internal_AttachedName = nil
    return _Internal_CurrentProcess ~= nil
end

function proc.attach_by_name(process_name, has_corrupt_cr3)
    if _Internal_CurrentProcess then
        deref_process(_Internal_CurrentProcess)
    end
    _Internal_CurrentProcess = ref_process(process_name)
    _Internal_AttachedName = process_name
    return _Internal_CurrentProcess ~= nil
end

function proc.attach_by_window(window_class, window_name, has_corrupt_cr3)
    local hwnd = find_window(window_name, window_class)
    if hwnd then
        local tid, pid = get_window_thread_process_id(hwnd)
        if pid then
            return proc.attach_by_pid(pid, has_corrupt_cr3)
        end
    end
    return false
end

function proc.is_attached()
    return _Internal_CurrentProcess and _Internal_CurrentProcess:alive()
end

function proc.did_exit()
    return not (_Internal_CurrentProcess and _Internal_CurrentProcess:alive())
end

function proc.pid()
    if proc.is_attached() then
        return _Internal_CurrentProcess:pid()
    end
    return 0
end

function proc.peb()
    if proc.is_attached() then
        return _Internal_CurrentProcess:peb()
    end
    return 0
end

function proc.base_address()
    if proc.is_attached() then
        return _Internal_CurrentProcess:base_address()
    end
    return 0
end

function proc.handle()
    if proc.is_attached() then
        return _Internal_CurrentProcess
    end
    return nil
end

function proc.get_base_module()
    if proc.is_attached() then
        if _Internal_AttachedName then
            local address, size = _Internal_CurrentProcess:get_module(_Internal_AttachedName)
            
            return address, size
        end
        return _Internal_CurrentProcess:base_address(), 0 
    end
    return 0, 0
end

function proc.find_module(module_name)
    if proc.is_attached() then
        return _Internal_CurrentProcess:get_module(module_name)
    end
    return 0, 0
end

function proc.find_signature(base_address, size, signature)
    if proc.is_attached() then
        return _Internal_CurrentProcess:find_code_pattern(base_address, size, signature)
    end
    return 0
end

function proc.read_double(address)
    if proc.is_attached() then return _Internal_CurrentProcess:rf64(address) end; return 0
end
function proc.read_float(address)
    if proc.is_attached() then return _Internal_CurrentProcess:rf32(address) end; return 0
end
function proc.read_int64(address)
    if proc.is_attached() then return _Internal_CurrentProcess:r64(address) end; return 0
end
function proc.read_int32(address)
    if proc.is_attached() then return _Internal_CurrentProcess:r32(address) end; return 0
end
function proc.read_int16(address)
    if proc.is_attached() then return _Internal_CurrentProcess:r16(address) end; return 0
end
function proc.read_int8(address)
    if proc.is_attached() then return _Internal_CurrentProcess:r8(address) end; return 0
end

function proc.read_string(address, size)
    if proc.is_attached() then return _Internal_CurrentProcess:rs(address, size) end; return ""
end
function proc.read_wide_string(address, size)
    if proc.is_attached() then return _Internal_CurrentProcess:rws(address, size) end; return ""
end

function proc.read_to_memory_buffer(address, buffer, size)

    if proc.is_attached() then
         local data = _Internal_CurrentProcess:rs(address, size) 
         if type(buffer) == "table" then
             buffer.data = data
         end
    end
end

function proc.dump(file_name)

    -----Damn this func is missing
end

function proc.write_double(address, value)
    if proc.is_attached() then return _Internal_CurrentProcess:wf64(address, value) end; return false
end
function proc.write_float(address, value)
    if proc.is_attached() then return _Internal_CurrentProcess:wf32(address, value) end; return false
end
function proc.write_int64(address, value)
    if proc.is_attached() then return _Internal_CurrentProcess:w64(address, value) end; return false
end
function proc.write_int32(address, value)
    if proc.is_attached() then return _Internal_CurrentProcess:w32(address, value) end; return false
end
function proc.write_int16(address, value)
    if proc.is_attached() then return _Internal_CurrentProcess:w16(address, value) end; return false
end
function proc.write_int8(address, value)
    if proc.is_attached() then return _Internal_CurrentProcess:w8(address, value) end; return false
end
function proc.write_string(address, text)
    if proc.is_attached() then return _Internal_CurrentProcess:ws(address, text) end; return false
end
function proc.write_wide_string(address, text)
    if proc.is_attached() then return _Internal_CurrentProcess:wws(address, text) end; return false
end

function proc.write_from_memory_buffer(address, buffer, size)
    if proc.is_attached() and type(buffer) == "table" and buffer.data then
        return _Internal_CurrentProcess:ws(address, buffer.data)
    end
    return false
end


function proc.read_struct(base_address, descriptor)
    if proc.is_attached() then
        return _Internal_CurrentProcess:read_struct(base_address, descriptor)
    end
    return nil
end

-- table proc:read_struct_array(
--     uint64 base_address,
--     integer count,
--     integer struct_size,
--     table descriptor
-- )
function proc.read_struct_array(base_address, count, struct_size, descriptor)
    if proc.is_attached() then
        return _Internal_CurrentProcess:read_struct_array(base_address, count, struct_size, descriptor)
    end
    return false
end


_G.proc = proc
return proc

 end)

package.preload['polys.render'] = (function (...)
local render = _G.render or {}
local net = _G.net

local function unpack_color(r, g, b, a)
    return r, g, b, a or 255
end

function render.draw_line(x1, y1, x2, y2, r, g, b, a, thickness)
    draw_line(x1, y1, x2, y2, r, g, b, a, thickness)
end

function render.draw_rectangle(x, y, width, height, r, g, b, a, thickness, filled, rounding)
    rounding = rounding or 0
    a = a or 255
    r = math.floor(r or 255)
    g = math.floor(g or 255)
    b = math.floor(b or 255)
    a = math.floor(a)
    if filled then
        draw_rect_filled(x, y, width, height, r, g, b, a, rounding, 15)
    else
        draw_rect(x, y, width, height, r, g, b, a, thickness, rounding, 15)
    end
end

function render.draw_circle(x, y, radius, r, g, b, a, thickness, filled)
    draw_circle(x, y, radius, r, g, b, a, thickness, filled)
end

function render.draw_triangle(x1, y1, x2, y2, x3, y3, r, g, b, a, thickness, filled)
    local points = {x1, y1, x2, y2, x3, y3}
    draw_polygon(points, 3, r, g, b, a, thickness, filled)
end

function render.draw_polygon(points_table, r, g, b, a, thickness, filled)

    local flat_points = {}
    for i, pt in ipairs(points_table) do
        if type(pt) == "table" then
            table.insert(flat_points, pt[1])
            table.insert(flat_points, pt[2])
        else
            table.insert(flat_points, pt)
        end
    end

    draw_polygon(flat_points, #flat_points / 2, r, g, b, a, thickness, filled)
end

function render.draw_ellipse(x, y, rx, ry, r, g, b, a, thickness, filled)
    local points = {}
    local segments = 32
    for i = 0, segments - 1 do
        local theta = (i / segments) * math.pi * 2
        table.insert(points, x + rx * math.cos(theta))
        table.insert(points, y + ry * math.sin(theta))
    end
    draw_polygon(points, segments, r, g, b, a, thickness, filled)
end

function render.draw_arc(x, y, rx, ry, start_angle, sweep_angle, r, g, b, a, thickness, filled)
    local points = {}
    local segments = 16
    local start_rad = math.rad(start_angle)
    local sweep_rad = math.rad(sweep_angle)

    if filled then table.insert(points, x); table.insert(points, y) end

    for i = 0, segments do
        local theta = start_rad + (i / segments) * sweep_rad
        table.insert(points, x + rx * math.cos(theta))
        table.insert(points, y + ry * math.sin(theta))
    end

    draw_polygon(points, #points/2, r, g, b, a, thickness, filled)
end

function render.create_font(path, size, anti_aliased, load_color)
    return create_font(path, size, anti_aliased or false, load_color or false)
end

function render.create_font_from_buffer(font_label, size, buffer_handle, anti_aliased, load_color)
    local data = buffer_handle

    if type(buffer_handle) == "table" then
        if buffer_handle._type == "ffi_buffer" and buffer_handle.ptr then
            local ffi = require("ffi")
            data = ffi.string(buffer_handle.ptr, buffer_handle.size)
        elseif buffer_handle._type == "lua_buffer" and buffer_handle.data then
            local t = {}
            for i=1, buffer_handle.size do
                t[i] = string.char(buffer_handle.data[i])
            end
            data = table.concat(t)
        end
    end

    return create_font_mem(font_label, size, data, anti_aliased or false, load_color or false)
end

function render.draw_text(font, text, x, y, r, g, b, a, outline_thickness, o_r, o_g, o_b, o_a)
    r = math.floor(r or 255)
    g = math.floor(g or 255)
    b = math.floor(b or 255)
    a = math.floor(a or 255)
    
    local er = math.floor(o_r or 0)
    local eg = math.floor(o_g or 0)
    local eb = math.floor(o_b or 0)
    local ea = math.floor(o_a or 0)

    local effect = 0 
    local effect_amount = 0

    if outline_thickness and outline_thickness > 0 then
        effect = 1 
        effect_amount = outline_thickness
    end

    draw_text(text, x, y, r, g, b, a, font, effect, er, eg, eb, ea, effect_amount, true)
end

function render.measure_text(font_handle, text)
    local w, h = get_text_size(font_handle, text, 10000, 10000)
    return w, h
end

function render.get_viewport_size()
    return get_view()
end

function render.get_fps()
    return get_fps()
end

function render.clip_start(x, y, width, height)
    clip_push(x, y, width, height)
end

function render.clip_end()
    clip_pop()
end

function render.create_bitmap_from_url(url)
    local ok, status, body = net_http_get(url)
    if ok and status == 200 then
        return create_bitmap(body)
    end
    return nil
end

function render.create_bitmap_from_buffer(buffer_handle)
    local data = buffer_handle
    if type(buffer_handle) == "table" then
        if buffer_handle._type == "ffi_buffer" and buffer_handle.ptr then
            local ffi = require("ffi")
            data = ffi.string(buffer_handle.ptr, buffer_handle.size)
        elseif buffer_handle._type == "lua_buffer" and buffer_handle.data then
            local t = {}
            for i=1, buffer_handle.size do
                t[i] = string.char(buffer_handle.data[i])
            end
            data = table.concat(t)
        end
    end
    return create_bitmap(data)
end

function render.create_bitmap_from_file(file_name)
    local ok, data = read_file(file_name)
    if ok then
        return create_bitmap(data)
    end
    return nil
end

function render.draw_four_corner_gradient(x, y, width, height, r1, g1, b1, r2, g2, b2, r3, g3, b3, r4, g4, b4)

    draw_four_corner_gradient(x, y, width, height,
        r1, g1, b1, 255,
        r2, g2, b2, 255,
        r3, g3, b3, 255,
        r4, g4, b4, 255,
        0)
end

function render.draw_gradient_line(x1, y1, x2, y2, color_table, thickness)

    local r,g,b,a = 255, 255, 255, 255
    if type(color_table) == "table" and #color_table >= 4 then
        r,g,b,a = color_table[1], color_table[2], color_table[3], color_table[4]
    end
    draw_line(x1, y1, x2, y2, r, g, b, a, thickness)
end

function render.draw_gradient_rectangle(x, y, width, height, color_table, rounding)
    local r1, g1, b1, a1 = 255, 255, 255, 255
    local r2, g2, b2, a2 = 255, 255, 255, 255

    if type(color_table) == "table" then
        if type(color_table[1]) == "table" then
            local c1 = color_table[1] or {255,255,255,255}
            local c2 = color_table[2] or c1
            
            r1, g1, b1, a1 = c1[1], c1[2], c1[3], c1[4]
            r2, g2, b2, a2 = c2[1], c2[2], c2[3], c2[4]
        else
            if #color_table >= 4 then 
                r1,g1,b1,a1 = color_table[1], color_table[2], color_table[3], color_table[4] 
            end
            if #color_table >= 8 then
                r2,g2,b2,a2 = color_table[5], color_table[6], color_table[7], color_table[8]
            else
                r2,g2,b2,a2 = r1,g1,b1,a1 
            end
        end
    end

    draw_four_corner_gradient(
        x, y, width, height,
        math.floor(r1 or 255), math.floor(g1 or 255), math.floor(b1 or 255), math.floor(a1 or 255),
        math.floor(r1 or 255), math.floor(g1 or 255), math.floor(b1 or 255), math.floor(a1 or 255), -- Top Right matches Top Left (Horizontal/Vertical hybrid)
        math.floor(r2 or 255), math.floor(g2 or 255), math.floor(b2 or 255), math.floor(a2 or 255),
        math.floor(r2 or 255), math.floor(g2 or 255), math.floor(b2 or 255), math.floor(a2 or 255), -- Bottom Right matches Bottom Left
        math.floor(rounding or 0)
    )
end

_G.render = render
return render
 end)

package.preload['polys.str'] = (function (...)
local str = _G.str or {}

function str.trim(s)
    return s:match("^%s*(.-)%s*$")
end

function str.ltrim(s)
    return s:match("^%s*(.*)")
end

function str.rtrim(s)
    return s:match("(.-)%s*$")
end

function str.pad_left(s, len, char)
    if #s >= len then return s end
    return string.rep(char or " ", len - #s) .. s
end

function str.pad_right(s, len, char)
    if #s >= len then return s end
    return s .. string.rep(char or " ", len - #s)
end

function str.strip_prefix(s, prefix)
    if str.startswith(s, prefix) then
        return s:sub(#prefix + 1)
    end
    return s
end

function str.strip_suffix(s, suffix)
    if str.endswith(s, suffix) then
        return s:sub(1, -#suffix - 1)
    end
    return s
end

function str.startswith(s, prefix)
    return s:sub(1, #prefix) == prefix
end

function str.endswith(s, suffix)
    return suffix == "" or s:sub(-#suffix) == suffix
end

function str.contains(s, substring)
    return s:find(substring, 1, true) ~= nil
end

function str.indexof(s, substr, start)
    return s:find(substr, start or 1, true)
end

function str.last_indexof(s, substr)
    local i = 0
    local found = nil
    while true do
        i = s:find(substr, i + 1, true)
        if not i then break end
        found = i
    end
    return found
end

function str.count(s, substr)
    local c = 0
    local i = 0
    while true do
        i = s:find(substr, i + 1, true)
        if not i then break end
        c = c + 1
    end
    return c
end

function str.empty(s)
    return s == nil or s == ""
end

function str.equals(a, b)
    return a == b
end

function str.replace(s, from, to)

    local pattern = from:gsub("[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1")
    local result, _ = s:gsub(pattern, to:gsub("%%", "%%%%")) 
    return result
end

function str.repeat_str(s, count)
    return string.rep(s, count)
end

function str.reverse(s)
    return string.reverse(s)
end

function str.insert(s, pos, substr)
    return s:sub(1, pos-1) .. substr .. s:sub(pos)
end

function str.remove(s, start, END)
    return s:sub(1, start-1) .. s:sub(END+1)
end

function str.substitute(s, tbl)
    return (s:gsub("{(.-)}", function(key)
        return tbl[key] or "{"..key.."}"
    end))
end

function str.upper(s)
    return string.upper(s)
end

function str.lower(s)
    return string.lower(s)
end

function str.split(s, delimiter)
    local result = {}
    for match in (s..delimiter):gmatch("(.-)"..delimiter) do
        table.insert(result, match)
    end
    return result
end

function str.slice(s, start, END)
    return string.sub(s, start, END)
end

function str.utf8len(s)
    return utf8.len(s)
end

function str.utf8sub(s, start, END)

    return string.sub(s, start, END)
end

_G.str = str
return str
 end)

package.preload['polys.time'] = (function (...)
local time = _G.time or {}

time.SECONDS_PER_MINUTE = 60
time.SECONDS_PER_HOUR = 3600
time.SECONDS_PER_DAY = 86400
time.DAYS_PER_WEEK = 7
time.WEEKDAY_NAMES = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
time.MONTH_NAMES = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
time.MONTH_DAYS = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
time.MONTH_DAYS_LEAP = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
time.MONTH_NAME_TO_INDEX = {}
for i, v in ipairs(time.MONTH_NAMES) do time.MONTH_NAME_TO_INDEX[v] = i end

function time.unix()
    return os.time()
end

function time.unix_ms()

    return os.time() * 1000
end

function time.now_utc()
    return os.date("!%Y-%m-%d %H:%M:%S")
end

function time.now_local()
    return os.date("%Y-%m-%d %H:%M:%S")
end

function time.format(timestamp)
    return os.date("%Y-%m-%d %H:%M:%S", timestamp)
end

function time.format_custom(timestamp, format)

    return os.date("!" .. format, timestamp)
end

function time.delta(t1, t2)
    return math.abs(t1 - t2)
end

function time.compare(t1, t2)
    if t1 < t2 then return -1 end
    if t1 > t2 then return 1 end
    return 0
end

function time.same_day(t1, t2)
    local d1 = os.date("!*t", t1)
    local d2 = os.date("!*t", t2)
    return d1.year == d2.year and d1.month == d2.month and d1.day == d2.day
end

function time.diff_table(t1, t2)
    local diff = math.abs(t1 - t2)
    local days = math.floor(diff / 86400)
    local remainder = diff % 86400
    local hours = math.floor(remainder / 3600)
    remainder = remainder % 3600
    local minutes = math.floor(remainder / 60)
    local seconds = remainder % 60
    return {days=days, hours=hours, minutes=minutes, seconds=seconds}
end

function time.between(now, start, END)
    return now >= start and now <= END
end

function time.weekday(timestamp)
    local d = os.date("!*t", timestamp)
    return d.wday - 1

end

function time.day_of_year(timestamp)
    local d = os.date("!*t", timestamp)
    return d.yday
end

function time.year_month_day(timestamp)
    local d = os.date("!*t", timestamp)
    return {year=d.year, month=d.month, day=d.day}
end

function time.is_weekend(timestamp)
    local w = time.weekday(timestamp)
    return w == 0 or w == 6
end

function time.is_leap_year(timestamp)
    local y = os.date("!*t", timestamp).year
    return (y % 4 == 0 and y % 100 ~= 0) or (y % 400 == 0)
end

function time.days_in_month(year, month)
    local is_leap = (year % 4 == 0 and year % 100 ~= 0) or (year % 400 == 0)
    if is_leap then return time.MONTH_DAYS_LEAP[month] end
    return time.MONTH_DAYS[month]
end

function time.timestamp_utc(y, m, d, h, min, s)
    return os.time({year=y, month=m, day=d, hour=h, min=min, sec=s}) 

end

function time.add_days(timestamp, days)
    return timestamp + (days * 86400)
end

function time.start_of_day(timestamp)
    local d = os.date("!*t", timestamp)
    d.hour = 0; d.min = 0; d.sec = 0
    return os.time(d)
end

function time.end_of_day(timestamp)
    local d = os.date("!*t", timestamp)
    d.hour = 23; d.min = 59; d.sec = 59
    return os.time(d)
end

function time.to_table(timestamp)
    return os.date("*t", timestamp)
end

function time.from_table(tbl)
    return os.time(tbl)
end

function time.to_utc_table(timestamp)
    return os.date("!*t", timestamp)
end

function time.from_utc_table(tbl)

    return os.time(tbl)
end

function time.is_valid(timestamp)
    return type(timestamp) == "number" and timestamp > 0
end

function time.is_dst(timestamp)
    local d = os.date("*t", timestamp)
    return d.isdst
end

function time.utc_offset()
    local now = os.time()
    local utc = os.time(os.date("!*t", now))
    return os.difftime(now, utc)
end

function time.get_timezone()
    return os.date("%z")
end

function time.seconds_to_hhmmss(seconds)
    local h = math.floor(seconds / 3600)
    local m = math.floor((seconds % 3600) / 60)
    local s = seconds % 60
    return string.format("%02d:%02d:%02d", h, m, s)
end

_G.time = time
return time
 end)

package.preload['polys.vectors'] = (function (...)
local vec2_impl = {}
local vec3_impl = {}
local vec4_impl = {}



local function make_vector_proxy(original_constructor, type_name)
    local proxy = {}

    setmetatable(proxy, {
        __call = function(_, ...)
            return original_constructor(...)
        end
    })

    return proxy
end

_G.vec2 = make_vector_proxy(vector2, "vec2")
_G.vec3 = make_vector_proxy(vector3, "vec3")
_G.vec4 = make_vector_proxy(vector4, "vec4")

function _G.vec2.read_float(address)
   
    local v = vector2()
    local proc = _G.proc and _G._Internal_CurrentProcess 
   
    if _G.proc and _G.proc.is_attached() then

    end

    local x = _G.proc.read_float(address)
    local y = _G.proc.read_float(address + 4)
    return vector2(x, y)
end

function _G.vec2.read_double(address)
    local x = _G.proc.read_double(address)
    local y = _G.proc.read_double(address + 8)
    return vector2(x, y)
end

function _G.vec2.write_float(address, v)
    _G.proc.write_float(address, v.x)
    _G.proc.write_float(address + 4, v.y)
end

function _G.vec2.write_double(address, v)
    _G.proc.write_double(address, v.x)
    _G.proc.write_double(address + 8, v.y)
end


function _G.vec3.read_float(address)
    local x = _G.proc.read_float(address)
    local y = _G.proc.read_float(address + 4)
    local z = _G.proc.read_float(address + 8)
    return vector3(x, y, z)
end

function _G.vec3.read_double(address)
    local x = _G.proc.read_double(address)
    local y = _G.proc.read_double(address + 8)
    local z = _G.proc.read_double(address + 16)
    return vector3(x, y, z)
end

function _G.vec3.write_float(address, v)
    _G.proc.write_float(address, v.x)
    _G.proc.write_float(address + 4, v.y)
    _G.proc.write_float(address + 8, v.z)
end

function _G.vec3.write_double(address, v)
    _G.proc.write_double(address, v.x)
    _G.proc.write_double(address + 8, v.y)
    _G.proc.write_double(address + 16, v.z)
end



local v3_dummy = vector3()
local v3_mt = getmetatable(v3_dummy) or debug.getmetatable(v3_dummy)

if v3_mt then
    v3_mt.to_forward = function(self)

        local pitch = math.rad(self.x)
        local yaw = math.rad(self.y)
        local cp = math.cos(pitch)
        local sp = math.sin(pitch)
        local cy = math.cos(yaw)
        local sy = math.sin(yaw)
        return vector3(cp * cy, cp * sy, -sp)
    end

    v3_mt.to_right = function(self)

        local fwd = self:to_forward()
        local up = vector3(0, 0, 1) 

        return vector3(0, 1, 0) 
    end

    v3_mt.to_up = function(self)
        return vector3(0, 0, 1) 
    end

    v3_mt.to_qangle = function(self)
        return vector3(0, 0, 0)
    end

    v3_mt.normalize_angles = function(self)
        local x = self.x
        local y = self.y
        return vector3(x, y, self.z)
    end

    v3_mt.clamp_angles = function(self)
        return self
    end

 
    _G.vec3.from_qangle = function(pitch, yaw)
        local v = vector3(pitch, yaw, 0)
        return v:to_forward()
    end

    _G.vec3.normalize_angle = function(angle)
        return angle 
    end
else

    log_error("Polyfill: Cannot modify vector metatables. Instance methods like :to_forward() may fail.")
end

function _G.vec4.read_float(address)
    local x = _G.proc.read_float(address)
    local y = _G.proc.read_float(address + 4)
    local z = _G.proc.read_float(address + 8)
    local w = _G.proc.read_float(address + 12)
    return vector4(x, y, z, w)
end

function _G.vec4.read_double(address)
    local x = _G.proc.read_double(address)
    local y = _G.proc.read_double(address + 8)
    local z = _G.proc.read_double(address + 16)
    local w = _G.proc.read_double(address + 24)
    return vector4(x, y, z, w)
end

function _G.vec4.write_float(address, v)
    _G.proc.write_float(address, v.x)
    _G.proc.write_float(address + 4, v.y)
    _G.proc.write_float(address + 8, v.z)
    _G.proc.write_float(address + 12, v.w)
end

function _G.vec4.write_double(address, v)
    _G.proc.write_double(address, v.x)
    _G.proc.write_double(address + 8, v.y)
    _G.proc.write_double(address + 16, v.z)
    _G.proc.write_double(address + 24, v.w)
end
 end)

package.preload['polys.winapi'] = (function (...)
local winapi = _G.winapi or {}

function winapi.get_tickcount64()
    return get_tickcount64()
end

function winapi.play_sound(file_name)
end

function winapi.get_hwnd(class_name, window_name)
    return find_window(window_name, class_name)
end

function winapi.post_message(hwnd, msg, wparam, lparam)
    return post_message(hwnd, msg, wparam, lparam)
end

function winapi.get_foreground_window()
    return 0
end

function winapi.get_window_rect(hwnd)
    return get_window_rect(hwnd)
end

function winapi.get_window_thread_process_id(hwnd)
    local tid, pid = get_window_thread_process_id(hwnd)
    return tid, pid
end

function winapi.get_window_style(hwnd)
    return 0 
end

function winapi.is_window_visible(hwnd)
    return true
end

function winapi.is_window_enabled(hwnd)
    return true
end

_G.winapi = winapi
return winapi
 end)



-- UFOHOOK Parser, stealing this means youre gay
package.preload['polys.mapparser'] = (function (...)
    local parser = {}
    local fs = _G.fs
    
    local math_abs   = math.abs
    local math_min   = math.min
    local math_max   = math.max
    local string_unpack = string.unpack

    local n_min_x, n_min_y, n_min_z = {}, {}, {}
    local n_max_x, n_max_y, n_max_z = {}, {}, {}
    local n_content, n_tri_count = {}, {}
    
    local t_v0x, t_v0y, t_v0z = {}, {}, {}
    local t_v1x, t_v1y, t_v1z = {}, {}, {}
    local t_v2x, t_v2y, t_v2z = {}, {}, {}
    
    local map_data = {
        name = "",
        loaded = false,
        nodes_count = 0,
        tris_count = 0
    }
    
    local _stack = {}
    for i=1, 256 do _stack[i] = 0 end

    local function read_int32(str, offset)
        local v, next_off = string_unpack("<i4", str, offset)
        return v, next_off
    end
    
    local function read_float(str, offset)
        local v, next_off = string_unpack("<f", str, offset)
        return v, next_off
    end

    local function IntersectBox(ox, oy, oz, idx, idy, idz, b_min_x, b_min_y, b_min_z, b_max_x, b_max_y, b_max_z, max_dist)
        local t1 = (b_min_x - ox) * idx
        local t2 = (b_max_x - ox) * idx
        local tmin = (t1 < t2) and t1 or t2
        local tmax = (t1 > t2) and t1 or t2

        t1 = (b_min_y - oy) * idy
        t2 = (b_max_y - oy) * idy
        local ty_min = (t1 < t2) and t1 or t2
        local ty_max = (t1 > t2) and t1 or t2

        if (tmin > ty_max) or (ty_min > tmax) then return false end
        if ty_min > tmin then tmin = ty_min end
        if ty_max < tmax then tmax = ty_max end

        t1 = (b_min_z - oz) * idz
        t2 = (b_max_z - oz) * idz
        local tz_min = (t1 < t2) and t1 or t2
        local tz_max = (t1 > t2) and t1 or t2

        if (tmin > tz_max) or (tz_min > tmax) then return false end
        if tz_min > tmin then tmin = tz_min end
        if tz_max < tmax then tmax = tz_max end

        return (tmin < max_dist) and (tmax > 0.0)
    end

    local function IntersectTriangle(ox, oy, oz, dx, dy, dz, v0x, v0y, v0z, v1x, v1y, v1z, v2x, v2y, v2z)
        local e1x, e1y, e1z = v1x - v0x, v1y - v0y, v1z - v0z
        local e2x, e2y, e2z = v2x - v0x, v2y - v0y, v2z - v0z

        local hx = dy * e2z - dz * e2y
        local hy = dz * e2x - dx * e2z
        local hz = dx * e2y - dy * e2x

        local a = e1x * hx + e1y * hy + e1z * hz
        if a > -0.00001 and a < 0.00001 then return false end

        local f = 1.0 / a
        local sx = ox - v0x
        local sy = oy - v0y
        local sz = oz - v0z

        local u = f * (sx * hx + sy * hy + sz * hz)
        if u < 0.0 or u > 1.0 then return false end

        local qx = sy * e1z - sz * e1y
        local qy = sz * e1x - sx * e1z
        local qz = sx * e1y - sy * e1x

        local v = f * (dx * qx + dy * qy + dz * qz)
        if v < 0.0 or u + v > 1.0 then return false end

        local t = f * (e2x * qx + e2y * qy + e2z * qz)
        
        return t > 0.001 and t < 0.999
    end

    function parser.load_map(map_name)
        if map_data.name == map_name and map_data.loaded then return true end

        n_min_x, n_min_y, n_min_z = {}, {}, {}
        n_max_x, n_max_y, n_max_z = {}, {}, {}
        n_content, n_tri_count = {}, {}
        t_v0x, t_v0y, t_v0z = {}, {}, {}
        t_v1x, t_v1y, t_v1z = {}, {}, {}
        t_v2x, t_v2y, t_v2z = {}, {}, {}
        
        map_data.name = map_name
        map_data.loaded = false
        
        local file_path = "maps/" .. map_name .. ".ufo"
        if not fs.does_file_exist(file_path) then 
            engine.log("UFOParser: MISSING " .. file_path, 255, 50, 50, 255)
            return false 
        end

        local data = fs.read_from_file(file_path)
        if not data or #data < 64 then return false end
        
        local status, err = pcall(function()
            local off = 1
            local num_nodes, next_off = string_unpack("<i4", data, off); off = next_off
            local num_tris, next_off = string_unpack("<i4", data, off); off = next_off
            
            for i = 1, num_nodes do
                n_min_x[i], off = string_unpack("<f", data, off)
                n_min_y[i], off = string_unpack("<f", data, off)
                n_min_z[i], off = string_unpack("<f", data, off)
                
                n_max_x[i], off = string_unpack("<f", data, off)
                n_max_y[i], off = string_unpack("<f", data, off)
                n_max_z[i], off = string_unpack("<f", data, off)
                
                n_content[i], off = string_unpack("<i4", data, off)
                n_tri_count[i], off = string_unpack("<i4", data, off)
            end
            
            for i = 1, num_tris do
                t_v0x[i], off = string_unpack("<f", data, off)
                t_v0y[i], off = string_unpack("<f", data, off)
                t_v0z[i], off = string_unpack("<f", data, off)
                
                t_v1x[i], off = string_unpack("<f", data, off)
                t_v1y[i], off = string_unpack("<f", data, off)
                t_v1z[i], off = string_unpack("<f", data, off)
                
                t_v2x[i], off = string_unpack("<f", data, off)
                t_v2y[i], off = string_unpack("<f", data, off)
                t_v2z[i], off = string_unpack("<f", data, off)
            end
            
            map_data.nodes_count = num_nodes
            map_data.tris_count = num_tris
            map_data.loaded = true
            
            engine.log("UFOParser: LOADED " .. map_name .. " (Nodes: " .. num_nodes .. ", Tris: " .. num_tris .. ")", 0, 255, 0, 255)
        end)

        if not status then
            engine.log("UFOParser: Parse Error: " .. tostring(err), 255, 0, 0, 255)
            return false
        end

        return true
    end

    function parser.is_visible(start_pos, end_pos)
        if not map_data.loaded then return false end
        if not start_pos or not end_pos then return false end

        local sx, sy, sz = start_pos.x, start_pos.y, start_pos.z
        local ex, ey, ez = end_pos.x, end_pos.y, end_pos.z

        local dx = ex - sx
        local dy = ey - sy
        local dz = ez - sz
        
        local epsilon = 0.00001
        local idx = 1.0 / (math_abs(dx) < epsilon and (dx >= 0 and epsilon or -epsilon) or dx)
        local idy = 1.0 / (math_abs(dy) < epsilon and (dy >= 0 and epsilon or -epsilon) or dy)
        local idz = 1.0 / (math_abs(dz) < epsilon and (dz >= 0 and epsilon or -epsilon) or dz)

        local sp = 1
        _stack[1] = 1 
        
        local safety_loop = 0
        local nodes_len = map_data.nodes_count
        local tris_len = map_data.tris_count

        while sp > 0 do
            safety_loop = safety_loop + 1
            if safety_loop > 4000 then break end

            local node_idx = _stack[sp]
            sp = sp - 1
            
            if node_idx > 0 and node_idx <= nodes_len then
                if IntersectBox(sx, sy, sz, idx, idy, idz, n_min_x[node_idx], n_min_y[node_idx], n_min_z[node_idx], n_max_x[node_idx], n_max_y[node_idx], n_max_z[node_idx], 1.0) then
                    
                    local count = n_tri_count[node_idx]
                    
                    if count > 0 then

                        local content_val = n_content[node_idx]
                        local start_tri = -(content_val + 1)
                        local lua_start = start_tri + 1 
                        local lua_end = lua_start + count - 1

                        if lua_start >= 1 and lua_end <= tris_len then
                            for i = lua_start, lua_end do
                                if IntersectTriangle(sx, sy, sz, dx, dy, dz, 
                                    t_v0x[i], t_v0y[i], t_v0z[i],
                                    t_v1x[i], t_v1y[i], t_v1z[i],
                                    t_v2x[i], t_v2y[i], t_v2z[i]) then
                                    
                                    return false
                                end
                            end
                        end
                    else

                        if sp + 2 < 256 then
                            local left_idx = node_idx + 1
                            local right_idx = n_content[node_idx] + 1
                            
                            if left_idx <= nodes_len and right_idx <= nodes_len then
                                
                                local lx = (n_min_x[left_idx] + n_max_x[left_idx]) * 0.5
                                local ly = (n_min_y[left_idx] + n_max_y[left_idx]) * 0.5
                                local lz = (n_min_z[left_idx] + n_max_z[left_idx]) * 0.5
                                
                                local rx = (n_min_x[right_idx] + n_max_x[right_idx]) * 0.5
                                local ry = (n_min_y[right_idx] + n_max_y[right_idx]) * 0.5
                                local rz = (n_min_z[right_idx] + n_max_z[right_idx]) * 0.5
                                
                                local dist_l = (sx - lx)^2 + (sy - ly)^2 + (sz - lz)^2
                                local dist_r = (sx - rx)^2 + (sy - ry)^2 + (sz - rz)^2
                                
                                if dist_l < dist_r then
                                    sp = sp + 1; _stack[sp] = right_idx
                                    sp = sp + 1; _stack[sp] = left_idx
                                else
                                    sp = sp + 1; _stack[sp] = left_idx
                                    sp = sp + 1; _stack[sp] = right_idx
                                end
                            else
                                sp = sp + 1; _stack[sp] = right_idx
                                sp = sp + 1; _stack[sp] = left_idx
                            end
                        end
                    end
                end
            end
        end

        return true
    end

    return parser
end)




_G.polyfill = {}

_G.Polyfill_TickCallbacks = {}
_G.Polyfill_UnloadCallbacks = {}
_G.Polyfill_NetCallbacks = {}

_G.engine = {}
_G.render = {}
_G.proc = {}
_G.fs = {}
_G.input = {}
_G.gui = {}
_G.net = {}
_G.time = {}
_G.winapi = {}
_G.m = {}
_G.str = {}

function polyfill.main()

    return 1 
end

function polyfill.on_frame()
    for id, callback in pairs(_G.Polyfill_TickCallbacks) do
        if callback then
            local success, err = pcall(callback, id)
            if not success then
           
            end
        end
    end
end

function polyfill.on_unload()
    for i = 1, #Polyfill_UnloadCallbacks do
        if Polyfill_UnloadCallbacks[i] then
            Polyfill_UnloadCallbacks[i]()
        end
    end
end

require("polys.engine")
require("polys.render")
require("polys.process")
require("polys.m")
require("polys.fs")
require("polys.input")
require("polys.gui")
require("polys.time")
require("polys.str")
require("polys.math")
require("polys.net")
require("polys.winapi")
require("polys.vectors")
require("polys.mapparser")

main = polyfill.main
on_frame = polyfill.on_frame
on_unload = polyfill.on_unload


local REFERENCE_HEIGHT = 1080 
_G.G_Scale = 1.0


local function IsCS2Active()
    local hwnd = find_window("Counter-Strike 2", "SDL_app")
    
    if not hwnd then 
        hwnd = find_window("Counter-Strike 2") 
    end

    if hwnd and not is_foreground_window(hwnd) then
        return false
    end

    return true
end

function S(pixel_value)
    return math.floor(pixel_value * _G.G_Scale)
end

local function UpdateScale()
    local sw, sh = render.get_viewport_size()
    if sh and sh > 0 then
        _G.G_Scale = sh / REFERENCE_HEIGHT
    end
end

UpdateScale()
engine.register_on_engine_tick(UpdateScale)

local STATE_LOGIN = -1 
local STATE_IDLE = 0
local STATE_WAITING_FOR_PROCESS = 1
local STATE_WAITING_FOR_GAME = 2
local STATE_TRANSITION = 3 
local STATE_ACTIVE = 4

local g_current_state = STATE_LOGIN 

local g_loader_alpha = 0
local g_transition_alpha = 255 
local g_btn_anim = 0
local g_spinner_rot = 0

local f_title = render.create_font("Verdana", S(28), 700)
local f_sub   = render.create_font("Verdana", S(12), 400)
local f_btn   = render.create_font("Verdana", S(14), 700)
local f_card  = render.create_font("Verdana", S(16), 600)
local f_input = render.create_font("Verdana", S(14), 400)

local InitializeFeatures = nil 
local MainGameLoop = nil 

local function Lerp(a, b, t) return a + (b - a) * t end

local Particles = {}
for i = 1, 50 do
    table.insert(Particles, {
        x = math.random(0, 1920),
        y = math.random(0, 1080),
        speed = math.random(2, 5) / 10,
        size = math.random(1, 3),
        alpha = math.random(50, 150)
    })
end

local function DrawParticles(alpha)
    local sw, sh = render.get_viewport_size()
    for _, p in ipairs(Particles) do
        p.y = p.y - p.speed
        if p.y < 0 then 
            p.y = sh 
            p.x = math.random(0, sw)
        end
        
        render.draw_circle(p.x, p.y, p.size, 255, 0, 0, math.floor(p.alpha * (alpha/255)), 0, true)
    end
end

local function DrawSpinner(x, y, radius, thickness, color_a)
    local steps = 20
    g_spinner_rot = g_spinner_rot + 5
    if g_spinner_rot > 360 then g_spinner_rot = 0 end
    
    for i = 1, steps do
        local angle = math.rad(g_spinner_rot + (i * (360/steps)))
        local next_angle = math.rad(g_spinner_rot + ((i+1) * (360/steps)))
        local alpha = math.floor(color_a * (i / steps))
        
        local x1 = x + math.cos(angle) * radius
        local y1 = y + math.sin(angle) * radius
        local x2 = x + math.cos(next_angle) * radius
        local y2 = y + math.sin(next_angle) * radius
        
        render.draw_line(x1, y1, x2, y2, 255, 255, 255, alpha, thickness)
    end
end

local LoginState = {
    alpha = 0,
    phase = 0,
    last_tick = 0,
    type_index = 0,
    init_delay_set = false, 
    
    username_target = get_user_name(),
    username_display = "",
    
    password_len = math.random(8, 14),
    password_display = "",
    
    status_text = "Login"
}

local function DrawLoginScreen()
    local now = winapi.get_tickcount64()

    if not LoginState.init_delay_set then
        LoginState.last_tick = now + 2000 -- 2000ms delay
        LoginState.init_delay_set = true
    end

    LoginState.alpha = Lerp(LoginState.alpha, 255, 0.05)
    local a = math.floor(LoginState.alpha)
    if a < 2 then return end

    local sw, sh = render.get_viewport_size()
    local w, h = S(400), S(350)
    local x, y = (sw/2) - (w/2), (sh/2) - (h/2)

    render.draw_rectangle(0, 0, sw, sh, 255, 255, 255, math.min(240, a), 0, true)
    DrawParticles(a)

    render.draw_rectangle(x + 8, y + 8, w, h, 200, 200, 200, 80 * (a/255), 15, true, 12)
    render.draw_rectangle(x, y, w, h, 255, 255, 255, a, 0, true, 10)
    render.draw_rectangle(x, y, w, h, 220, 220, 220, a, 1, false, 10)

    render.draw_text(f_title, "TSIDE", x + (w/2) - (render.measure_text(f_title, "TSIDE")/2), y + S(40), 255, 0, 0, a, 0,0,0,0,0)
    render.draw_text(f_sub, "Login to continue", x + (w/2) - (render.measure_text(f_sub, "Login to continue")/2), y + S(75), 80, 80, 80, a, 0,0,0,0,0)

    if LoginState.phase == 0 then 
        if now - LoginState.last_tick > math.random(50, 150) then
            LoginState.type_index = LoginState.type_index + 1
            LoginState.username_display = string.sub(LoginState.username_target, 1, LoginState.type_index)
            LoginState.last_tick = now
            if LoginState.type_index >= #LoginState.username_target then
                LoginState.phase = 1
                LoginState.type_index = 0
                LoginState.last_tick = now + 400 
            end
        end
    elseif LoginState.phase == 1 then -- Typing Password
        if now - LoginState.last_tick > math.random(50, 120) then
            LoginState.type_index = LoginState.type_index + 1
            LoginState.password_display = string.rep("*", LoginState.type_index)
            LoginState.last_tick = now
            if LoginState.type_index >= LoginState.password_len then
                LoginState.phase = 2
                LoginState.last_tick = now
                LoginState.status_text = "Authenticating..."
            end
        end
    elseif LoginState.phase == 2 then 
        if now - LoginState.last_tick > 1500 then 
            g_current_state = STATE_IDLE 
            LoginState.alpha = 0 
        end
    end


    local bx = x + S(50)
    local bw = w - S(100)
    local start_y = y + S(110)

    render.draw_text(f_sub, "Username", bx, start_y, 200, 200, 200, a, 0,0,0,0,0)
    local u_bg_col = {245, 245, 245}
    local u_br_col = (LoginState.phase == 0) and {255, 0, 0} or {200, 200, 200}
    
    render.draw_rectangle(bx, start_y + S(20), bw, S(35), u_bg_col[1], u_bg_col[2], u_bg_col[3], a, 0, true, 4)
    render.draw_rectangle(bx, start_y + S(20), bw, S(35), u_br_col[1], u_br_col[2], u_br_col[3], a, 1, false, 4)
    local show_user_cursor = (LoginState.phase == 0 and (now > (LoginState.last_tick - 150)) and (now % 800 < 400))
    render.draw_text(f_input, LoginState.username_display .. (show_user_cursor and "|" or ""), bx + 10, start_y + S(28), 255, 255, 255, a, 0,0,0,0,0)

    local pass_y = start_y + S(70)
    render.draw_text(f_sub, "Password", bx, pass_y, 200, 200, 200, a, 0,0,0,0,0)
    local p_bg_col = {245, 245, 245}
    local p_br_col = (LoginState.phase == 1) and {255, 0, 0} or {200, 200, 200}

    render.draw_rectangle(bx, pass_y + S(20), bw, S(35), p_bg_col[1], p_bg_col[2], p_bg_col[3], a, 0, true, 4)
    render.draw_rectangle(bx, pass_y + S(20), bw, S(35), p_br_col[1], p_br_col[2], p_br_col[3], a, 1, false, 4)
    render.draw_text(f_input, LoginState.password_display .. ((LoginState.phase == 1 and (now % 800 < 400)) and "|" or ""), bx + 10, pass_y + S(30), 255, 255, 255, a, 0,0,0,0,0)

    local btn_y = pass_y + S(75)
    local btn_col = (LoginState.phase == 2) and {45, 45, 50} or {255, 0, 0}
    
    render.draw_rectangle(bx, btn_y, bw, S(40), btn_col[1], btn_col[2], btn_col[3], a, 0, true, 4)
    
    if LoginState.phase == 2 then
        local tw = render.measure_text(f_btn, "Authenticating...")
        local spinner_x = bx + (bw/2) - (tw/2) - 15
        DrawSpinner(spinner_x, btn_y + S(20), 8, 2, a)
        render.draw_text(f_btn, "Authenticating...", spinner_x + 20, btn_y + S(12), 255, 255, 255, a, 0,0,0,0,0)
    else
        local tw = render.measure_text(f_btn, "LOGIN")
        render.draw_text(f_btn, "LOGIN", bx + (bw/2) - (tw/2), btn_y + S(12), 255, 255, 255, a, 0,0,0,0,0)
    end
end
local Loader = {
    state = 0, 
    alpha = 0,
    progress = 0,
    log_text = "Waiting for action...",
    anim_time = 0,
    
    colors = {    bg = {255, 255, 255},          -- main background white
    sidebar = {245, 245, 245},     -- slightly off-white
    accent = {255, 0, 0},          -- red
    accent_hover = {200, 0, 0},    -- darker red hover
    text = {0, 0, 0},              -- black text
    text_dim = {80, 80, 80},       -- dark gray text
    success = {0, 170, 0}          -- darker green for white bg
    }
}

local function DrawLoaderButton(x, y, w, h, text, font, alpha, callback)
    local mx, my = input.get_mouse_position()
    local hover = mx >= x and mx <= x + w and my >= y and my <= y + h
    local c = Loader.colors
    
    if not _G.btn_hover_anim then _G.btn_hover_anim = 0 end
    _G.btn_hover_anim = Lerp(_G.btn_hover_anim, hover and 1 or 0, 0.1)

    local r = Lerp(c.accent[1], c.accent_hover[1], _G.btn_hover_anim)
    local g = Lerp(c.accent[2], c.accent_hover[2], _G.btn_hover_anim)
    local b = Lerp(c.accent[3], c.accent_hover[3], _G.btn_hover_anim)
    
    if _G.btn_hover_anim > 0.01 then
        render.draw_rectangle(x - 2, y - 2, w + 4, h + 4, r, g, b, alpha * 0.3 * _G.btn_hover_anim, 0, true, 6)
    end

    render.draw_rectangle(x, y, w, h, r, g, b, alpha, 0, true, 4)
    
    local tw, th = render.measure_text(font, text)
    render.draw_text(font, text, x + (w/2) - (tw/2), y + (h/2) - (th/2), 255, 255, 255, alpha, 0, 0, 0, 0, 0)

    if hover and input.is_key_pressed(1) and callback then
        callback()
    end
end

local function DrawModernLoader()
    if g_current_state == STATE_LOGIN then
        DrawLoginScreen()
        return
    end

    local target_alpha = (g_current_state >= STATE_IDLE and g_current_state < STATE_ACTIVE) and 255 or 0
    Loader.alpha = Lerp(Loader.alpha, target_alpha, 0.05)
    
    local a = math.floor(Loader.alpha)
    if a < 2 then return end

    local sw, sh = render.get_viewport_size()
    local c = Loader.colors
    
    render.draw_rectangle(0, 0, sw, sh, 10, 10, 12, math.min(240, a), 0, true)
    DrawParticles(a)

    local w, h = S(650), S(400)
    local x, y = (sw/2) - (w/2), (sh/2) - (h/2)

    render.draw_rectangle(x + 10, y + 10, w, h, 0, 0, 0, 100 * (a/255), 15, true, 12) 
    render.draw_rectangle(x, y, w, h, c.bg[1], c.bg[2], c.bg[3], a, 0, true, 10) 
    render.draw_rectangle(x, y, w, h, 60, 60, 70, a, 1, false, 10) 

    local sb_w = S(200)
    render.draw_rectangle(x, y, sb_w, h, c.sidebar[1], c.sidebar[2], c.sidebar[3], a, 0, true, 10)
    render.draw_line(x + sb_w, y, x + sb_w, y + h, 40, 40, 45, a, 1)
    render.draw_rectangle(x + sb_w - 10, y, 10, h, c.sidebar[1], c.sidebar[2], c.sidebar[3], a, 0, true, 0)

    render.draw_text(f_title, "TSIDE", x + S(30), y + S(40), c.accent[1], c.accent[2], c.accent[3], a, 0,0,0,0,0)
    render.draw_text(f_sub, "EXTERNAL SOLUTION", x + S(30), y + S(72), c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0,0,0,0,0)

    local u_y = y + h - S(80)
    render.draw_circle(x + S(40), u_y + S(30), S(22), 40, 40, 50, a, 0, true)
    render.draw_text(f_title, string.sub(get_user_name(), 1, 1):upper(), x + S(33), u_y + S(18), 255, 255, 255, a, 0,0,0,0,0) 
    
    render.draw_text(f_btn, get_user_name(), x + S(75), u_y + S(15), 255, 255, 255, a, 0,0,0,0,0)
    render.draw_text(f_sub, "Lifetime Sub", x + S(75), u_y + S(35), c.success[1], c.success[2], c.success[3], a, 0,0,0,0,0)

    local cx = x + sb_w + S(25)
    local cy = y + S(25)
    local cw = w - sb_w - S(50)

    render.draw_text(f_card, "Game Status", cx, cy, c.text[1], c.text[2], c.text[3], a, 0,0,0,0,0)
    
    local card_y = cy + S(30)
    render.draw_rectangle(cx, card_y, cw, S(70), 25, 25, 30, a, 0, true, 6) 
    render.draw_rectangle(cx, card_y, cw, S(70), 50, 50, 55, a, 1, false, 6) 
    
    render.draw_rectangle(cx + S(15), card_y + S(15), S(40), S(40), 255, 150, 0, a, 0, true, 4)
    render.draw_text(f_btn, "CS2", cx + S(22), card_y + S(25), 255, 255, 255, a, 0,0,0,0,0)

    render.draw_text(f_btn, "Counter-Strike 2", cx + S(70), card_y + S(15), 255, 255, 255, a, 0,0,0,0,0)
    render.draw_text(f_sub, "Status: Undetected", cx + S(70), card_y + S(38), c.success[1], c.success[2], c.success[3], a, 0,0,0,0,0)

    local bottom_y = y + h - S(60)
    
    if Loader.state == 0 then
        DrawLoaderButton(cx, bottom_y, cw, S(35), "LOAD CHEAT", f_btn, a, function()
            Loader.state = 1 
            Loader.anim_time = winapi.get_tickcount64()
        end)
    elseif Loader.state == 1 then
        local time_diff = winapi.get_tickcount64() - Loader.anim_time
        Loader.progress = math.min(1, time_diff / 2500) 
        
        if Loader.progress < 0.2 then Loader.log_text = "Downloading config..."
        elseif Loader.progress < 0.5 then Loader.log_text = "Mapping memory..."
        elseif Loader.progress < 0.8 then Loader.log_text = "Bypassing anti-cheat..."
        else Loader.log_text = "Finalizing..." end

        render.draw_rectangle(cx, bottom_y, cw, S(35), 25, 25, 30, a, 0, true, 4)
        render.draw_rectangle(cx, bottom_y, cw, S(35), 50, 50, 55, a, 1, false, 4)
        
        if Loader.progress > 0.01 then
            render.draw_rectangle(cx + 2, bottom_y + 2, (cw - 4) * Loader.progress, S(35) - 4, c.accent[1], c.accent[2], c.accent[3], a, 0, true, 2)
        end
        
        local tw, th = render.measure_text(f_sub, Loader.log_text)
        render.draw_text(f_sub, Loader.log_text, cx + (cw/2) - (tw/2), bottom_y + (S(35)/2) - (th/2), 255, 255, 255, a, 0,0,0,0,0)

        if Loader.progress >= 1 then
            g_current_state = STATE_WAITING_FOR_PROCESS 
            Loader.state = 2
        end
    elseif Loader.state == 2 then
        local txt = "Waiting for CS2.exe..."
        if g_current_state == STATE_WAITING_FOR_GAME then txt = "Waiting for Match..." end
        if g_current_state == STATE_TRANSITION then txt = "Injecting..." end
        
        DrawSpinner(cx + (cw/2) - 10, bottom_y + S(17), 8, 2, a)
        render.draw_text(f_sub, txt, cx + (cw/2) + 5, bottom_y + S(10), 200, 200, 200, a, 0,0,0,0,0)
    end
end

local function to_argb(r, g, b, a)
    local clamp = function(x) return math.max(0, math.min(1, x)) end
    r = math.floor(clamp(r) * 255)
    g = math.floor(clamp(g) * 255)
    b = math.floor(clamp(b) * 255)
    a = math.floor(clamp(a) * 255)

    return (a << 24) | (b << 16) | (g << 8) | r
end





local offsets = {
    dwViewMatrix = 0x230BEE0,
    dwLocalPlayerPawn = 0x2065AF0,
    dwLocalPlayerController = 0x22F0188,
    dwEntityList = 0x24AB1B8,
    dwGlobalVars = 0x205A580,
    m_pCurrentMapName = 0x1B8,
    dwViewAngles = 0x23165E8,
    m_hPlayerPawn = 0x90C,
    m_bDormant = 0x10B,
    m_angEyeAngles = 0x3DD0,
    m_iHealth = 0x354,
    m_lifeState = 0x35C,
    m_Glow = 0xCC0,
    m_glowColorOverride = 0x40,
    m_bGlowing = 0x51,
    m_iGlowType = 0x30,
    m_iTeamNum = 0x3F3,
    m_ArmorValue = 0x272C,
    m_vOldOrigin = 0x1588,
    m_pGameSceneNode = 0x338,
    m_modelState = 0x160,
    m_boneArray = 0x80,
    m_nodeToWorld = 0x10,
    m_sSanitizedPlayerName = 0x860,
    m_hPawn = 0x6C4,
    m_hObserverPawn = 0x910,
    m_pObserverServices = 0x13F0,
    m_hObserverTarget = 0x4C,
    m_bBeingDefused = 0x11AC,
    m_bBombDefused = 0x11C4,
    m_flFlashDuration = 0x15F8,
    m_vecAbsOrigin = 0xD0,  
    m_hOwnerEntity = 0x528,      -- C_BaseEntity
    m_pCameraServices = 0x1410,  
    m_hPostProcessing = 0x1F4,   -- NOT UPDATED OFFSET  
    m_flMinExposure = 0xF7C,        
    m_flMaxExposure = 0xF80,
    m_pInGameMoneyServices = 0x808,
    m_iAccount = 0x40,
    m_pEntity = 0x10,
    m_designerName = 0x20,
    -- C_SmokeGrenadeProjectile offset
    vSmokeColor = 0x145C,
    m_iIDEntIndex = 0x3EAC,
    m_vecVelocity = 0x438,
    m_pClippingWeapon = 0x3DC0,
    m_bIsScoped = 0x26F8,
     m_iszPlayerName = 0x6F8,
    m_AttributeManager = 0x1378,
    m_Item = 0x50,
    m_iItemDefinitionIndex = 0x1BA,
    m_entitySpottedState = 0x26E0, 
    m_bSpotted = 0x8,
     m_vecViewOffset = 0xD58,
     m_boneArray_aim = 0x80,
     m_bSpottedByMask = 0xC,
     v_angle = 0x1490,
    dwCSGOInput = 0x2315F60, 
    dwForceJump = 0x1BD54A0, 
    m_bCameraInThirdPerson = 0x251, 
    m_iShotsFired = 0x270C,      -- C_CSPlayerPawn
    m_aimPunchAngle = 0x16CC,    -- C_CSPlayerPawn
    m_aimPunchCache = 0x1008,     -- C_CSPlayerPawn
    m_fFlags = 0x400,         -- C_BaseEntity::m_fFlags
    m_hpawn = 0x6C4,
    m_pObserverServices = 0x13F0,
    m_hObserverTarget = 0x4C,
    m_pWeaponServices = 0x13D8,
    m_hActiveWeapon = 0x60,
    -----Bomb Shits -----
    dwPlantedC4 = 0x2313700,
    m_nBombSite = 0x1174,
    m_flC4Blow = 0x11A0,
    m_flTimerLength = 0x11A8,
    m_bBeingDefused = 0x11AC,
    m_flDefuseLength = 0x11BC,
    m_flDefuseCountDown = 0x11C0,
    m_bBombDefused = 0x11C4,
    m_bBombPlanted = 0x1F7B,
    m_pGameRules = 0x608,
    m_bBombTicking = 0x1170,
     m_nTickBase = 0x6C0,
     dwGameTypes = 0x1B8000,
     m_szLevelName = 0x120,
     ---Fire shits-----
    m_fireCount = 0x1838,       
    m_firePositions = 0xEF8,    
    m_bFireIsBurning = 0x14F8, 
    m_minBounds = 0x8464,     
    m_maxBounds = 0x8470,    
        m_nFireLifetime = 0x1840,
    m_nFireEffectTickBegin = 0x184C,
    dwNetworkGameClient = 0x9084B0,
    m_hMyWeapons = 0x40,
    m_iItemIDHigh = 0x1D0,
    m_nFallbackPaintKit = 0x1870,
    m_flFallbackWear = 0x1878,
    m_nFallbackStatTrak = 0x187C,
    m_OriginalOwnerXuidLow = 0x1868,
    m_pViewModelServices = 0x12C0,
    m_hViewModel = 0x40,
    clientstate_delta_ticks = 0x23C, -- dwNetworkGameClient_deltaTick

}


local function cross_product(o, a, b)
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)
end

local function get_convex_hull(points)
    local n = #points
    if n <= 2 then return points end

    table.sort(points, function(a, b) 
        return a.x < b.x or (a.x == b.x and a.y < b.y) 
    end)

    local lower = {}
    for _, p in ipairs(points) do
        while #lower >= 2 and cross_product(lower[#lower-1], lower[#lower], p) <= 0 do
            table.remove(lower)
        end
        table.insert(lower, p)
    end

    local upper = {}
    for i = n, 1, -1 do
        local p = points[i]
        while #upper >= 2 and cross_product(upper[#upper-1], upper[#upper], p) <= 0 do
            table.remove(upper)
        end
        table.insert(upper, p)
    end

    table.remove(upper)
    table.remove(lower)

    local hull = {}
    for _, p in ipairs(lower) do table.insert(hull, p) end
    for _, p in ipairs(upper) do table.insert(hull, p) end

    return hull
end


local g = {
    font = render.create_font("Verdana", 12, 700),
    small_font = render.create_font("Verdana", 11, 400)
}

local esp_fonts = {
    font = render.create_font("Verdana", 12, 700),
    small_font = render.create_font("Verdana", 11, 400),
     name = render.create_font("Verdana", 12, 700),
    weapon = render.create_font("Verdana", 11, 400)
}

local BONE_MAP = {
    head = 6, neck_0 = 5, spine_1 = 4, spine_2 = 2, pelvis = 0,
    arm_upper_L = 8, arm_lower_L = 9, hand_L = 10,
    arm_upper_R = 13, arm_lower_R = 14, hand_R = 15,
    leg_upper_L = 22, leg_lower_L = 23, ankle_L = 24,
    leg_upper_R = 25, leg_lower_R = 26, ankle_R = 27
}

local BONE_MAP_aim = {
    head = 6, neck = 5, spine = 4, pelvis = 0,
    left_shoulder = 8, left_elbow = 9, left_hand = 10,
    right_shoulder = 13, right_elbow = 14, right_hand = 15,
    left_hip = 22, left_knee = 23, left_ankle = 24,
    right_hip = 25, right_knee = 26, right_ankle = 27
}

engine.register_on_engine_tick(function(tick_id)
    if g_current_state < STATE_ACTIVE then
        
        if g_current_state == STATE_TRANSITION then
            g_transition_alpha = math.lerp(g_transition_alpha, 0, 0.08)
            g_loader_alpha = g_transition_alpha
            
            DrawModernLoader()
            
            if g_transition_alpha < 1 then
                engine.log("Transition complete. Loading Menu.", 100, 255, 100, 255)
                InitializeFeatures() 
                g_current_state = STATE_ACTIVE
                
                engine.unregister_on_engine_tick(tick_id) 
                engine.register_on_engine_tick(function(...)
                    local success, err = pcall(MainGameLoop, ...) 
                    if not success and err then
                        engine.log("RUNTIME ERROR: " .. tostring(err), 255, 50, 50, 255)
                    end
                end)
                return
            end
            return 
        end

        DrawModernLoader()

        if g_current_state == STATE_WAITING_FOR_PROCESS then
            if proc.attach_by_name("cs2.exe") then
                engine.log("Attached to CS2.", 0, 255, 0, 255)
                g_current_state = STATE_WAITING_FOR_GAME
            end
        end

     if g_current_state == STATE_WAITING_FOR_GAME then
            if proc.did_exit() then 
                g_current_state = STATE_WAITING_FOR_PROCESS 
                return 
            end
            
            local client_dll = proc.find_module("client.dll")
            if client_dll and client_dll ~= 0 then
                local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
                
                local local_controller = proc.read_int64(client_dll + offsets.dwLocalPlayerController)

                if (local_pawn and local_pawn ~= 0) or (local_controller and local_controller ~= 0) then
                    engine.log("Match Found. Starting transition...", 255, 0, 0, 255)
                    g_current_state = STATE_TRANSITION
                end
            end
        end
    end
end)

function InitializeFeatures()

    if not table.unpack then table.unpack = _G.unpack end 

        local key_mode = {
        always = 0,
        hold = 1,
        toggle = 2,
        onhotkey = 1,   
        single = 3
    }

local MenuLib = { version = "4.4", current_config = "Default" }

local function round(n, p)
    p = 10^(p or 0)
    return math.floor(n * p + 0.5) / p
end

function MenuLib.hsv_to_rgb(h, s, v, a)
    h, s, v, a = h or 0, s or 0, v or 0, a or 255
    local r, g, b
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    i = i % 6
    if i == 0 then r, g, b = v, t, p elseif i == 1 then r, g, b = q, v, p elseif i == 2 then r, g, b = p, v, t elseif i == 3 then r, g, b = p, q, v elseif i == 4 then r, g, b = t, p, v elseif i == 5 then r, g, b = v, p, q end
    return round(r * 255), round(g * 255), round(b * 255), round(a)
end

function MenuLib.rgb_to_hsv(r, g, b)
    r, g, b = (r or 0) / 255, (g or 0) / 255, (b or 0) / 255
    local max, min = math.max(r, g, b), math.min(r, g, b)
    local h, s, v = 0, 0, max
    local d = max - min
    if max ~= 0 then s = d / max end
    if max ~= min then
        if max == r then h = (g - b) / d + (g < b and 6 or 0) elseif max == g then h = (b - r) / d + 2 else h = (r - g) / d + 4 end
        h = h / 6
    end
    return h, s, v
end



local Menu = { initialized = false, visible = false, key = 0x2D, current_theme = "default",theme_anim = {
        is_transitioning = false,
        progress = 0,
        speed = 0.05, 
        source_colors = {},
        target_colors = {}
    },active_tab = nil, active_sub_tab = nil, active_binding_element = nil, active_input_element = nil, active_select_element = nil, click_consumed = false, tab_anim_y = 0, tabs = {}, elements = {}, values = {}, groups = {}, anim = { alpha = 0, target_alpha = 0, speed = 0.1 }, window = { x = 0, y = 0, w = 620, h = 750, dragging = false, drag_x = 0, drag_y = 0 }, fonts = {}, colors = { bg_dark = { 22, 23, 27 }, bg_mid = { 35, 37, 43 }, bg_light = { 50, 52, 60 }, text_main = { 220, 220, 220 }, text_dim = { 150, 150, 150 }, accent = { 255, 0, 0 } }, info_window = { visible = false, x = 0, y = 0, w = 350, h = 220, dragging = false, drag_x = 0, drag_y = 0, anim = { alpha = 0, target_alpha = 0, speed = 0.15 } }, color_pickers = {}, keybind_mode_selector = { visible = false, element_id = nil, x = 0, y = 0, w = 110, anim = { alpha = 0, target_alpha = 0, speed = 0.2 }, items = { "Hold", "Toggle", "Single Press" }, item_h = 22 } }
local VK_NAMES = {[0x01]="M1",[0x02]="M2",[0x04]="M3",[0x05]="M4",[0x06]="M5",[0x08]="Bsp",[0x09]="Tab",[0x0D]="Enter",[0x10]="Shift",[0x11]="Ctrl",[0x12]="Alt",[0x13]="Pause",[0x14]="Caps",[0x1B]="Esc",[0x20]="Space",[0x21]="PgUp",[0x22]="PgDown",[0x23]="End",[0x24]="Home",[0x25]="Left",[0x26]="Up",[0x27]="Right",[0x28]="Down",[0x2D]="Ins",[0x2E]="Del",[0x30]="0",[0x31]="1",[0x32]="2",[0x33]="3",[0x34]="4",[0x35]="5",[0x36]="6",[0x37]="7",[0x38]="8",[0x39]="9",[0x41]="A",[0x42]="B",[0x43]="C",[0x44]="D",[0x45]="E",[0x46]="F",[0x47]="G",[0x48]="H",[0x49]="I",[0x4A]="J",[0x4B]="K",[0x4C]="L",[0x4D]="M",[0x4E]="N",[0x4F]="O",[0x50]="P",[0x51]="Q",[0x52]="R",[0x53]="S",[0x54]="T",[0x55]="U",[0x56]="V",[0x57]="W",[0x58]="X",[0x59]="Y",[0x5A]="Z",[0x60]="Num0",[0x61]="Num1",[0x62]="Num2",[0x63]="Num3",[0x64]="Num4",[0x65]="Num5",[0x66]="Num6",[0x67]="Num7",[0x68]="Num8",[0x69]="Num9",[0x6A]="Num*",[0x6B]="Num+",[0x6C]="NumEnter",[0x6D]="Num-",[0x6E]="Num.",[0x6F]="Num/",[0x70]="F1",[0x71]="F2",[0x72]="F3",[0x73]="F4",[0x74]="F5",[0x75]="F6",[0x76]="F7",[0x77]="F8",[0x78]="F9",[0x79]="F10",[0x7A]="F11",[0x7B]="F12",[0x90]="NumLk",[0x91]="ScrLk",[0xBA]=";",[0xBB]="=",[0xBC]=",",[0xBD]="-",[0xBE]=".",[0xBF]="/",[0xC0]="`",[0xDB]="[",[0xDC]="\\",[0xDD]="]",[0xDE]="'" }
local function get_key_name(vk) if vk and vk > 0 then return VK_NAMES[vk] or string.format("K:0x%X", vk) end return "NONE" end
local VK_TO_CHAR = { [0x30] = { normal = "0", shifted = ")" },[0x31]={ normal = "1", shifted = "!" },[0x32]={ normal = "2", shifted = "@" },[0x33]={ normal = "3", shifted = "#" },[0x34]={ normal = "4", shifted = "$" },[0x35]={ normal = "5", shifted = "%" },[0x36]={ normal = "6", shifted = "^" },[0x37]={ normal = "7", shifted = "&" },[0x38]={ normal = "8", shifted = "*" },[0x39]={ normal = "9", shifted = "(" },[0x41]={ normal = "a", shifted = "A" },[0x42]={ normal = "b", shifted = "B" },[0x43]={ normal = "c", shifted = "C" },[0x44]={ normal = "d", shifted = "D" },[0x45]={ normal = "e", shifted = "E" },[0x46]={ normal = "f", shifted = "F" },[0x47]={ normal = "g", shifted = "G" },[0x48]={ normal = "h", shifted = "H" },[0x49]={ normal = "i", shifted = "I" },[0x4A]={ normal = "j", shifted = "J" },[0x4B]={ normal = "k", shifted = "K" },[0x4C]={ normal = "l", shifted = "L" },[0x4D]={ normal = "m", shifted = "M" },[0x4E]={ normal = "n", shifted = "N" },[0x4F]={ normal = "o", shifted = "O" },[0x50]={ normal = "p", shifted = "P" },[0x51]={ normal = "q", shifted = "Q" },[0x52]={ normal = "r", shifted = "R" },[0x53]={ normal = "s", shifted = "S" },[0x54]={ normal = "t", shifted = "T" },[0x55]={ normal = "u", shifted = "U" },[0x56]={ normal = "v", shifted = "V" },[0x57]={ normal = "w", shifted = "W" },[0x58]={ normal = "x", shifted = "X" },[0x59]={ normal = "y", shifted = "Y" },[0x5A]={ normal = "z", shifted = "Z" },[0x20]={ normal = " ", shifted = " " },[0xBA]={ normal = ";", shifted = ":" },[0xBB]={ normal = "=", shifted = "+" },[0xBC]={ normal = ",", shifted = "<" },[0xBD]={ normal = "-", shifted = "_" },[0xBE]={ normal = ".", shifted = ">" },[0xBF]={ normal = "/", shifted = "?" },[0xC0]={ normal = "`", shifted = "~" },[0xDB]={ normal = "[", shifted = "{" },[0xDC]={ normal = "\\", shifted = "|" },[0xDD]={ normal = "]", shifted = "}" },[0xDE]={ normal = "'", shifted = '"' } }


local themes = {
    default = {
        name = "Default",
        colors = { 
            bg_dark = { 22, 23, 27 }, bg_mid = { 35, 37, 43 }, bg_light = { 50, 52, 60 }, 
            text_main = { 220, 220, 220 }, text_dim = { 150, 150, 150 }, 
            accent = { 255, 0, 0 } 
        },
        fonts = { title = nil }
    },
    halloween = {
        name = "Halloween",
        colors = { 
            bg_dark = { 18, 15, 12 }, bg_mid = { 35, 30, 25 }, bg_light = { 55, 50, 45 }, 
            text_main = { 240, 240, 240 }, text_dim = { 160, 160, 160 }, 
            accent = { 255, 140, 0 } 
        },
        fonts = { title = nil }
    },
    cyberpunk = {
        name = "Cyberpunk",
        colors = {
            bg_dark = { 10, 12, 30 }, bg_mid = { 20, 25, 50 }, bg_light = { 30, 35, 65 },
            text_main = { 220, 220, 255 }, text_dim = { 140, 140, 180 },
            accent = { 0, 255, 255 } 
        },
        fonts = { title = nil }
    },
    ocean = {
        name = "Ocean",
        colors = {
            bg_dark = { 15, 25, 35 }, bg_mid = { 25, 40, 55 }, bg_light = { 40, 60, 75 },
            text_main = { 210, 225, 240 }, text_dim = { 130, 150, 170 },
            accent = { 60, 180, 220 }
        },
        fonts = { title = nil }
    },
    vampire = {
        name = "Vampire",
        colors = {
            bg_dark = { 15, 15, 20 }, bg_mid = { 28, 25, 30 }, bg_light = { 45, 40, 45 },
            text_main = { 220, 210, 210 }, text_dim = { 150, 140, 140 },
            accent = { 180, 20, 40 }
        },
        fonts = { title = nil }
    },
    obsidian = {
        name = "Obsidian",
        colors = {
            bg_dark = { 12, 12, 14 }, bg_mid = { 20, 20, 24 }, bg_light = { 35, 35, 42 },
            text_main = { 230, 230, 235 }, text_dim = { 120, 120, 130 },
            accent = { 147, 112, 219 } -- Medium Purple
        },
        fonts = { title = nil }
    },
    quartz = {
        name = "Quartz",
        colors = {
            bg_dark = { 28, 30, 36 }, bg_mid = { 40, 44, 52 }, bg_light = { 60, 65, 75 },
            text_main = { 245, 245, 250 }, text_dim = { 160, 165, 175 },
            accent = { 255, 160, 180 } -- Rose Quartz Pink
        },
        fonts = { title = nil }
    },
    gameception = {
        name = "Gameception",
        colors = {
            bg_dark = { 10, 10, 10 },    -- Sidebar background
            bg_mid = { 16, 16, 16 },     -- Main content background
            bg_light = { 40, 40, 40 },   -- Inactive elements
            text_main = { 220, 220, 220 },
            text_dim = { 150, 150, 150 },
            accent = { 139, 195, 74 }    -- The specific Green from your screenshot
        },
        fonts = { title = nil }, 
        style = {
            rainbow_bar = true,      -- Top rainbow strip
            square_corners = true,   -- 0 rounding on groups
            legacy_checkbox = true,  -- Square checkboxes
            flat_slider = true,      -- Thin, flat sliders
            sidebar_icons = true,    -- Icon-only sidebar
            group_outlined = true    -- Thin outlines on groups
        }
    }
}





function MenuLib.initialize(config)
    config = config or {}
    local sw, sh = render.get_viewport_size()

    Menu.window.w = S(780)
    Menu.window.h = S(750)
    Menu.window.x, Menu.window.y = sw / 2 - Menu.window.w / 2, sh / 2 - Menu.window.h / 2
    Menu.active_tab = config.default_tab or ""
    
    Menu.fonts.main = render.create_font("Verdana", S(12), 500)
    Menu.fonts.keybind = render.create_font("Verdana", S(11), 500)
    Menu.fonts.tab = render.create_font("Verdana", S(14), 500)
    Menu.fonts.group = render.create_font("Verdana", S(12), 700)
    Menu.fonts.title = render.create_font("Verdana", S(22), 400)

    themes.default.fonts.title = render.create_font("Verdana", S(22), 400)
    themes.halloween.fonts.title = render.create_font("Verdana", S(22), 400)
    themes.cyberpunk.fonts.title = render.create_font("Verdana", S(22), 400)
    themes.ocean.fonts.title = render.create_font("Verdana", S(22), 400)
    themes.vampire.fonts.title = render.create_font("Verdana", S(22), 400)
    themes.obsidian.fonts.title = render.create_font("Verdana", S(22), 400) 
    themes.quartz.fonts.title = render.create_font("Verdana", S(22), 400)   
    
    for name, theme in pairs(themes) do
        if not theme.fonts.title then
            engine.log(string.format("Warning: Font for '%s' theme failed to load. Using default.", name), 255, 200, 100, 255)
        end
    end

    MenuLib.set_theme(Menu.current_theme)
    
    engine.register_on_engine_tick(MenuLib.render_all)
    Menu.initialized = true
end

local function update_theme_animation()
    local anim = Menu.theme_anim
    if not anim.is_transitioning then return end
    
    anim.progress = math.min(1.0, anim.progress + anim.speed)
    
    for key, source_rgb in pairs(anim.source_colors) do
        local target_rgb = anim.target_colors[key]
        if target_rgb then
            local new_rgb = {}
            new_rgb[1] = math.floor(math.lerp(source_rgb[1], target_rgb[1], anim.progress))
            new_rgb[2] = math.floor(math.lerp(source_rgb[2], target_rgb[2], anim.progress))
            new_rgb[3] = math.floor(math.lerp(source_rgb[3], target_rgb[3], anim.progress))
            Menu.colors[key] = new_rgb
        end
    end
    
    if anim.progress >= 1.0 then
        anim.is_transitioning = false
    end
end


function MenuLib.set_theme(theme_name)
    local theme = themes[theme_name]
    if not theme or Menu.current_theme == theme_name or Menu.theme_anim.is_transitioning then 
        return 
    end

    Menu.fonts.title = theme.fonts.title or themes.default.fonts.title
    Menu.current_theme = theme_name
    
    local anim = Menu.theme_anim
    
    anim.source_colors = {}
    for k, v in pairs(Menu.colors) do
        anim.source_colors[k] = { v[1], v[2], v[3] }
    end
    
    anim.target_colors = theme.colors
    
    anim.progress = 0
    anim.is_transitioning = true
    
end

function MenuLib.add_tab(id, name)
    table.insert(Menu.tabs, {id = id, name = name, anim = 0})
    if not Menu.active_tab or Menu.active_tab == "" then
        Menu.active_tab = id
    end
end

Menu.group_counter = 0 


function MenuLib.add_group(parent_id, name, column)
    Menu.group_counter = (Menu.group_counter or 0) + 1
    local id = parent_id .. "_" .. name
    Menu.groups[id] = {
        id = id, 
        name = name, 
        tab = parent_id, 
        col = column or 1, 
        elements = {}, 
        index = Menu.group_counter 
    }
    return id
end

function MenuLib.add_element(group_id, type, id, name, config)
    config = config or {}
    local group = Menu.groups[group_id]
    if not group then return end
    local el = {id = id, type = type, name = name, anim = 0,  is_active = true}
    if type == "checkbox" then
        el.draw = MenuLib.draw_checkbox
        Menu.values[id] = config.default or false
    elseif type == "slider" then
        el.min, el.max, el.drag = config.min or 0, config.max or 100, false
        el.draw = MenuLib.draw_slider
        Menu.values[id] = config.default or el.min
    elseif type == "slider_float" then
        el.min, el.max, el.drag = config.min or 0, config.max or 100, false
        el.draw = MenuLib.draw_slider_float
        Menu.values[id] = config.default or el.min
    elseif type == "keybind" then
        el.binding = false
        el.draw = MenuLib.draw_keybind
        Menu.values[id] = {key = config.default_key or 0, mode = config.default_mode or 1}
    elseif type == "label" then
        el.draw = MenuLib.draw_label
    elseif type == "input_text" then
        el.draw = MenuLib.draw_input_text
        Menu.values[id] = config.default or ""
    elseif type == "button" then
        el.draw = MenuLib.draw_button
        el.callback = config.callback or function() end
    elseif type == "singleselect" then
        el.draw = MenuLib.draw_singleselect
        el.items = config.items or {}
        Menu.values[id] = config.default or 1
        el.onChange = config.onChange
    elseif type == "multiselect" then
        el.draw = MenuLib.draw_multiselect
        el.items = config.items or {}
        Menu.values[id] = config.default or {}
    elseif type == "colorpicker_button" then
        el.draw = MenuLib.draw_colorpicker_button
        local default_rgba = config.default or {255, 255, 255, 255}
        local h, s, v = MenuLib.rgb_to_hsv(default_rgba[1], default_rgba[2], default_rgba[3])
        Menu.values[id] = {h = h, s = s, v = v, a = default_rgba[4]}
        Menu.color_pickers[id] = {id = id, title = name, visible = false, x = 0, y = 0, w = 240, h = 270, dragging = false, drag_x = 0, drag_y = 0, dragging_sv = false, dragging_hue = false, dragging_alpha = false, anim = {alpha = 0, target_alpha = 0, speed = 0.15}}
    end
    table.insert(group.elements, el)
    Menu.elements[id] = el
end

function MenuLib.get_keybind_value(id)
    local default_bind = { key = 0, mode = 1 }
    local stored_bind = Menu.values[id]

    if type(stored_bind) ~= "table" then
        return default_bind
    end
    
    local key_is_valid = type(stored_bind.key) == "number"
    local mode_is_valid = type(stored_bind.mode) == "number"

    return {
        key = key_is_valid and stored_bind.key or default_bind.key,
        mode = mode_is_valid and stored_bind.mode or default_bind.mode
    }
end

function MenuLib.get_value(id)
    local value = Menu.values[id]
    if type(value) == "table" and value.h ~= nil then
        local r, g, b, a = MenuLib.hsv_to_rgb(value.h, value.s, value.v, value.a)
        return {r, g, b, a}
    end
    return value
end

function MenuLib.set_value(id, value)
    if Menu.values[id] ~= nil then
        Menu.values[id] = value
    end
end

function MenuLib.render_all()
    local cs2_hwnd = find_window("Counter-Strike 2", "SDL_app")
    if not cs2_hwnd then 
        cs2_hwnd = find_window("Counter-Strike 2") 
    end

    if cs2_hwnd and not is_foreground_window(cs2_hwnd) then
        return
    end

    if not Menu.initialized then return end
    update_theme_animation()

    MenuLib.render_menu()

    if Menu.visible and Menu.active_tab == "visuals" then
        if Menu.active_sub_tab == "vis_enemy" or Menu.active_sub_tab == "vis_team" then
            draw_esp_placeholder()
        end
    end

    for _, picker in pairs(Menu.color_pickers) do
        MenuLib.render_single_color_picker(picker)
    end

    MenuLib.render_keybind_mode_selector()
    if MenuLib.Notify then 
        MenuLib.Notify.render()
    end
end

function MenuLib.render_keybind_mode_selector()
    local selector = Menu.keybind_mode_selector
    selector.anim.target_alpha = selector.visible and Menu.anim.alpha > 0.99 and 1 or 0
    selector.anim.alpha = math.lerp(selector.anim.alpha, selector.anim.target_alpha, selector.anim.speed)
    if selector.anim.alpha < 0.01 then return end
    local a = math.floor(255 * selector.anim.alpha)
    local c = Menu.colors
    local mx, my = input.get_mouse_position()
    selector.h = #selector.items * selector.item_h + 10
    render.draw_rectangle(selector.x + 2, selector.y + 2, selector.w, selector.h, 0, 0, 0, math.floor(80 * (a / 255)), 0, true, 4)
    render.draw_rectangle(selector.x, selector.y, selector.w, selector.h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], a, 0, true, 4)
    render.draw_rectangle(selector.x, selector.y, selector.w, selector.h, c.bg_light[1], c.bg_light[2], c.bg_light[3], a, 1, false, 4)
    local current_y = selector.y + 5
    for i, item in ipairs(selector.items) do
        local hov = mx > selector.x and mx < selector.x + selector.w and my > current_y and my < current_y + selector.item_h
        if hov then
            render.draw_rectangle(selector.x + 2, current_y, selector.w - 4, selector.item_h, c.accent[1], c.accent[2], c.accent[3], a, 0, true, 4)
        end
        render.draw_text(Menu.fonts.main, item, selector.x + 10, current_y + 3, c.text_main[1], c.text_main[2], c.text_main[3], a, 0, 0, 0, 0, 0)
        if hov and input.is_key_pressed(1) then
            if selector.element_id and Menu.values[selector.element_id] then
                Menu.values[selector.element_id].mode = i
            end
            selector.visible = false
            Menu.click_consumed = true
        end
        current_y = current_y + selector.item_h
    end
end


local function draw_rainbow_stripe(x, y, w, h)
    local steps = 100
    local step_w = math.ceil(w / steps)
    
    for i = 0, steps - 1 do
        local hue = i / steps
        local r, g, b = MenuLib.hsv_to_rgb(hue, 0.8, 1.0, 255)
        
        local a = 255
        if i < 15 then a = math.floor(255 * (i/15)) 
        elseif i > steps - 15 then a = math.floor(255 * ((steps-i)/15)) end
        
        render.draw_rectangle(x + (i * step_w), y, step_w, h, r, g, b, a, 0, true)
    end
end




function MenuLib.render_menu()
    if not IsCS2Active() then return end

    local render_after_queue = {}
    Menu.click_consumed = false

   local menu_bind = MenuLib.get_keybind_value("menu_open_key")
    if menu_bind and input.is_key_pressed(menu_bind.key) then
        Menu.visible = not Menu.visible
        if not Menu.visible then
            for _, p in pairs(Menu.color_pickers) do p.visible = false end
            Menu.keybind_mode_selector.visible = false
        end
    end

    Menu.anim.target_alpha = Menu.visible and 1 or 0
    Menu.anim.alpha = math.lerp(Menu.anim.alpha, Menu.anim.target_alpha, Menu.anim.speed)
    
    if Menu.anim.alpha < 0.01 then
        if Menu.window.dragging then Menu.window.dragging = false end
        MenuLib.render_info_window()
        return
    end

    Menu.window.w = S(780)
    Menu.window.h = S(750)

    local w, a, s = Menu.window, math.floor(255 * Menu.anim.alpha), S(20) * (1 - Menu.anim.alpha)
    local mx, my = input.get_mouse_position()
    local c = Menu.colors
    
    local cur_theme = themes[Menu.current_theme]
    local is_gc = cur_theme and cur_theme.style and cur_theme.style.rainbow_bar
    local rounding = is_gc and 0 or 8 

    local sidebar_w = S(180)
    local content_start_x = w.x + sidebar_w


    if not w.dragging and input.is_key_pressed(1) and 
       mx > w.x and mx < w.x + sidebar_w and 
       my > w.y and my < w.y + S(60) and 
       not Menu.click_consumed then
        w.dragging, w.drag_x, w.drag_y = true, mx - w.x, my - w.y
        Menu.click_consumed = true
    end
    if not input.is_key_down(1) then w.dragging = false end
    if w.dragging then w.x, w.y = mx - w.drag_x, my - w.drag_y end
    
    render.draw_rectangle(w.x + 4, w.y + 4, w.w, w.h, 0, 0, 0, 80 * (a / 255), 12, true)
    if is_gc then draw_rainbow_stripe(w.x, w.y - 2, w.w, 2) end

    render.draw_rectangle(content_start_x, w.y, w.w - sidebar_w, w.h, c.bg_mid[1], c.bg_mid[2], c.bg_mid[3], a, 0, true, rounding) 
    if not is_gc then render.draw_rectangle(content_start_x, w.y, 10, w.h, c.bg_mid[1], c.bg_mid[2], c.bg_mid[3], a, 0, true, 0) end

    render.draw_rectangle(w.x, w.y, sidebar_w, w.h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], a, 0, true, rounding)
    if not is_gc then render.draw_rectangle(w.x + sidebar_w - 10, w.y, 10, w.h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], a, 0, true, 0) end
    render.draw_line(w.x + sidebar_w, w.y, w.x + sidebar_w, w.y + w.h, 60, 60, 70, math.floor(a * 0.5), 1)

    local title_txt = is_gc and "gameception" or "TSIDE"
    render.draw_text(Menu.fonts.title, title_txt, w.x + S(25), w.y + S(30) - s, 255, 255, 255, a, 0, 0, 0, 0, 0)
    local ver_x = w.x + S(105); if is_gc then ver_x = w.x + S(160) end
    render.draw_text(Menu.fonts.keybind, "v" .. MenuLib.version, ver_x, w.y + S(38) - s, c.accent[1], c.accent[2], c.accent[3], a, 0, 0, 0, 0, 0)
    
    if not is_gc then render.draw_gradient_rectangle(w.x + S(20), w.y + S(65) - s, sidebar_w - S(40), 1, {{60,60,70, a}, {60,60,70, 0}}, 0)
    else render.draw_line(w.x, w.y + S(65), w.x + sidebar_w, w.y + S(65), 40, 40, 40, a, 1) end

    local tab_h = S(38)
    local start_tab_y = w.y + S(90) - s
    if Menu.active_tab == "" and #Menu.tabs > 0 then Menu.active_tab = Menu.tabs[1].id end
    
    local active_main_tab = nil
    for i, tab in ipairs(Menu.tabs) do
        local cur_y = start_tab_y + (i-1) * (tab_h + S(4))
        local btn_w, btn_x = sidebar_w - S(30), w.x + S(15)
        local hov = mx > btn_x and mx < btn_x + btn_w and my > cur_y and my < cur_y + tab_h
        local act = Menu.active_tab == tab.id
        if act then active_main_tab = tab end
        
        tab.anim = math.lerp(tab.anim or 0, act and 1 or 0, 0.15)
        tab.hover_anim = math.lerp(tab.hover_anim or 0, hov and 1 or 0, 0.15)
        
        if is_gc then
            if act then render.draw_rectangle(btn_x, cur_y, btn_w, tab_h, 30, 30, 30, a, 0, true, 0); render.draw_rectangle(btn_x, cur_y, 3, tab_h, c.accent[1], c.accent[2], c.accent[3], a, 0, true, 0)
            elseif hov then render.draw_rectangle(btn_x, cur_y, btn_w, tab_h, 255, 255, 255, math.floor(10 * (a/255)), 0, true, 0) end
        else
            if not act and tab.hover_anim > 0.01 then render.draw_rectangle(btn_x, cur_y, btn_w, tab_h, 255, 255, 255, math.floor(10 * tab.hover_anim * (a/255)), 0, true, 6) end
            if tab.anim > 0.01 then
                render.draw_gradient_rectangle(btn_x, cur_y, btn_w, tab_h, {{c.accent[1], c.accent[2], c.accent[3], math.floor(30 * tab.anim * (a/255))}, {c.accent[1], c.accent[2], c.accent[3], 0}}, 6)
                render.draw_rectangle(btn_x, cur_y + S(8), 3, tab_h - S(16), c.accent[1], c.accent[2], c.accent[3], math.floor(a * tab.anim), 0, true, 2)
            end
        end
        
        local t_r, t_g, t_b = math.lerp(c.text_dim[1], 255, tab.anim), math.lerp(c.text_dim[2], 255, tab.anim), math.lerp(c.text_dim[3], 255, tab.anim)
        render.draw_text(Menu.fonts.tab, tab.name, btn_x + S(10) + (S(6) * tab.anim), cur_y + S(9), math.floor(t_r), math.floor(t_g), math.floor(t_b), a, 0, 0, 0, 0, 0)
        
        if hov and input.is_key_pressed(1) and not Menu.click_consumed then
            Menu.active_tab = tab.id
            if tab.sub_tabs and #tab.sub_tabs > 0 then Menu.active_sub_tab = tab.sub_tabs[1].id else Menu.active_sub_tab = nil end
            Menu.click_consumed = true
        end
    end

    local user_y = w.y + w.h - S(75)
    if is_gc then render.draw_line(w.x, user_y, w.x + sidebar_w, user_y, 40, 40, 40, a, 1)
    else render.draw_gradient_rectangle(w.x + S(15), user_y - 1, sidebar_w - S(30), 1, {{60,60,70, 0}, {60,60,70, a}, {60,60,70, 0}}, 0) end
    render.draw_circle(w.x + S(40), user_y + S(30), S(18), 35, 35, 40, a, 0, true)
    if not is_gc then render.draw_circle(w.x + S(40), user_y + S(30), S(18), 60, 60, 70, a, 1, false) end
    render.draw_text(Menu.fonts.title, "S", w.x + S(33), user_y + S(18), c.accent[1], c.accent[2], c.accent[3], a, 0, 0, 0, 0, 0)
    render.draw_text(Menu.fonts.group, get_user_name(), w.x + S(70), user_y + S(15), 255, 255, 255, a, 0, 0, 0, 0, 0)
    render.draw_text(Menu.fonts.keybind, "Lifetime", w.x + S(70), user_y + S(32), 100, 255, 100, a, 0, 0, 0, 0, 0)

    if active_main_tab and active_main_tab.sub_tabs then
        local sub_tab_bar_y, current_x = w.y + S(20), w.x + sidebar_w + S(30)
        for _, sub_tab in ipairs(active_main_tab.sub_tabs) do
            local text_w, text_h = render.measure_text(Menu.fonts.main, sub_tab.name)
            local is_active = Menu.active_sub_tab == sub_tab.id
            local is_hovered = mx > current_x and mx < current_x + text_w + 10 and my > sub_tab_bar_y and my < sub_tab_bar_y + text_h + 4
            
            local tr, tg, tb = c.text_dim[1], c.text_dim[2], c.text_dim[3]
            if is_active then tr, tg, tb = c.accent[1], c.accent[2], c.accent[3] elseif is_hovered then tr, tg, tb = 255, 255, 255 end
            
            render.draw_text(Menu.fonts.main, sub_tab.name, current_x + 5, sub_tab_bar_y + 2, tr, tg, tb, a, 0, 0, 0, 0, 0)
            sub_tab.anim = math.lerp(sub_tab.anim or 0, is_active and 1 or 0, 0.2)
            if sub_tab.anim > 0.01 then 
                local bar_w = (text_w + 10) * sub_tab.anim
                render.draw_rectangle(current_x + ((text_w + 10) - bar_w) / 2, sub_tab_bar_y + text_h + 4, bar_w, 2, c.accent[1], c.accent[2], c.accent[3], math.floor(sub_tab.anim * a), 0, true, 1) 
            end
            
            if is_hovered and input.is_key_pressed(1) and not Menu.click_consumed then
                Menu.active_sub_tab = sub_tab.id; Menu.click_consumed = true
            end
            current_x = current_x + text_w + S(25)
        end
    end

    local content_start_y = w.y + (active_main_tab and active_main_tab.sub_tabs and S(60) or S(30)) - s
    local content_start_x_real = w.x + sidebar_w
    local content_view_w = w.w - sidebar_w
    local content_view_h = (w.y + w.h) - content_start_y - S(15) 
    
    local tab_key = Menu.active_tab .. (Menu.active_sub_tab or "")
    if not Menu.tab_scrolls then Menu.tab_scrolls = {} end
    if not Menu.tab_heights then Menu.tab_heights = {} end
    if not Menu.scrollbar_dragging then Menu.scrollbar_dragging = false end
    
    local total_h = Menu.tab_heights[tab_key] or 0
    local max_scroll = math.max(0, total_h - content_view_h + S(30))
    local scroll_val = Menu.tab_scrolls[tab_key] or 0

    if mx > content_start_x_real and mx < w.x + w.w and my > content_start_y and my < w.y + w.h then
        local delta = input.get_scroll_delta()
        if delta ~= 0 then
            scroll_val = math.clamp(scroll_val - (delta * 40), 0, max_scroll)
            Menu.tab_scrolls[tab_key] = scroll_val
        end
    end

    if max_scroll > 0 then
        local sb_w, sb_x = S(6), w.x + w.w - S(10)
        local sb_y, sb_h = content_start_y, content_view_h
        local thumb_ratio = sb_h / (total_h + S(50))
        local thumb_h = math.max(S(20), sb_h * thumb_ratio)
        local thumb_y = sb_y + (scroll_val / max_scroll) * (sb_h - thumb_h)
        
        render.draw_rectangle(sb_x, sb_y, sb_w, sb_h, 30, 30, 35, a, 3, true)
        
        local mouse_over_thumb = mx >= sb_x - 4 and mx <= sb_x + sb_w + 4 and my >= thumb_y and my <= thumb_y + thumb_h
        if input.is_key_pressed(1) and mouse_over_thumb then 
            Menu.scrollbar_dragging = true
            Menu.scrollbar_drag_offset = my - thumb_y
            Menu.click_consumed = true
        end
        
        if input.is_key_down(1) and Menu.scrollbar_dragging then
            local new_y = my - (Menu.scrollbar_drag_offset or 0)
            local progress = (new_y - sb_y) / (sb_h - thumb_h)
            scroll_val = math.clamp(progress * max_scroll, 0, max_scroll)
            Menu.tab_scrolls[tab_key] = scroll_val
        else
            Menu.scrollbar_dragging = false
        end

        local sb_col = Menu.scrollbar_dragging and c.accent or {70, 70, 80}
        render.draw_rectangle(sb_x, thumb_y, sb_w, thumb_h, sb_col[1], sb_col[2], sb_col[3], a, 3, true)
    end

    local sorted_groups = {}
    for _, group in pairs(Menu.groups) do table.insert(sorted_groups, group) end
    table.sort(sorted_groups, function(a, b) return a.index < b.index end)

    local col_1_y, col_2_y = 0, 0
    local group_width, col_gap = S(260), S(20)
    local x1 = content_start_x_real + S(30)
    local x2 = x1 + group_width + col_gap
    local GROUP_HEADER_H, ELEMENT_PADDING, GROUP_PADDING_X = S(32), S(5), S(10)

    render.clip_start(math.floor(content_start_x_real), math.floor(content_start_y), math.floor(content_view_w), math.floor(content_view_h))

    local can_interact_with_content = (mx > content_start_x_real and mx < w.x + w.w and my > content_start_y and my < content_start_y + content_view_h)

    for _, group in ipairs(sorted_groups) do
        local should_draw = false
        if active_main_tab and active_main_tab.sub_tabs then
            if group.tab == Menu.active_sub_tab then should_draw = true end
        else
            if group.tab == Menu.active_tab then should_draw = true end
        end
        
        if should_draw then
            local g_x = (group.col == 1) and x1 or x2
            local g_y_offset = (group.col == 1) and col_1_y or col_2_y
            local draw_y = content_start_y + g_y_offset - scroll_val

            local active_elements_h = 0
            for _, el in ipairs(group.elements) do
                if el.is_active then
                    local h = el.h or S(24) 
                    if el.type == "slider" or el.type == "slider_float" then h = S(38)
                    elseif el.type == "singleselect" or el.type == "multiselect" or el.type == "input_text" then h = S(45)
                    elseif el.type == "button" then h = S(30)
                    elseif el.type == "label" then h = S(20) end
                    active_elements_h = active_elements_h + h + ELEMENT_PADDING
                end
            end
            local group_h = GROUP_HEADER_H + active_elements_h + S(10)

            if (draw_y + group_h > content_start_y) and (draw_y < content_start_y + content_view_h) then
                if is_gc then
                    render.draw_rectangle(g_x, draw_y, group_width, group_h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], a, 0, true, 0)
                    render.draw_rectangle(g_x, draw_y, group_width, group_h, 50, 50, 50, a, 1, false, 0)
                    render.draw_rectangle(g_x, draw_y + GROUP_HEADER_H, group_width, 1, 50, 50, 50, a, 0, true, 0)
                else
                    render.draw_rectangle(g_x, draw_y, group_width, group_h, 22, 23, 27, a, 0, true, rounding)
                    render.draw_line(g_x + 1, draw_y + GROUP_HEADER_H, g_x + group_width - 1, draw_y + GROUP_HEADER_H, 45, 45, 50, a, 1)
                    render.draw_rectangle(g_x, draw_y, group_width, group_h, 60, 60, 65, a, 1, false, rounding)
                end
                render.draw_text(Menu.fonts.group, group.name, g_x + S(10), draw_y + S(8), c.accent[1], c.accent[2], c.accent[3], a, 0, 0, 0, 0, 0)

                local el_y = draw_y + GROUP_HEADER_H + S(8)
                for _, el in ipairs(group.elements) do
                    if el.is_active then
                        if not can_interact_with_content and input.is_key_pressed(1) then
                            local old_consumed = Menu.click_consumed
                            Menu.click_consumed = true 
                            el.draw(el, a, g_x + GROUP_PADDING_X, el_y, mx, my, render_after_queue)
                            Menu.click_consumed = old_consumed
                        else
                            el.draw(el, a, g_x + GROUP_PADDING_X, el_y, mx, my, render_after_queue)
                        end
                        el_y = el_y + el.h + ELEMENT_PADDING
                    end
                end
            end

            if group.col == 1 then col_1_y = col_1_y + group_h + S(15) else col_2_y = col_2_y + group_h + S(15) end
        end
    end
    render.clip_end()

    Menu.tab_heights[tab_key] = math.max(col_1_y, col_2_y)

    local btn_text, btn_size = "?", S(20)
    local btn_x, btn_y = w.x + w.w - btn_size - S(10), w.y + S(10)
    local hov_info = mx > btn_x and mx < btn_x + btn_size and my > btn_y and my < btn_y + btn_size
    local tc = hov_info and c.text_main or c.text_dim
    if hov_info then render.draw_circle(btn_x + btn_size/2, btn_y + btn_size/2, btn_size/2, 60, 60, 70, a, 0, true) end
    render.draw_text(Menu.fonts.group, btn_text, btn_x + 5, btn_y + 2, tc[1], tc[2], tc[3], a, 0, 0, 0, 0, 0)
    
    if hov_info and input.is_key_pressed(1) then 
        Menu.info_window.visible = not Menu.info_window.visible
        if Menu.info_window.visible then 
            local sw,sh=render.get_viewport_size()
            Menu.info_window.x, Menu.info_window.y = sw/2-Menu.info_window.w/2, sh/2-Menu.info_window.h/2 
        end
        Menu.click_consumed=true 
    end
    
    MenuLib.render_info_window()
    
    if input.is_key_pressed(1) and not Menu.click_consumed then 
        if Menu.active_select_element then 
            local el=Menu.elements[Menu.active_select_element]; if el then el.is_open=false end
            Menu.active_select_element=nil 
        end
        if Menu.keybind_mode_selector.visible then 
            local sel=Menu.keybind_mode_selector
            if not(mx>sel.x and mx<sel.x+sel.w and my>sel.y and my<sel.y+sel.h)then sel.visible=false end 
        end 
    end
    for _,f in ipairs(render_after_queue)do f()end
end





local function is_any_picker_open()
    for _, p in pairs(Menu.color_pickers) do
        if p.visible then return true end
    end
    return false
end

local function is_hovering_info_window()
    local iw = Menu.info_window
    if not iw.visible or (iw.anim and iw.anim.alpha < 0.1) then return false end
    
    local mx, my = input.get_mouse_position()
    return mx > iw.x and mx < iw.x + iw.w and my > iw.y and my < iw.y + iw.h
end

local function can_interact(element_id)
    if Menu.click_consumed then return false end
    
    if is_any_picker_open() then 
        return false 
    end

    if is_hovering_info_window() then
        return false
    end

    if Menu.active_select_element and Menu.active_select_element ~= element_id then return false end
    if Menu.active_binding_element and Menu.active_binding_element ~= element_id then return false end
    
    return true
end

function MenuLib.draw_checkbox(opt, a, x, y, mx, my, r_queue)
    opt.h = S(24) 
    local w = S(240)
    local v = Menu.values[opt.id]
    local c = Menu.colors
    local hov = mx > x and mx < x + w and my > y and my < y + opt.h
    
    -- Interaction
    if hov and input.is_key_pressed(1) and can_interact(opt.id) then
        Menu.values[opt.id] = not v
        Menu.click_consumed = true
    end
    
    opt.anim = math.lerp(opt.anim or (v and 1 or 0), v and 1 or 0, 0.15)
    
    local cur_theme = themes[Menu.current_theme]
    local is_legacy = cur_theme and cur_theme.style and cur_theme.style.legacy_checkbox

    if is_legacy then
        -- [[ GAMECEPTION STYLE (Square) ]]
        local box_sz = S(14)
        local box_x = x + 1
        local box_y = y + S(3)
        
        -- Background
        local bg_col = hov and {55, 55, 55} or {45, 45, 45}
        render.draw_rectangle(box_x, box_y, box_sz, box_sz, bg_col[1], bg_col[2], bg_col[3], a, 0, true, 0)
        render.draw_rectangle(box_x, box_y, box_sz, box_sz, 0, 0, 0, 150, 1, false, 0) -- Shadow/Border
        
        -- Check mark / Fill
        if v then
            -- Draw gradient fill
            local r, g, b = c.accent[1], c.accent[2], c.accent[3]
            -- Simple lines for gradient effect
            for i = 0, box_sz - 1 do
                local t = i / (box_sz - 1)
                local dark_factor = 1.0 - (t * 0.3) -- Darken bottom
                render.draw_line(box_x, box_y + i, box_x + box_sz, box_y + i, 
                    math.floor(r*dark_factor), math.floor(g*dark_factor), math.floor(b*dark_factor), a, 1)
            end
        end
        
        -- Label (Next to box)
        render.draw_text(Menu.fonts.main, opt.name, box_x + box_sz + S(8), y + S(2), c.text_main[1], c.text_main[2], c.text_main[3], a, 0, 0, 0, 0, 0)
        
    else
        -- [[ SHOOK STYLE (Toggle Switch) ]]
        local box_w, box_h = S(36), S(18)
        local box_x = x + w - box_w
        local box_y = y + S(1)
        local knob_radius = S(6)
        
        if opt.name then 
            render.draw_text(Menu.fonts.main, opt.name, x, y + S(2), c.text_main[1], c.text_main[2], c.text_main[3], a, 0, 0, 0, 0, 0) 
        end
        
        local bg_r = math.lerp(c.bg_light[1], c.accent[1], opt.anim)
        local bg_g = math.lerp(c.bg_light[2], c.accent[2], opt.anim)
        local bg_b = math.lerp(c.bg_light[3], c.accent[3], opt.anim)
        
        render.draw_rectangle(box_x, box_y, box_w, box_h, math.floor(bg_r), math.floor(bg_g), math.floor(bg_b), a, 0, true, box_h/2)
        
        local knob_start = box_x + box_h/2
        local knob_end   = box_x + box_w - box_h/2
        local knob_x     = math.lerp(knob_start, knob_end, opt.anim)
        
        render.draw_circle(knob_x, box_y + box_h/2, knob_radius, 255, 255, 255, a, 0, true)
    end
end

function MenuLib.draw_slider(opt, a, x, y, mx, my, r_queue)
    opt.h = S(38)
    local w = S(240)
    
    local text_h = S(16)
    local bar_y = y + text_h + S(6)
    local bar_h = S(4)
    local hit_h = S(12) 
    
    local c = Menu.colors
    local hov = mx > x and mx < x + w and my > bar_y - S(4) and my < bar_y + hit_h + S(4)
    
    if hov and input.is_key_pressed(1) and can_interact(opt.id) then
        opt.is_dragging = true; Menu.click_consumed = true
    end
    if not input.is_key_down(1) then opt.is_dragging = false end
    
    if opt.is_dragging then
        local val = math.map(mx, x, x + w, opt.min, opt.max)
        Menu.values[opt.id] = math.clamp(math.round(val), opt.min, opt.max)
        Menu.click_consumed = true
    end

    local v = Menu.values[opt.id]
    local r = (v - opt.min) / (opt.max - opt.min)
    local vs = string.format("%d", v)
    
    opt.anim_ratio = math.lerp(opt.anim_ratio or r, r, 0.2)
    
    if opt.name then 
        render.draw_text(Menu.fonts.main, opt.name, x, y, c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) 
    end
    
    local tw, _ = render.measure_text(Menu.fonts.main, vs)
    render.draw_text(Menu.fonts.main, vs, x + w - tw, y, 255, 255, 255, a, 0, 0, 0, 0, 0)
    
    render.draw_rectangle(x, bar_y, w, bar_h, c.bg_light[1], c.bg_light[2], c.bg_light[3], a, 0, true, 2)
    
    if opt.anim_ratio > 0.01 then 
        render.draw_rectangle(x, bar_y, w * opt.anim_ratio, bar_h, c.accent[1], c.accent[2], c.accent[3], a, 0, true, 2) 
    end
    
    render.draw_circle(x + w * opt.anim_ratio, bar_y + bar_h/2, S(5), 255, 255, 255, a, 0, true)
    if opt.is_dragging or hov then
        render.draw_circle(x + w * opt.anim_ratio, bar_y + bar_h/2, S(9), 255, 255, 255, math.floor(a * 0.1), 0, true)
    end
end

function MenuLib.draw_slider_float(opt, a, x, y, mx, my, r_queue)
    opt.h = S(38)
    local w = S(240)
    
    local text_h = S(16)
    local bar_y = y + text_h + S(6)
    local bar_h = S(4)
    local hit_h = S(12)
    
    local c = Menu.colors
    local hov = mx > x and mx < x + w and my > bar_y - S(4) and my < bar_y + hit_h + S(4)
    
    if hov and input.is_key_pressed(1) and can_interact(opt.id) then
        opt.is_dragging = true; Menu.click_consumed = true
    end
    if not input.is_key_down(1) then opt.is_dragging = false end
    
    if opt.is_dragging then
        local val = math.map(mx, x, x + w, opt.min, opt.max)
        Menu.values[opt.id] = math.clamp(val, opt.min, opt.max)
        Menu.click_consumed = true
    end

    local v = Menu.values[opt.id]
    local r = (v - opt.min) / (opt.max - opt.min)
    local vs = string.format("%.2f", v)
    
    opt.anim_ratio = math.lerp(opt.anim_ratio or r, r, 0.2)
    
    if opt.name then 
        render.draw_text(Menu.fonts.main, opt.name, x, y, c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) 
    end
    
    local tw, _ = render.measure_text(Menu.fonts.main, vs)
    render.draw_text(Menu.fonts.main, vs, x + w - tw, y, 255, 255, 255, a, 0, 0, 0, 0, 0)
    
    render.draw_rectangle(x, bar_y, w, bar_h, c.bg_light[1], c.bg_light[2], c.bg_light[3], a, 0, true, 2)
    if opt.anim_ratio > 0.01 then 
        render.draw_rectangle(x, bar_y, w * opt.anim_ratio, bar_h, c.accent[1], c.accent[2], c.accent[3], a, 0, true, 2) 
    end
    render.draw_circle(x + w * opt.anim_ratio, bar_y + bar_h/2, S(5), 255, 255, 255, a, 0, true)
    if opt.is_dragging or hov then
        render.draw_circle(x + w * opt.anim_ratio, bar_y + bar_h/2, S(9), 255, 255, 255, math.floor(a * 0.1), 0, true)
    end
end

function MenuLib.draw_label(opt, a, x, y, mx, my, r_queue)
    opt.h = S(20)
    local c = Menu.colors
    if opt.name then render.draw_text(Menu.fonts.main, opt.name, x, y, c.text_main[1], c.text_main[2], c.text_main[3], a, 0, 0, 0, 0, 0) end
end

function MenuLib.draw_keybind(opt, a, x, y, mx, my, r_queue)
    opt.h = S(24)
    local w = S(240)
    
    local bind_w = S(90) 
    local bind_x = x + w - bind_w
    local bind_h = S(20)
    
    local c = Menu.colors
    local hov = mx > bind_x and mx < bind_x + bind_w and my > y and my < y + bind_h

    if can_interact(opt.id) then
        if hov and input.is_key_pressed(1) then 
            if Menu.active_binding_element ~= opt.id then 
                Menu.active_binding_element = opt.id
                Menu.keybind_mode_selector.visible = false
                Menu.click_consumed = true 
            end
        end
        if hov and input.is_key_pressed(2) then 
            if Menu.active_binding_element ~= opt.id then
                local selector = Menu.keybind_mode_selector
                if selector.visible and selector.element_id == opt.id then 
                    selector.visible = false
                else 
                    selector.visible = true
                    selector.element_id = opt.id
                    selector.x, selector.y = mx + 5, my
                    Menu.active_binding_element = nil 
                end
                Menu.click_consumed = true
            end
        end
    end

    local keybind_data = Menu.values[opt.id]
    if Menu.active_binding_element == opt.id and not Menu.click_consumed then
        for i = 1, 255 do
            if input.is_key_pressed(i) then 
                keybind_data.key = (i == 0x1B) and 0 or i 
                Menu.active_binding_element = nil
                Menu.click_consumed = true
                break
            end
        end
    end

    local mode_str = Menu.keybind_mode_selector.items[keybind_data.mode] or "Hold"
    local mode_char = mode_str:sub(1, 1) 
    local key_name = (keybind_data.key == 0) and "None" or get_key_name(keybind_data.key)
    
    if mode_str == "Always" then mode_char = "A" end
    
    local display_text = string.format("[%s] %s", mode_char, key_name)
    if Menu.active_binding_element == opt.id then display_text = "Press key..." end

    if opt.name then render.draw_text(Menu.fonts.main, opt.name, x, y + S(2), c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) end
    
    local bg_col = (hov or Menu.active_binding_element == opt.id) and c.bg_light or {28, 28, 33}
    local text_col = (Menu.active_binding_element == opt.id) and c.accent or c.text_dim
    
    render.draw_rectangle(bind_x, y, bind_w, bind_h, bg_col[1], bg_col[2], bg_col[3], a, 0, true, 4)
    if Menu.active_binding_element == opt.id then
        render.draw_rectangle(bind_x, y, bind_w, bind_h, c.accent[1], c.accent[2], c.accent[3], a, 1, false, 4)
    end
    
    local tw, th = render.measure_text(Menu.fonts.keybind, display_text)
    render.draw_text(Menu.fonts.keybind, display_text, bind_x + (bind_w - tw)/2, y + (bind_h - th)/2, text_col[1], text_col[2], text_col[3], a, 0, 0, 0, 0, 0)
end

function MenuLib.draw_singleselect(opt, a, x, y, mx, my, r_queue)
    opt.h = S(45) 
    local w = S(240)
    local box_h = S(22)
    local box_y = y + S(18)
    
    local c = Menu.colors
    local hov = mx > x and mx < x + w and my > box_y and my < box_y + box_h
    
    if can_interact(opt.id) and hov and input.is_key_pressed(1) then
        if opt.is_open then 
            opt.is_open = false
            Menu.active_select_element = nil
        else 
            if Menu.active_select_element and Menu.elements[Menu.active_select_element] then 
                Menu.elements[Menu.active_select_element].is_open = false 
            end
            opt.is_open = true
            Menu.active_select_element = opt.id 
        end
        Menu.click_consumed = true
    end
    
    local selected_index = Menu.values[opt.id] or 1
    local selected_text = (opt.items[selected_index] or "None")
    
    if opt.name then 
        render.draw_text(Menu.fonts.main, opt.name, x, y, c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) 
    end
    
    local border_color = opt.is_open and c.accent or {60, 60, 65}
    local bg_color = {28, 28, 33} 
    
    render.draw_rectangle(x, box_y, w, box_h, bg_color[1], bg_color[2], bg_color[3], a, 0, true, 4)
    if opt.is_open or hov then
        render.draw_rectangle(x, box_y, w, box_h, border_color[1], border_color[2], border_color[3], a, 1, false, 4)
    end
    
    render.draw_text(Menu.fonts.main, selected_text, x + S(8), box_y + S(3), 220, 220, 220, a, 0, 0, 0, 0, 0)
    
    local arrow_x = x + w - S(15)
    local arrow_y = box_y + S(9)
    if opt.is_open then
        render.draw_triangle(arrow_x, arrow_y + 3, arrow_x + 6, arrow_y + 3, arrow_x + 3, arrow_y, 200, 200, 200, a, 1, true)
    else
        render.draw_triangle(arrow_x, arrow_y, arrow_x + 6, arrow_y, arrow_x + 3, arrow_y + 3, 150, 150, 150, a, 1, true)
    end
    
    if opt.is_open then
        table.insert(r_queue, function()
            local list_y = box_y + box_h + 2
            local list_h = #opt.items * box_h
            
            render.draw_rectangle(x + 2, list_y + 2, w, list_h, 0, 0, 0, 100, 4, true)
            render.draw_rectangle(x, list_y, w, list_h, 25, 25, 30, a, 0, true, 4)
            render.draw_rectangle(x, list_y, w, list_h, c.accent[1], c.accent[2], c.accent[3], a, 1, false, 4)
            
            for i, item in ipairs(opt.items) do
                local item_y = list_y + (i - 1) * box_h
                local item_hov = mx > x and mx < x + w and my > item_y and my < item_y + box_h
                local is_sel = (i == selected_index)
                
                if item_hov or is_sel then 
                    render.draw_rectangle(x + 1, item_y, w - 2, box_h, c.accent[1], c.accent[2], c.accent[3], is_sel and 200 or 100, 0, true, 2) 
                end
                
                local tc = (is_sel or item_hov) and {255, 255, 255} or c.text_dim
                render.draw_text(Menu.fonts.main, item, x + S(8), item_y + S(3), tc[1], tc[2], tc[3], a, 0, 0, 0, 0, 0)
                
                if item_hov and input.is_key_pressed(1) then 
                    Menu.values[opt.id] = i
                    opt.is_open = false
                    Menu.active_select_element = nil
                    Menu.click_consumed = true
                    if opt.onChange then opt.onChange(i, item) end 
                end
            end
        end)
    end
end

function MenuLib.draw_multiselect(opt, a, x, y, mx, my, r_queue)
    opt.h = S(45)
    local w = S(240)
    local box_h = S(22)
    local box_y = y + S(18)
    local c = Menu.colors
    local hov = mx > x and mx < x + w and my > box_y and my < box_y + box_h
    
    if can_interact(opt.id) and hov and input.is_key_pressed(1) then
        if opt.is_open then 
            opt.is_open = false
            Menu.active_select_element = nil
        else 
            if Menu.active_select_element and Menu.elements[Menu.active_select_element] then 
                Menu.elements[Menu.active_select_element].is_open = false 
            end
            opt.is_open = true
            Menu.active_select_element = opt.id 
        end
        Menu.click_consumed = true
    end
    
    local selected_items = {}
    if Menu.values[opt.id] then 
        for i, item in ipairs(opt.items) do 
            if Menu.values[opt.id][i] then table.insert(selected_items, item) end 
        end 
    end
    local display_text = table.concat(selected_items, ", ")
    if display_text == "" then display_text = "None" end
    if #display_text > 28 then display_text = #selected_items .. " selected" end
    
    if opt.name then render.draw_text(Menu.fonts.main, opt.name, x, y, c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) end
    
    local border_color = opt.is_open and c.accent or {60, 60, 65}
    local bg_color = {28, 28, 33}
    
    render.draw_rectangle(x, box_y, w, box_h, bg_color[1], bg_color[2], bg_color[3], a, 0, true, 4)
    if opt.is_open or hov then
        render.draw_rectangle(x, box_y, w, box_h, border_color[1], border_color[2], border_color[3], a, 1, false, 4)
    end
    
    render.draw_text(Menu.fonts.main, display_text, x + S(8), box_y + S(3), 220, 220, 220, a, 0, 0, 0, 0, 0)
    
    local arrow_x = x + w - S(15)
    local arrow_y = box_y + S(9)
    if opt.is_open then
        render.draw_triangle(arrow_x, arrow_y + 3, arrow_x + 6, arrow_y + 3, arrow_x + 3, arrow_y, 200, 200, 200, a, 1, true)
    else
        render.draw_triangle(arrow_x, arrow_y, arrow_x + 6, arrow_y, arrow_x + 3, arrow_y + 3, 150, 150, 150, a, 1, true)
    end
    
    if opt.is_open then
        table.insert(r_queue, function()
            local list_y = box_y + box_h + 2
            local list_h = #opt.items * box_h
            
            render.draw_rectangle(x + 2, list_y + 2, w, list_h, 0, 0, 0, 100, 4, true)
            render.draw_rectangle(x, list_y, w, list_h, 25, 25, 30, a, 0, true, 4)
            render.draw_rectangle(x, list_y, w, list_h, c.accent[1], c.accent[2], c.accent[3], a, 1, false, 4)
            
            for i, item in ipairs(opt.items) do
                local item_y = list_y + (i - 1) * box_h
                local item_hov = mx > x and mx < x + w and my > item_y and my < item_y + box_h
                local is_ticked = (Menu.values[opt.id] and Menu.values[opt.id][i]) or false
                
                if item_hov then 
                    render.draw_rectangle(x + 1, item_y, w - 2, box_h, 40, 40, 45, a, 0, true, 2) 
                end
                
                local cb_size = 12
                render.draw_rectangle(x + 8, item_y + (box_h - cb_size)/2, cb_size, cb_size, 60, 60, 65, a, 0, true, 3)
                if is_ticked then
                    render.draw_rectangle(x + 8, item_y + (box_h - cb_size)/2, cb_size, cb_size, c.accent[1], c.accent[2], c.accent[3], a, 0, true, 3)
                end
                
                local tc = is_ticked and {255, 255, 255} or c.text_dim
                render.draw_text(Menu.fonts.main, item, x + 28, item_y + S(3), tc[1], tc[2], tc[3], a, 0, 0, 0, 0, 0)
                
                if item_hov and input.is_key_pressed(1) then
                    if not Menu.values[opt.id] then Menu.values[opt.id] = {} end
                    Menu.values[opt.id][i] = not is_ticked
                    Menu.click_consumed = true
                end
            end
        end)
    end
end

local function rgb_to_hex(r, g, b, a)
    return string.format("#%02X%02X%02X%02X", r, g, b, a)
end

local function hex_to_rgba(hex)
    hex = hex:gsub("#", "")
    if #hex == 6 then hex = hex .. "FF" end 
    if #hex ~= 8 then return nil end
    
    local r = tonumber(hex:sub(1, 2), 16)
    local g = tonumber(hex:sub(3, 4), 16)
    local b = tonumber(hex:sub(5, 6), 16)
    local a = tonumber(hex:sub(7, 8), 16)
    
    if r and g and b and a then
        return {r, g, b, a}
    end
    return nil
end

function MenuLib.draw_checkered_background(x, y, w, h, alpha)
    local size = 4
    local c1 = { 50, 50, 55, alpha }
    local c2 = { 35, 35, 40, alpha }
    
    render.draw_rectangle(x, y, w, h, c2[1], c2[2], c2[3], c2[4], 0, true, 3)
    
    for i = 0, w / size do
        for j = 0, h / size do
            if (i + j) % 2 == 0 then
                local draw_x = x + i * size
                local draw_y = y + j * size
                if draw_x + size <= x + w and draw_y + size <= y + h then
                    render.draw_rectangle(draw_x, draw_y, size, size, c1[1], c1[2], c1[3], c1[4], 0, true)
                end
            end
        end
    end
end


function MenuLib.draw_colorpicker_button(opt, a, x, y, mx, my, r_queue)
    opt.h = S(24)
    local w, h = S(36), S(18)
    local col_width = S(240)
    
    local swatch_x = x + col_width - w
    local swatch_y = y + S(3)
    
    local c = Menu.colors
    local hsva_val = Menu.values[opt.id]
    local r, g, b, color_alpha = MenuLib.hsv_to_rgb(hsva_val.h, hsva_val.s, hsva_val.v, hsva_val.a)
    
    if opt.name then 
        render.draw_text(Menu.fonts.main, opt.name, x, y + S(2), c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) 
    end
    
    local hov = mx > swatch_x and mx < swatch_x + w and my > swatch_y and my < swatch_y + h
    
    render.draw_rectangle(swatch_x, swatch_y, w, h, 28, 28, 33, a, 0, true, 4)
    
    MenuLib.draw_checkered_background(swatch_x + 2, swatch_y + 2, w - 4, h - 4, a)
    
    render.draw_rectangle(swatch_x + 2, swatch_y + 2, w - 4, h - 4, r, g, b, color_alpha, 0, true, 3)
    
    if hov then 
        render.draw_rectangle(swatch_x, swatch_y, w, h, 255, 255, 255, 30, 1, false, 4) 
    else
        render.draw_rectangle(swatch_x, swatch_y, w, h, 60, 60, 65, a, 1, false, 4)
    end
    
    if hov and input.is_key_pressed(1) and can_interact(opt.id) then
        local cpw = Menu.color_pickers[opt.id]
        cpw.visible = not cpw.visible
        
        if cpw.visible then
            local sw, sh = render.get_viewport_size()
            cpw.x = mx + 15
            cpw.y = my - 15
            
            if cpw.x + cpw.w > sw then cpw.x = mx - cpw.w - 15 end
            if cpw.y + cpw.h > sh then cpw.y = sh - cpw.h - 15 end
        end
        Menu.click_consumed = true
    end
end

function MenuLib.render_single_color_picker(cpw)
    cpw.anim.target_alpha = cpw.visible and 1 or 0
    cpw.anim.alpha = math.lerp(cpw.anim.alpha, cpw.anim.target_alpha, 0.2)
    
    if cpw.anim.alpha < 0.01 then
        cpw.dragging, cpw.dragging_sv, cpw.dragging_hue, cpw.dragging_alpha = false, false, false, false
        cpw.typing_hex = false 
        return
    end
    
    local alpha_mult = cpw.anim.alpha
    local master_a = math.floor(255 * alpha_mult)
    local c = Menu.colors
    local mx, my = input.get_mouse_position()
    
    local pad = 12
    local top_bar_h = 28
    local sv_size = 180
    local hue_w = 18
    local slider_h = 14
    local bottom_h = 35
    local gap = 10
    
    cpw.w = pad + sv_size + gap + hue_w + pad
    cpw.h = top_bar_h + sv_size + gap + slider_h + gap + bottom_h + pad
    

    local interacting = cpw.dragging_sv or cpw.dragging_hue or cpw.dragging_alpha or cpw.typing_hex
    if input.is_key_pressed(1) and not interacting then
        if mx > cpw.x and mx < cpw.x + cpw.w and my > cpw.y and my < cpw.y + top_bar_h then
            cpw.dragging, cpw.drag_x, cpw.drag_y = true, mx - cpw.x, my - cpw.y
            Menu.click_consumed = true
        end
    end
    
    if not input.is_key_down(1) then 
        cpw.dragging, cpw.dragging_sv, cpw.dragging_hue, cpw.dragging_alpha = false, false, false, false 
    end
    if cpw.dragging then cpw.x, cpw.y = mx - cpw.drag_x, my - cpw.drag_y end
    
    local sv_x, sv_y = cpw.x + pad, cpw.y + top_bar_h
    local hue_x, hue_y = sv_x + sv_size + gap, sv_y
    local alpha_x, alpha_y = sv_x, sv_y + sv_size + gap
    local alpha_w = sv_size + gap + hue_w
    
    render.draw_rectangle(cpw.x + 4, cpw.y + 4, cpw.w, cpw.h, 0, 0, 0, math.floor(80 * alpha_mult), 12, true)
    render.draw_rectangle(cpw.x, cpw.y, cpw.w, cpw.h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], master_a, 0, true, 8)
    render.draw_rectangle(cpw.x, cpw.y, cpw.w, cpw.h, 60, 60, 70, master_a, 1, false, 8)
    
    render.draw_text(Menu.fonts.group, cpw.title or "Color Picker", cpw.x + pad, cpw.y + 6, 255, 255, 255, master_a, 0, 0, 0, 0, 0)
    
    local close_sz = 14
    local cx, cy = cpw.x + cpw.w - pad - close_sz, cpw.y + 8
    local hov_close = mx > cx - 4 and mx < cx + close_sz + 4 and my > cy - 4 and my < cy + close_sz + 4
    local cc = hov_close and {255, 100, 100} or {150, 150, 150}
    render.draw_text(Menu.fonts.main, "X", cx + 2, cy - 1, cc[1], cc[2], cc[3], master_a, 0, 0,0,0,0)
    if hov_close and input.is_key_pressed(1) then cpw.visible = false; Menu.click_consumed = true end


    if not cpw.typing_hex and input.is_key_pressed(1) then
        if mx > sv_x and mx < sv_x + sv_size and my > sv_y and my < sv_y + sv_size then cpw.dragging_sv = true; Menu.click_consumed = true end
        if mx > hue_x and mx < hue_x + hue_w and my > hue_y and my < hue_y + sv_size then cpw.dragging_hue = true; Menu.click_consumed = true end
        if mx > alpha_x and mx < alpha_x + alpha_w and my > alpha_y and my < alpha_y + slider_h then cpw.dragging_alpha = true; Menu.click_consumed = true end
    end
    
    local val = Menu.values[cpw.id]
    
    if cpw.dragging_sv then
        val.s = math.clamp((mx - sv_x) / sv_size, 0, 1)
        val.v = math.clamp(1 - (my - sv_y) / sv_size, 0, 1)
    end
    if cpw.dragging_hue then 
        val.h = math.clamp((my - hue_y) / sv_size, 0, 1) 
    end
    if cpw.dragging_alpha then 
        val.a = math.floor(math.clamp((mx - alpha_x) / alpha_w * 255, 0, 255)) 
    end
    
    local r, g, b = MenuLib.hsv_to_rgb(val.h, val.s, val.v)
    local hr, hg, hb = MenuLib.hsv_to_rgb(val.h, 1, 1)
    
    render.draw_four_corner_gradient(sv_x, sv_y, sv_size, sv_size, 255, 255, 255, 255, hr, hg, hb, 255, 0, 0, 0, 255, 0, 0, 0, 255)
    render.draw_rectangle(sv_x, sv_y, sv_size, sv_size, 40, 40, 40, master_a, 1, false, 0)
    
    local cur_x = sv_x + (val.s * sv_size)
    local cur_y = sv_y + ((1 - val.v) * sv_size)
    render.draw_circle(cur_x, cur_y, 4, 0, 0, 0, master_a, 1, false)
    render.draw_circle(cur_x, cur_y, 3, 255, 255, 255, master_a, 1, false)
    
    local segs = 6
    local seg_h = sv_size / segs
    for i = 0, segs - 1 do
        local r1, g1, b1 = MenuLib.hsv_to_rgb(i/6, 1, 1)
        local r2, g2, b2 = MenuLib.hsv_to_rgb((i+1)/6, 1, 1)
        render.draw_gradient_rectangle(hue_x, hue_y + (i * seg_h), hue_w, seg_h + 1, {{r1,g1,b1,255}, {r2,g2,b2,255}}, 0)
    end
    render.draw_rectangle(hue_x, hue_y, hue_w, sv_size, 40, 40, 40, master_a, 1, false, 0)
    
    local hue_cur_y = hue_y + (val.h * sv_size)
    render.draw_rectangle(hue_x - 1, hue_cur_y - 2, hue_w + 2, 4, 255, 255, 255, master_a, 1, false, 0)
    
    MenuLib.draw_checkered_background(alpha_x, alpha_y, alpha_w, slider_h, master_a)
    render.draw_four_corner_gradient(alpha_x, alpha_y, alpha_w, slider_h, 0,0,0,0, r,g,b,255, 0,0,0,0, r,g,b,255)
    render.draw_rectangle(alpha_x, alpha_y, alpha_w, slider_h, 40, 40, 40, master_a, 1, false, 0)
    
    local a_cur_x = alpha_x + ((val.a / 255) * alpha_w)
    render.draw_rectangle(a_cur_x - 2, alpha_y - 1, 4, slider_h + 2, 255, 255, 255, master_a, 0, true, 2)
    
    local foot_y = alpha_y + slider_h + gap
    local hex_w = 90
    local hex_h = 24
    
    local current_hex_display
    if cpw.typing_hex then
        current_hex_display = cpw.temp_hex_buffer or ""
        if (winapi.get_tickcount64() % 1000) < 500 then current_hex_display = current_hex_display .. "|" end
    else
        current_hex_display = rgb_to_hex(r, g, b, val.a)
    end
    
    local hov_hex = mx > sv_x and mx < sv_x + hex_w and my > foot_y and my < foot_y + hex_h
    local bg_hex = cpw.typing_hex and c.bg_light or {30, 30, 35}
    local border_hex = (cpw.typing_hex or hov_hex) and c.accent or {60, 60, 65}
    
    render.draw_rectangle(sv_x, foot_y, hex_w, hex_h, bg_hex[1], bg_hex[2], bg_hex[3], master_a, 0, true, 4)
    render.draw_rectangle(sv_x, foot_y, hex_w, hex_h, border_hex[1], border_hex[2], border_hex[3], master_a, 1, false, 4)
    render.draw_text(Menu.fonts.main, current_hex_display, sv_x + 8, foot_y + 5, 200, 200, 200, master_a, 0, 0,0,0,0)
    
    if input.is_key_pressed(1) then
        if hov_hex then
            cpw.typing_hex = true
            cpw.temp_hex_buffer = rgb_to_hex(r, g, b, val.a)
            Menu.click_consumed = true
        else
            if cpw.typing_hex then
                cpw.typing_hex = false
                local new_rgba = hex_to_rgba(cpw.temp_hex_buffer)
                if new_rgba then
                    local nh, ns, nv = MenuLib.rgb_to_hsv(new_rgba[1], new_rgba[2], new_rgba[3])
                    val.h, val.s, val.v, val.a = nh, ns, nv, new_rgba[4]
                end
            end
        end
    end
    
    if cpw.typing_hex then
        -- Cancel / Enter
        if input.is_key_pressed(0x1B) then cpw.typing_hex = false end
        if input.is_key_pressed(0x0D) then
            cpw.typing_hex = false
            -- If user forgot #, assume hex
            local hex_str = cpw.temp_hex_buffer
            if not hex_str:find("#") and (#hex_str == 6 or #hex_str == 8) then
                hex_str = "#" .. hex_str
            end
            
            local new_rgba = hex_to_rgba(hex_str)
            if new_rgba then
                local nh, ns, nv = MenuLib.rgb_to_hsv(new_rgba[1], new_rgba[2], new_rgba[3])
                val.h, val.s, val.v, val.a = nh, ns, nv, new_rgba[4]
            end
        end
        
        -- Backspace
        if input.is_key_pressed(0x08) and #cpw.temp_hex_buffer > 0 then
            cpw.temp_hex_buffer = cpw.temp_hex_buffer:sub(1, -2)
        end
        
        -- Manual polling for Hex characters
        local keys_to_poll = {
            {0x30, "0"}, {0x31, "1"}, {0x32, "2"}, {0x33, "3"}, {0x34, "4"},
            {0x35, "5"}, {0x36, "6"}, {0x37, "7"}, {0x38, "8"}, {0x39, "9"},
            {0x41, "A"}, {0x42, "B"}, {0x43, "C"}, {0x44, "D"}, {0x45, "E"}, {0x46, "F"},
            -- Numpad
            {0x60, "0"}, {0x61, "1"}, {0x62, "2"}, {0x63, "3"}, {0x64, "4"},
            {0x65, "5"}, {0x66, "6"}, {0x67, "7"}, {0x68, "8"}, {0x69, "9"}
        }
        
        -- Handle # (Shift + 3)
        if input.is_key_down(0x10) and input.is_key_pressed(0x33) then
             if #cpw.temp_hex_buffer < 9 then
                cpw.temp_hex_buffer = cpw.temp_hex_buffer .. "#"
             end
        end

        for _, k in ipairs(keys_to_poll) do
            if input.is_key_pressed(k[1]) then
                -- Avoid typing "3" if we just typed "#" (Shift+3)
                local is_3 = (k[1] == 0x33)
                local shift = input.is_key_down(0x10)
                
                if not (is_3 and shift) then
                    if #cpw.temp_hex_buffer < 9 then
                        cpw.temp_hex_buffer = cpw.temp_hex_buffer .. k[2]
                    end
                end
            end
        end
        
        Menu.click_consumed = true
    end
    
    -- [[ BUTTONS ]]
    local btn_w = 55
    local btn_x_copy = sv_x + hex_w + 10
    local btn_x_paste = btn_x_copy + btn_w + 5
    
    local function draw_action_btn(bx, txt, action)
        local hov = mx > bx and mx < bx + btn_w and my > foot_y and my < foot_y + hex_h
        local bg = hov and c.accent or {45, 45, 50}
        
        render.draw_rectangle(bx, foot_y, btn_w, hex_h, bg[1], bg[2], bg[3], master_a, 0, true, 4)
        if not hov then render.draw_rectangle(bx, foot_y, btn_w, hex_h, 60, 60, 65, master_a, 1, false, 4) end
        
        local tw = render.measure_text(Menu.fonts.main, txt)
        render.draw_text(Menu.fonts.main, txt, bx + (btn_w - tw)/2, foot_y + 5, 255, 255, 255, master_a, 0, 0,0,0,0)
        
        if hov and input.is_key_pressed(1) and not cpw.typing_hex then 
            action()
            Menu.click_consumed = true
        end
    end
    
    draw_action_btn(btn_x_copy, "Copy", function()
        input.set_clipboard(rgb_to_hex(r, g, b, val.a))
        if MenuLib.Notify then MenuLib.Notify.push("Color Copied", 2) end
    end)
    
    draw_action_btn(btn_x_paste, "Paste", function()
        local clip = input.get_clipboard()
        if clip then
            -- Clean clipboard
            clip = clip:gsub("[^%x#]", ""):upper()
            -- Auto-add hash if missing
            if not clip:find("#") and (#clip == 6 or #clip == 8) then clip = "#" .. clip end
            
            local rgba = hex_to_rgba(clip)
            if rgba then
                local nh, ns, nv = MenuLib.rgb_to_hsv(rgba[1], rgba[2], rgba[3])
                val.h, val.s, val.v, val.a = nh, ns, nv, rgba[4]
                if MenuLib.Notify then MenuLib.Notify.push("Color Pasted", 2) end
            else
                if MenuLib.Notify then MenuLib.Notify.push("Invalid Hex", 3) end
            end
        end
    end)
    
    -- Consume clicks on picker background to prevent clicking UI behind it
    if input.is_key_pressed(1) and mx > cpw.x and mx < cpw.x + cpw.w and my > cpw.y and my < cpw.y + cpw.h then
        Menu.click_consumed = true
    end
end

function MenuLib.draw_input_text(opt, a, x, y, mx, my, r_queue)
    opt.h = S(45) -- Label + Box stack
    local w = S(240)
    local box_h = S(22)
    local box_y = y + S(18)
    
    local c = Menu.colors
    local hov = mx > x and mx < x + w and my > box_y and my < box_y + box_h
    
    if input.is_key_pressed(1) and can_interact(opt.id) then
        if hov then 
            Menu.active_input_element = opt.id
            Menu.click_consumed = true
        elseif Menu.active_input_element == opt.id then 
            Menu.active_input_element = nil 
        end
    end
    
    if Menu.values[opt.id] == nil then Menu.values[opt.id] = "" end
    local current_text = tostring(Menu.values[opt.id])
    local now = winapi.get_tickcount64()

    -- Input Logic
    if Menu.active_input_element == opt.id then
        if input.is_key_pressed(0x0D) or input.is_key_pressed(0x1B) then Menu.active_input_element = nil end
        -- Simple Backspace handling (no repeat timer for brevity here, assume handled elsewhere or simple press)
        if input.is_key_pressed(0x08) and #current_text > 0 then
             current_text = current_text:sub(1, -2)
        end
        
        if _G.get_recent_key_input then
            local typed = _G.get_recent_key_input()
            if typed and typed ~= "" then 
                local safe = typed:gsub("[^%w%s%-%_%.,!@#$%%]", "")
                current_text = current_text .. safe 
            end
        end
        Menu.values[opt.id] = current_text
    end
    
    local is_active = Menu.active_input_element == opt.id
    local display_text = current_text
    if is_active and (now % 1000) < 500 then display_text = display_text .. "|" end
    
    -- Label
    if opt.name then 
        render.draw_text(Menu.fonts.main, opt.name, x, y, c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0) 
    end
    
    -- Box
    local bg_col = {28, 28, 33}
    local border_col = is_active and c.accent or {60, 60, 65}
    
    render.draw_rectangle(x, box_y, w, box_h, bg_col[1], bg_col[2], bg_col[3], a, 0, true, 4)
    if is_active or hov then
        render.draw_rectangle(x, box_y, w, box_h, border_col[1], border_col[2], border_col[3], a, 1, false, 4)
    end
    
    -- Text inside
    render.draw_text(Menu.fonts.main, display_text, x + S(8), box_y + S(3), 220, 220, 220, a, 0, 0, 0, 0, 0)
end

function MenuLib.draw_button(opt, a, x, y, mx, my, r_queue)
    opt.h = S(30)
    local w, h = S(240), S(26)
    local c = Menu.colors
    
    local hov = mx > x and mx < x + w and my > y and my < y + h
    if hov and input.is_key_pressed(1) and can_interact(opt.id) then 
        opt.callback()
        Menu.click_consumed = true 
    end
    
    -- Button Style
    local bg = hov and c.accent or {40, 40, 45}
    render.draw_rectangle(x, y, w, h, bg[1], bg[2], bg[3], a, 0, true, 4)
    if not hov then
        -- Subtle outline
        render.draw_rectangle(x, y, w, h, 60, 60, 65, a, 1, false, 4)
    end
    
    if opt.name then 
        local tw, th = render.measure_text(Menu.fonts.main, opt.name)
        render.draw_text(Menu.fonts.main, opt.name, x + (w-tw)/2, y + (h-th)/2, 255, 255, 255, a, 0, 0, 0, 0, 0) 
    end
end

function MenuLib.draw_glow_rect(x, y, w, h, rounding, glow_color, master_alpha)
    local r, g, b, a
    if glow_color.h then r, g, b, a = MenuLib.hsv_to_rgb(glow_color.h, glow_color.s, glow_color.v, glow_color.a) else r, g, b, a = glow_color[1], glow_color[2], glow_color[3], glow_color[4] end
    local steps = 4
    local size_increase = 1.5
    for i = steps, 1, -1 do
        local step_alpha = math.floor((a / steps) * 0.5 * (master_alpha / 255))
        local offset = i * size_increase
        render.draw_rectangle(x - offset, y - offset, w + offset * 2, h + offset * 2, r, g, b, step_alpha, 0, true, rounding + offset)
    end
end

-- function MenuLib.render_single_color_picker(cpw)
--     cpw.anim.target_alpha = cpw.visible and 1 or 0
--     cpw.anim.alpha = math.lerp(cpw.anim.alpha, cpw.anim.target_alpha, 0.25)
--     if cpw.anim.alpha < 0.01 then
--         cpw.dragging, cpw.dragging_sv, cpw.dragging_hue, cpw.dragging_alpha = false, false, false, false
--         return
--     end
--     local master_alpha = math.floor(255 * cpw.anim.alpha)
--     local c = Menu.colors
--     local mx, my = input.get_mouse_position()
--     local layout = {padding = 15, title_h = 35, sv_size = 150, hue_w = 20, slider_h = 22, preview_h = 40, gap = 12, rounding = 8}
--     cpw.w = layout.padding * 2 + layout.sv_size + layout.gap + layout.hue_w
--     cpw.h = layout.title_h + layout.sv_size + layout.gap + layout.slider_h + layout.gap + layout.preview_h + layout.padding
--     if input.is_key_pressed(1) and not(cpw.dragging_sv or cpw.dragging_hue or cpw.dragging_alpha) then
--         if mx > cpw.x and mx < cpw.x + cpw.w and my > cpw.y and my < cpw.y + layout.title_h then
--             cpw.dragging, cpw.drag_x, cpw.drag_y = true, mx - cpw.x, my - cpw.y
--             Menu.click_consumed = true
--         end
--     end
--     if not input.is_key_down(1) then cpw.dragging, cpw.dragging_sv, cpw.dragging_hue, cpw.dragging_alpha = false, false, false, false end
--     if cpw.dragging then cpw.x, cpw.y = mx - cpw.drag_x, my - cpw.drag_y end
--     local sv_x, sv_y = cpw.x + layout.padding, cpw.y + layout.title_h
--     local hue_x, hue_y = sv_x + layout.sv_size + layout.gap, sv_y
--     local alpha_x, alpha_y = sv_x, sv_y + layout.sv_size + layout.gap
--     local alpha_w = layout.sv_size + layout.gap + layout.hue_w
--     if input.is_key_pressed(1) then
--         if mx > sv_x and mx < sv_x + layout.sv_size and my > sv_y and my < sv_y + layout.sv_size then cpw.dragging_sv = true; Menu.click_consumed = true end
--         if mx > hue_x and mx < hue_x + layout.hue_w and my > hue_y and my < hue_y + layout.sv_size then cpw.dragging_hue = true; Menu.click_consumed = true end
--         if mx > alpha_x and mx < alpha_x + alpha_w and my > alpha_y and my < alpha_y + layout.slider_h then cpw.dragging_alpha = true; Menu.click_consumed = true end
--     end
--     local current_hsva = Menu.values[cpw.id]
--     if cpw.dragging_sv then
--         current_hsva.s = math.clamp((mx - sv_x) / layout.sv_size, 0, 1)
--         current_hsva.v = math.clamp(1 - (my - sv_y) / layout.sv_size, 0, 1)
--     end
--     if cpw.dragging_hue then current_hsva.h = math.clamp(1 - (my - hue_y) / layout.sv_size, 0, 1) end
--     if cpw.dragging_alpha then current_hsva.a = math.floor(math.clamp((mx - alpha_x) / alpha_w * 255, 0, 255)) end
--     local r, g, b = MenuLib.hsv_to_rgb(current_hsva.h, current_hsva.s, current_hsva.v)
--     render.draw_rectangle(cpw.x, cpw.y, cpw.w, cpw.h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], master_alpha, 0, true, layout.rounding)
--     render.draw_text(Menu.fonts.title, cpw.title, cpw.x + layout.padding, cpw.y + 8, c.text_main[1], c.text_main[2], c.text_main[3], master_alpha, 0, 0, 0, 0, 0)
--     render.draw_line(cpw.x + 8, cpw.y + layout.title_h, cpw.x + cpw.w - 8, cpw.y + layout.title_h, c.bg_light[1], c.bg_light[2], c.bg_light[3], master_alpha, 1)
--     local close_x, close_y, size = cpw.x + cpw.w - 22, cpw.y + 11, 12
--     local hov_close = mx > close_x - 3 and mx < close_x + size + 3 and my > close_y - 3 and my < close_y + size + 3
--     local clr = hov_close and c.accent or c.text_dim
--     render.draw_line(close_x, close_y, close_x + size, close_y + size, clr[1], clr[2], clr[3], master_alpha, 1.5)
--     render.draw_line(close_x, close_y + size, close_x + size, close_y, clr[1], clr[2], clr[3], master_alpha, 1.5)
--     if hov_close and input.is_key_pressed(1) then cpw.visible = false; Menu.click_consumed = true end
--     local hue_r, hue_g, hue_b = MenuLib.hsv_to_rgb(current_hsva.h, 1, 1)
--     for i = 0, layout.sv_size - 1, 2 do
--         local ratio = i / layout.sv_size
--         local r_lerp = math.lerp(255, hue_r, ratio)
--         local g_lerp = math.lerp(255, hue_g, ratio)
--         local b_lerp = math.lerp(255, hue_b, ratio)
--         render.draw_rectangle(sv_x + i, sv_y, 2, layout.sv_size, r_lerp, g_lerp, b_lerp, master_alpha, 0, true)
--     end
--     render.draw_gradient_rectangle(sv_x, sv_y, layout.sv_size, layout.sv_size, {{0, 0, 0, 0}, {0, 0, 0, 255}}, 0)
--     for i = 0, layout.sv_size - 1 do
--         local hr, hg, hb = MenuLib.hsv_to_rgb(1 - i / layout.sv_size, 1, 1)
--         render.draw_line(hue_x, hue_y + i, hue_x + layout.hue_w, hue_y + i, hr, hg, hb, master_alpha, 1)
--     end
--     local alpha_rounding = layout.slider_h / 2
--     MenuLib.draw_checkered_background(alpha_x, alpha_y, alpha_w, layout.slider_h, master_alpha)
--     render.draw_gradient_rectangle(alpha_x, alpha_y, alpha_w, layout.slider_h, {{r, g, b, 0}, {r, g, b, master_alpha}}, alpha_rounding)
--     render.draw_rectangle(sv_x - 1, sv_y - 1, layout.sv_size + 2, layout.sv_size + 2, c.bg_light[1], c.bg_light[2], c.bg_light[3], master_alpha, 1, false, 8)
--     render.draw_rectangle(hue_x - 1, hue_y - 1, layout.hue_w + 2, layout.sv_size + 2, c.bg_light[1], c.bg_light[2], c.bg_light[3], master_alpha, 1, false, 4)
--     render.draw_rectangle(alpha_x - 1, alpha_y - 1, alpha_w + 2, layout.slider_h + 2, c.bg_light[1], c.bg_light[2], c.bg_light[3], master_alpha, 1, false, alpha_rounding + 1)
--     render.draw_circle(sv_x + current_hsva.s * layout.sv_size, sv_y + (1 - current_hsva.v) * layout.sv_size, 5, 0, 0, 0, math.floor(master_alpha * 0.6), 1, false)
--     render.draw_circle(sv_x + current_hsva.s * layout.sv_size, sv_y + (1 - current_hsva.v) * layout.sv_size, 4, 255, 255, 255, master_alpha, 1, false)
--     render.draw_rectangle(hue_x - 2, hue_y + (1 - current_hsva.h) * layout.sv_size - 2, layout.hue_w + 4, 4, 255, 255, 255, master_alpha, 1, false, 2)
--     local alpha_cursor_x = alpha_x + (current_hsva.a / 255) * alpha_w
--     render.draw_rectangle(alpha_cursor_x - 4, alpha_y - 2, 8, layout.slider_h + 4, 255, 255, 255, master_alpha, 1.5, false, 4)
--     local preview_y = alpha_y + layout.slider_h + layout.gap
--     local preview_w = 90
--     MenuLib.draw_glow_rect(alpha_x, preview_y, preview_w, layout.preview_h, layout.rounding, {r, g, b, 120}, master_alpha)
--     render.draw_rectangle(alpha_x, preview_y, preview_w, layout.preview_h, r, g, b, current_hsva.a, 0, true, layout.rounding - 1)
--     local hex_x = alpha_x + preview_w + layout.gap
--     local hex_w = alpha_w - preview_w - layout.gap
--     render.draw_rectangle(hex_x, preview_y, hex_w, layout.preview_h, c.bg_mid[1], c.bg_mid[2], c.bg_mid[3], master_alpha, 0, true, layout.rounding)
--     local hex_text = string.format("#%02X%02X%02X", r, g, b)
--     render.draw_text(Menu.fonts.main, hex_text, hex_x + 12, preview_y + 11, c.text_dim[1], c.text_dim[2], c.text_dim[3], master_alpha, 0, 0, 0, 0, 0)
-- end






function MenuLib.render_info_window()
    local iw = Menu.info_window
    
    iw.anim.target_alpha = (iw.visible and Menu.anim.alpha > 0.99) and 1 or 0
    iw.anim.alpha = math.lerp(iw.anim.alpha, iw.anim.target_alpha, iw.anim.speed)
    
    if iw.anim.alpha < 0.01 then
        iw.dragging = false
        return
    end

    local a = math.floor(255 * iw.anim.alpha)
    local c = Menu.colors
    local mx, my = input.get_mouse_position()

    iw.w = S(400)
    iw.h = S(320)

    if not iw.dragging and input.is_key_pressed(1) and mx > iw.x and mx < iw.x + iw.w and my > iw.y and my < iw.y + S(50) then
        iw.dragging, iw.drag_x, iw.drag_y = true, mx - iw.x, my - iw.y
    end
    if not input.is_key_down(1) then iw.dragging = false end
    if iw.dragging then iw.x, iw.y = mx - iw.drag_x, my - iw.drag_y end


    render.draw_rectangle(iw.x + 4, iw.y + 4, iw.w, iw.h, 0, 0, 0, 80 * (a / 255), 12, true)
    render.draw_rectangle(iw.x, iw.y, iw.w, iw.h, c.bg_dark[1], c.bg_dark[2], c.bg_dark[3], a, 0, true, 8)
    render.draw_rectangle(iw.x, iw.y, iw.w, iw.h, 60, 60, 70, a, 1, false, 8)
    render.draw_gradient_rectangle(iw.x, iw.y + S(50), iw.w, 1, {{60,60,70, 0}, {c.accent[1], c.accent[2], c.accent[3], a}, {60,60,70, 0}}, 0)

    render.draw_text(Menu.fonts.title, "TSIDE", iw.x + S(25), iw.y + S(15), 255, 255, 255, a, 0, 0, 0, 0, 0)
    render.draw_text(Menu.fonts.main, "Information", iw.x + S(110), iw.y + S(24), c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0, 0, 0, 0)

    local card_y = iw.y + S(70)
    local card_h = S(90)
    local card_w = iw.w - S(40)
    local card_x = iw.x + S(20)

    render.draw_rectangle(card_x, card_y, card_w, card_h, c.bg_mid[1], c.bg_mid[2], c.bg_mid[3], a, 0, true, 6)
    render.draw_rectangle(card_x, card_y, card_w, card_h, 60, 60, 65, math.floor(a * 0.5), 1, false, 6)

    local function draw_row(label, val, y_off)
        render.draw_text(Menu.fonts.main, label, card_x + S(15), card_y + y_off, c.text_dim[1], c.text_dim[2], c.text_dim[3], a, 0, 0,0,0,0)
        local vw, _ = render.measure_text(Menu.fonts.main, val)
        render.draw_text(Menu.fonts.main, val, card_x + card_w - S(15) - vw, card_y + y_off, 255, 255, 255, a, 0, 0,0,0,0)
    end

    draw_row("Build Version", "v" .. MenuLib.version, S(15))
    draw_row("Developer", "Saikaido", S(38))
    draw_row("Subscription", "Lifetime", S(61))

    local theme_y = card_y + card_h + S(20)
    render.draw_text(Menu.fonts.group, "Personalize", iw.x + S(20), theme_y, 255, 255, 255, a, 0, 0, 0, 0, 0)

    local radius = S(12)
    local spacing = S(35) 
    local theme_keys = {"default", "halloween", "cyberpunk", "ocean", "vampire", "obsidian", "quartz", "gameception"} 
    
    local total_width = (#theme_keys - 1) * spacing
    local start_x = (iw.x + iw.w / 2) - (total_width / 2)
    local circles_y = theme_y + S(30)

    for i, theme_name in ipairs(theme_keys) do
        local x_pos = start_x + (i - 1) * spacing
        local theme_colors = themes[theme_name].colors
        local is_active = (Menu.current_theme == theme_name)
        
        if is_active then
            render.draw_circle(x_pos, circles_y, radius + 3, c.text_main[1], c.text_main[2], c.text_main[3], a, 1, false)
        end

        render.draw_circle(x_pos, circles_y, radius, theme_colors.accent[1], theme_colors.accent[2], theme_colors.accent[3], a, 0, true)
        
        render.draw_circle(x_pos, circles_y, radius - 4, theme_colors.bg_dark[1], theme_colors.bg_dark[2], theme_colors.bg_dark[3], a, 0, true)

        if input.is_key_pressed(1) and not iw.dragging then
            local dist = math.sqrt((mx - x_pos)^2 + (my - circles_y)^2)
            if dist < radius + 2 then
                MenuLib.set_theme(theme_name)
            end
        end
    end
    
    local btn_h = S(32)
    local btn_w = iw.w - S(40)
    local btn_x = iw.x + S(20)
    local btn_y = iw.y + iw.h - S(20) - btn_h
    
    local hov_btn = mx > btn_x and mx < btn_x + btn_w and my > btn_y and my < btn_y + btn_h
    local bg_btn = hov_btn and c.accent or c.bg_mid
    
    render.draw_rectangle(btn_x, btn_y, btn_w, btn_h, bg_btn[1], bg_btn[2], bg_btn[3], a, 0, true, 4)
    if not hov_btn then
        render.draw_rectangle(btn_x, btn_y, btn_w, btn_h, 60, 60, 65, a, 1, false, 4)
    end
    
    local btn_txt = "Close"
    local tw, th = render.measure_text(Menu.fonts.main, btn_txt)
    render.draw_text(Menu.fonts.main, btn_txt, btn_x + (btn_w - tw)/2, btn_y + (btn_h - th)/2, 255, 255, 255, a, 0, 0, 0, 0, 0)
    
    if hov_btn and input.is_key_pressed(1) then 
        iw.visible = false 
    end
end



   MenuLib.Notify = { 
        list = {},
        conf = {
            width = 240,
            height = 40,
            x_pad = 20, 
            y_pad = 20,   
            rounding = 6
        }
    }
    
    function MenuLib.Notify.push(text, type_id)
        local time = winapi.get_tickcount64()
        

        local colors = {
            [1] = {255, 0, 0}, 
            [2] = {100, 255, 110},
            [3] = {255, 80, 80}
        }
        
        if type_id == 1 and Menu.colors and Menu.colors.accent then
            local c = Menu.colors.accent
            colors[1] = {c[1], c[2], c[3]}
        end

        table.insert(MenuLib.Notify.list, 1, {
            id = time + math.random(1,1000),
            text = text,
            type = type_id or 1,
            color = colors[type_id] or colors[1],
            start_time = time,
            duration = 3000,
            alpha = 0,    
            anim_y = 0     
        })
    end

    function MenuLib.Notify.render()
        local conf = MenuLib.Notify.conf
        local sw, sh = render.get_viewport_size()
        local now = winapi.get_tickcount64()
        

        local c_bg = Menu.colors.bg_dark or {22, 23, 27}
        local c_outline = {60, 60, 70}
        local c_text = {230, 230, 230}
        
        local x_start = sw - conf.width - conf.x_pad
        local y_start = conf.y_pad + 25 
        
        for i = #MenuLib.Notify.list, 1, -1 do
            local n = MenuLib.Notify.list[i]
            local elapsed = now - n.start_time
            
     
            local target_alpha = 0
            
            if elapsed < 250 then 
                target_alpha = 255 
            elseif elapsed > n.duration then
                target_alpha = 0  
            else
                target_alpha = 255
            end
            
            n.alpha = math.lerp(n.alpha, target_alpha, 0.15)
            
            if elapsed > n.duration and n.alpha < 2 then
                table.remove(MenuLib.Notify.list, i)
                goto continue_notify
            end
            
            local a = math.floor(n.alpha)
            if a > 2 then
 
                local slide_off = (255 - a) * 0.2 
                local bx = x_start + slide_off
                local by = y_start
                
                render.draw_rectangle(bx + 3, by + 3, conf.width, conf.height, 0, 0, 0, math.floor(a * 0.3), conf.rounding, true)
                
                render.draw_rectangle(bx, by, conf.width, conf.height, c_bg[1], c_bg[2], c_bg[3], math.floor(a * 0.95), conf.rounding, true)
                
                local acc = n.color
                render.draw_rectangle(bx, by + 2, 3, conf.height - 4, acc[1], acc[2], acc[3], a, 2, true)
                
                local grad_cols = {{acc[1], acc[2], acc[3], math.floor(a * 0.25)}, {acc[1], acc[2], acc[3], 0}}
                render.draw_gradient_rectangle(bx + 3, by, conf.width - 3, conf.height, grad_cols, conf.rounding)
                
                render.draw_rectangle(bx, by, conf.width, conf.height, c_outline[1], c_outline[2], c_outline[3], math.floor(a * 0.6), 1, false, conf.rounding)
                
                local icon = (n.type == 2) and "success" or ((n.type == 3) and "error" or "info")
                local icon_char = (n.type == 2) and "S" or ((n.type == 3) and "!" or "i") 
                
                render.draw_circle(bx + 20, by + conf.height/2, 9, acc[1], acc[2], acc[3], math.floor(a * 0.15), 0, true)
                render.draw_circle(bx + 20, by + conf.height/2, 9, acc[1], acc[2], acc[3], a, 1, false) 
                

                local font = Menu.fonts.main 
                
                render.draw_text(font, n.text, bx + 40, by + (conf.height / 2) - 6, c_text[1], c_text[2], c_text[3], a, 0, 0,0,0,0)
                
                local visual_height = (conf.height + 6) * (n.alpha / 255) 
                y_start = y_start + visual_height
            end
            
            ::continue_notify::
        end
    end

local CONFIG_MANIFEST = "_config_list.json"
function MenuLib.save_config(name)
    if not name or name == "" then 
        MenuLib.Notify.push("Error: Name cannot be empty", 3)
        return 
    end
    local file_name = name .. ".json"
    local config_data = {}
    for id, value in pairs(Menu.values) do config_data[id] = value end
    local json_string = json.stringify(config_data)
    fs.write_to_file(file_name, json_string)
    
    local list = {}
    if fs.does_file_exist(CONFIG_MANIFEST) then
        local success, data = pcall(json.parse, fs.read_from_file(CONFIG_MANIFEST))
        if success and type(data) == "table" then list = data end
    end
    local exists = false
    for _, v in ipairs(list) do
        if v == name then exists = true; break end
    end
   if not exists then table.insert(list, name) end
    fs.write_to_file(CONFIG_MANIFEST, json.stringify(list))

    MenuLib.current_config = name
    MenuLib.Notify.push("Config saved: " .. name, 2)
end

function MenuLib.save_config(name)
    if not name or name == "" then 
        MenuLib.Notify.push("Config name cannot be empty", MenuLib.Notify.Type.ERROR)
        return 
    end
    
    local file_name = name .. ".json"
    local config_data = {}
    for id, value in pairs(Menu.values) do config_data[id] = value end
    
    local json_string = json.stringify(config_data)
    fs.write_to_file(file_name, json_string)
    
    local list = {}
    if fs.does_file_exist(CONFIG_MANIFEST) then
        local success, data = pcall(json.parse, fs.read_from_file(CONFIG_MANIFEST))
        if success and type(data) == "table" then list = data end
    end
    
    local exists = false
    for _, v in ipairs(list) do
        if v == name then exists = true; break end
    end
    
    if not exists then 
        table.insert(list, name) 
        fs.write_to_file(CONFIG_MANIFEST, json.stringify(list))
    end
    
    MenuLib.Notify.push("Saved config: " .. name, MenuLib.Notify.Type.SUCCESS)
    engine.log("Config saved to " .. file_name, 100, 255, 100, 255)
end

function MenuLib.load_config(name)
    if not name or name == "" then 
        MenuLib.Notify.push("Error: Select a config", 3)
        return 
    end
    
    local file_name = name .. ".json"
    if not fs.does_file_exist(file_name) then 
        MenuLib.Notify.push("Error: File not found", 3)
        return 
    end
    
    local json_string = fs.read_from_file(file_name)
    local success, config_data = pcall(json.parse, json_string)
    
    if not success or type(config_data) ~= "table" then
        MenuLib.Notify.push("Error: Corrupt config", 3)
        return
    end

    for id, loaded_value in pairs(config_data) do
        if Menu.values[id] ~= nil then
             local current_value = Menu.values[id]
            if type(current_value) == "table" and current_value.key ~= nil then
                 if type(loaded_value) == "table" then
                     current_value.key = loaded_value.key; current_value.mode = loaded_value.mode
                 end
            elseif type(current_value) == "table" and current_value.h ~= nil then
                 if type(loaded_value)=="table" and loaded_value.h then
                    current_value.h = loaded_value.h; current_value.s = loaded_value.s; 
                    current_value.v = loaded_value.v; current_value.a = loaded_value.a
                 end
            else
                 Menu.values[id] = loaded_value
            end
        end
    end
      MenuLib.current_config = name
    MenuLib.Notify.push("Config loaded successfully", 2)
end

function MenuLib.refresh_config_list(element_id)
    local select_el = Menu.elements[element_id]
    if not select_el or select_el.type ~= "singleselect" then return end
    
    local valid_configs = {}
    if fs.does_file_exist(CONFIG_MANIFEST) then
        local success, list = pcall(json.parse, fs.read_from_file(CONFIG_MANIFEST))
        if success and type(list) == "table" then
            for _, name in ipairs(list) do
                local file_name = name .. ".json"
                if fs.does_file_exist(file_name) then
                    table.insert(valid_configs, name)
                end
            end
        end
    end
    select_el.items = valid_configs
    if #valid_configs == 0 then select_el.items = {"No configs found"} end
    Menu.values[select_el.id] = 1
    
    MenuLib.Notify.push("Config list refreshed", 1)
end

function MenuLib.refresh_config_list(element_id)
    local select_el = Menu.elements[element_id]
    if not select_el or select_el.type ~= "singleselect" then return end
    local valid_configs = {}
    if fs.does_file_exist(CONFIG_MANIFEST) then
        local success, list = pcall(json.parse, fs.read_from_file(CONFIG_MANIFEST))
        if success and type(list) == "table" then
            for _, name in ipairs(list) do
                local file_name = name .. ".json"
                if fs.does_file_exist(file_name) then
                    local s, _ = pcall(json.parse, fs.read_from_file(file_name))
                    if s then table.insert(valid_configs, name) end
                end
            end
        end
    end
    select_el.items = valid_configs
    if #valid_configs == 0 then select_el.items = {"No configs found"} end
    Menu.values[select_el.id] = 1
    engine.log("Config list refreshed.", 200, 200, 255, 255)
end
----CS2


local INDICATOR_OPTIONS = { 
    "Legit Aimbot",  "Triggerbot", 
    "RCS"
}


-- local MenuLib = require("Shooktestmenu")

function is_keybind_active(keybind_id)
    local bind = MenuLib.get_keybind_value(keybind_id)
    if not bind or bind.key == 0 then
        return false 
    end


    if bind.mode == 1 then 
        return input.is_key_down(bind.key)
    elseif bind.mode == 2 then
        return input.is_key_toggled(bind.key)
    elseif bind.mode == 3 then 
        return input.is_key_pressed(bind.key)
    end
    
    return false
end

function parse_pos(pos_string)
    if type(pos_string) ~= "string" then return 0, 0 end
    local x, y = string.match(pos_string, "^(-?%d+),(-?%d+)$")
    if x and y then
        return tonumber(x), tonumber(y)
    end
    return 0, 0 
end

function parse_pos(pos_string)
    if type(pos_string) ~= "string" then return 0, 0 end
    local x, y = string.match(pos_string, "^(-?%d+),(-?%d+)$")
    if x and y then
        return tonumber(x), tonumber(y)
    end
    return 0, 0
end

MenuLib.initialize({ key = 0x2E, default_tab = "legit" })


local legit_sub_tabs = {
    { id = "legit_pistol", name = "PISTOL", anim = 0 },
    { id = "legit_deagle", name = "DEAGLE", anim = 0 },
    { id = "legit_smg",    name = "SMG",    anim = 0 },
    { id = "legit_rifle",  name = "RIFLE",  anim = 0 },
    { id = "legit_shotgun",name = "SHOTGUN",anim = 0 },
    { id = "legit_sniper", name = "SNIPERS",anim = 0 }
}

    local visuals_sub_tabs = {
        { id = "vis_enemy", name = "ENEMY", anim = 0 },
        { id = "vis_team",  name = "TEAM",  anim = 0 },
        { id = "vis_world", name = "WORLD", anim = 0 },
        { id = "vis_misc",  name = "MISC",  anim = 0 }
    }


table.insert(Menu.tabs, {id = "legit", name = "Legit", anim = 0, sub_tabs = legit_sub_tabs})
Menu.active_sub_tab = "legit_rifle"

table.insert(Menu.tabs, {id = "visuals", name = "Visuals", anim = 0, sub_tabs = visuals_sub_tabs})
MenuLib.add_tab("misc", "Misc")
MenuLib.add_tab("configs", "Configs")




function create_weapon_settings(sub_tab_id, weapon_name)
    local legit_general = MenuLib.add_group(sub_tab_id, weapon_name .. " Aimbot", 1)
    local legit_rcs = MenuLib.add_group(sub_tab_id, "Recoil Control", 2)
    local legit_trigger = MenuLib.add_group(sub_tab_id, "Triggerbot", 2)

    MenuLib.add_element(legit_general, "checkbox", sub_tab_id .. "_legit_enabled", "Enable Aimbot")
    MenuLib.add_element(legit_general, "checkbox", sub_tab_id .. "_legit_vis_check", "Visibility Check")
     MenuLib.add_element(legit_general, "checkbox", sub_tab_id .. "_autostop", "Auto Stop")
       MenuLib.add_element(legit_general, "slider", sub_tab_id .. "_autostop_strength", "Stop Strength (ms)", { min = 20, max = 150, default = 50 })
    MenuLib.add_element(legit_general, "singleselect", sub_tab_id .. "_autostop_mode", "Stop Mode", { items = { "On Fire", "On Aimbot Key", "Always" }, default = 1 })
    MenuLib.add_element(legit_general, "keybind", sub_tab_id .. "_legit_key", "Aimbot Key", { default_key = 90, default_mode = 1 })
    MenuLib.add_element(legit_general, "slider", sub_tab_id .. "_legit_fov", "Aim FOV", { min = 0, max = 100, default = 10 })
    MenuLib.add_element(legit_general, "slider", sub_tab_id .. "_legit_smoothing", "Aim Smoothing", { min = 5, max = 100, default = 8 })
    MenuLib.add_element(legit_general, "slider_float", sub_tab_id .. "_legit_switch_delay", "Target Switch Delay", { min = 0.0, max = 1.0, default = 0.3 })
    MenuLib.add_element(legit_general, "multiselect", sub_tab_id .. "_legit_hitbox", "Aim Hitboxes", { 
        items = { "Head", "Neck", "Chest", "Stomach", "Pelvis" },
        default = { [1] = true }
    })
    MenuLib.add_element(legit_general, "slider", sub_tab_id .. "_legit_human_factor", "Human Factor", { min = 5, max = 100, default = 8 })
    MenuLib.add_element(legit_general, "singleselect", sub_tab_id .. "_legit_target_mode", "Aim Priority", { items = { "Closest to Crosshair", "Highest Damage" } })    MenuLib.add_element(legit_general, "checkbox", sub_tab_id .. "_legit_draw_fov", "Draw FOV Circle")
    MenuLib.add_element(legit_general, "checkbox", sub_tab_id .. "_legit_prediction_enabled", "Enable Prediction")
    MenuLib.add_element(legit_general, "keybind", sub_tab_id .. "_legit_prediction_key", "Prediction Key", { default_key = 0, default_mode = 1 })
    MenuLib.add_element(legit_general, "slider_float", sub_tab_id .. "_legit_prediction_h", "Horizontal Prediction", { min = 0.0, max = 1.0, default = 0.05 })
    MenuLib.add_element(legit_general, "slider_float", sub_tab_id .. "_legit_prediction_v", "Vertical Prediction", { min = 0.0, max = 1.0, default = 0.0 })
    MenuLib.add_element(legit_trigger, "keybind", sub_tab_id .. "_trigger_rapid_key", "PredictionBot", { default = 0, mode = key_mode.onhotkey })
    MenuLib.add_element(legit_trigger, "slider", sub_tab_id .. "_trigger_rapid_reduction", "PredictionBot Delay Reduction (ms)", { min = 0, max = 100, default = 20 })

    MenuLib.add_element(legit_rcs, "checkbox", sub_tab_id .. "_rcs_enabled", "Enable RCS")
    MenuLib.add_element(legit_rcs, "slider_float", sub_tab_id .. "_rcs_strength_x", "Strength (Vertical)", { min = 0.0, max = 2.0, default = 2.0 })
    MenuLib.add_element(legit_rcs, "slider_float", sub_tab_id .. "_rcs_strength_y", "Strength (Horizontal)", { min = 0.0, max = 2.0, default = 2.0 })
    MenuLib.add_element(legit_rcs, "slider", sub_tab_id .. "_rcs_start_bullet", "Start Bullet", { min = 1, max = 10, default = 2 })
    MenuLib.add_element(legit_rcs, "slider", sub_tab_id .. "_rcs_smooth", "Smoothing", { min = 1, max = 30, default = 8 })
    MenuLib.add_element(legit_rcs, "slider_float", sub_tab_id .. "_rcs_humanize", "Humanize (Jitter)", { min = 0.0, max = 1.0, default = 0.2 })


    MenuLib.add_element(legit_trigger, "checkbox", sub_tab_id .. "_trigger_enabled", "Enable Triggerbot", { default = true })
    MenuLib.add_element(legit_trigger, "keybind", sub_tab_id .. "_trigger_key", "Trigger Hotkey", { default = 0x05, mode = key_mode.onhotkey })
    
    MenuLib.add_element(legit_trigger, "slider", sub_tab_id .. "_trigger_delay", "Trigger Delay (ms)", { min = 0, max = 250, default = 25 })
    
    MenuLib.add_element(legit_trigger, "checkbox", sub_tab_id .. "_trigger_dynamic_delay_enabled", "Enable Dynamic Delay")

    MenuLib.add_element(legit_trigger, "slider", sub_tab_id .. "_trigger_dynamic_delay_min", "Min Dynamic Delay (ms)", { min = 0, max = 250, default = 20 })
    MenuLib.add_element(legit_trigger, "slider", sub_tab_id .. "_trigger_dynamic_delay_max", "Max Dynamic Delay (ms)", { min = 0, max = 250, default = 60 })

    MenuLib.add_element(legit_trigger, "slider", sub_tab_id .. "_trigger_hitchance", "Min Hitchance (%)", { min = 0, max = 100, default = 70 })
        MenuLib.add_element(legit_trigger, "checkbox", sub_tab_id .. "_trigger_magnet", "Magnet Trigger (Bone Check)", { default = true })
    MenuLib.add_element(legit_trigger, "checkbox", sub_tab_id .. "_trigger_team_check", "Team Check", { default = true })
end

for _, sub_tab in ipairs(legit_sub_tabs) do
    create_weapon_settings(sub_tab.id, sub_tab.name)
end


  -- [[ VISUALS GROUPS ]]
    
    -- 1. Enemy
    local vis_enemy_main = MenuLib.add_group("vis_enemy", "Enemy ESP", 1)
    local vis_enemy_colors = MenuLib.add_group("vis_enemy", "Enemy Colors", 2)
    local vis_enemy_glow = MenuLib.add_group("vis_enemy", "Enemy Glow", 2)

    -- 2. Team
    local vis_team_main = MenuLib.add_group("vis_team", "Team ESP", 1)
    local vis_team_colors = MenuLib.add_group("vis_team", "Team Colors", 2)

    -- 3. World
    local vis_world_main = MenuLib.add_group("vis_world", "World ESP", 1)
    local vis_world_settings = MenuLib.add_group("vis_world", "World Settings", 2)
    local vis_world_colors = MenuLib.add_group("vis_world", "Colors", 2)

    -- 4. Misc (Visuals)
    local vis_misc_main = MenuLib.add_group("vis_misc", "Crosshair & Indicators", 1)
    local vis_misc_view = MenuLib.add_group("vis_misc", "View", 2)
    

    -- [[ ENEMY VISUALS ELEMENTS ]]
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_enabled", "Enable Enemy ESP")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_box", "Box")
    MenuLib.add_element(vis_enemy_main, "singleselect", "esp_box_type", "Box Type", { items = { "Normal", "Corner", "Filled" }, default = 3 })
MenuLib.add_element(vis_enemy_main, "singleselect", "esp_skeleton_mode", "Skeleton", { items = { "Off", "Normal", "Circular", "Traced", "Neon"} })    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_money", "Money")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_health", "Health Bar", { default = true })
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_snaplines", "Snaplines")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_name", "Name")
    -- MenuLib.add_element(vis_enemy_main, "checkbox", "esp_floating_damage", "Floating Damage Text")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_armor", "Armor Bar")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_distance", "Distance")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_player_weapon", "Weapon")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_scoped_flag", "Scoped Flag")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_flashed_flag", "Flashed Flag")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_c4_carrier", "Bomb Carrier Flag")
    MenuLib.add_element(vis_enemy_main, "checkbox", "esp_oof_arrows", "Out of View Arrows")
    MenuLib.add_element(vis_enemy_main, "slider", "esp_oof_radius", "Arrow Radius", { min = 50, max = 500, default = 250 })
    MenuLib.add_element(vis_enemy_main, "slider", "esp_oof_size", "Arrow Size", { min = 8, max = 30, default = 14 })
MenuLib.add_element(vis_enemy_main, "checkbox", "esp_sound_world", "Sound ESP (World Rings)")
    
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_sound_world_color", "Sound Ring Color", { default = {255, 50, 50, 255} })

    MenuLib.add_element(vis_enemy_chams, "checkbox", "esp_ext_chams_enemy", "External Chams")
MenuLib.add_element(vis_enemy_chams, "colorpicker_button", "esp_ext_chams_fill_enemy", "Fill Color", { default = {255, 105, 180, 200} }) -- Default Pink
MenuLib.add_element(vis_enemy_chams, "colorpicker_button", "esp_ext_chams_out_enemy", "Outline Color", { default = {255, 255, 255, 255} }) -- Default White


    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_box_color", "Box Color (Hidden)", { default = {255, 50, 50, 255} })
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_box_color_vis", "Box Color (Visible)", { default = {0, 255, 0, 255} }) 
    
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_skeleton_color", "Skeleton (Hidden)", { default = {200, 200, 200, 255} })
MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_skeleton_color_vis", "Skeleton (Visible)", { default = {0, 255, 0, 255} })    
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_name_color", "Name Color", { default = {255, 255, 255, 255} })
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_money_color", "Money Color", { default = {50, 200, 50, 255} })
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_distance_color", "Distance Color", { default = {220, 220, 220, 255} })
    MenuLib.add_element(vis_enemy_colors, "colorpicker_button", "esp_oof_color", "OoF Arrow Color", { default = {255, 50, 50, 200} })

    MenuLib.add_element(vis_enemy_glow, "checkbox", "esp_glow_enemy", "Enable Glow")
    MenuLib.add_element(vis_enemy_glow, "colorpicker_button", "esp_glow_color_enemy", "Glow Color", { default = {255, 0, 0, 255} })

    -- [[ TEAM VISUALS ELEMENTS ]]
    MenuLib.add_element(vis_team_main, "checkbox", "team_esp_enabled", "Enable Team ESP")
    MenuLib.add_element(vis_team_main, "checkbox", "team_box", "Box")
    MenuLib.add_element(vis_team_main, "singleselect", "team_box_type", "Box Type", { items = { "Normal", "Corner", "Filled" }, default = 1 })
    MenuLib.add_element(vis_team_main, "singleselect", "team_skeleton_mode", "Skeleton", { items = { "Off", "Normal", "Circular"} })
    MenuLib.add_element(vis_team_main, "checkbox", "team_name", "Name")
    MenuLib.add_element(vis_team_main, "checkbox", "team_health", "Health Bar", { default = true })
    MenuLib.add_element(vis_team_main, "checkbox", "team_armor", "Armor Bar")
    MenuLib.add_element(vis_team_main, "checkbox", "team_weapon", "Weapon")
    

    MenuLib.add_element(vis_team_chams, "checkbox", "team_ext_chams", "External Chams")
MenuLib.add_element(vis_team_chams, "colorpicker_button", "team_ext_chams_fill", "Fill Color", { default = {0, 150, 255, 200} })
MenuLib.add_element(vis_team_chams, "colorpicker_button", "team_ext_chams_out", "Outline Color", { default = {255, 255, 255, 255} })


    MenuLib.add_element(vis_team_colors, "colorpicker_button", "team_box_color", "Box Color", { default = {0, 150, 255, 255} })
    MenuLib.add_element(vis_team_colors, "colorpicker_button", "team_skeleton_color", "Skeleton Color", { default = {200, 200, 200, 255} })
    MenuLib.add_element(vis_team_colors, "colorpicker_button", "team_name_color", "Name Color", { default = {255, 255, 255, 255} })
    
    -- [[ WORLD VISUALS ELEMENTS ]]
    MenuLib.add_element(vis_world_main, "checkbox", "esp_dropped_weapons", "Dropped Weapons")
    MenuLib.add_element(vis_world_main, "checkbox", "esp_projectiles", "Grenades")
    MenuLib.add_element(vis_world_main, "checkbox", "esp_bomb", "C4 Bomb")
    MenuLib.add_element(vis_world_main, "checkbox", "esp_chickens", "Chickens")

    MenuLib.add_element(vis_world_settings, "checkbox", "world_nightmode", "Nightmode")
    MenuLib.add_element(vis_world_settings, "slider_float", "world_nightmode_intensity", "Nightmode Intensity", { min = 1.0, max = 100.0, default = 50.0 })
    MenuLib.add_element(vis_world_settings, "checkbox", "world_smoke_mod", "Smoke Color Mod", { default = true })

    MenuLib.add_element(vis_world_colors, "colorpicker_button", "esp_bomb_color", "Bomb Color", { default = {255, 50, 50, 255} })
    MenuLib.add_element(vis_world_colors, "colorpicker_button", "world_smoke_color", "Smoke Color", { default = {170, 0, 255, 255} })

    -- [[ MISC VISUALS ELEMENTS ]]
    MenuLib.add_element(vis_misc_main, "checkbox", "sniper_crosshair_enabled", "Sniper Crosshair")
    MenuLib.add_element(vis_misc_main, "checkbox", "recoil_dot_enabled", "Recoil Dot")
    MenuLib.add_element(vis_misc_main, "colorpicker_button", "recoil_dot_color", "Recoil Dot Color", { default = {255, 0, 0, 255} })
    MenuLib.add_element(vis_misc_main, "checkbox", "crosshair_enabled", "Custom Crosshair")
    MenuLib.add_element(vis_misc_main, "colorpicker_button", "crosshair_color", "Crosshair Color", { default = {255, 255, 255, 255} })
    MenuLib.add_element(vis_misc_main, "slider", "crosshair_thickness", "Thickness", { min = 0, max = 10, default = 2 })
    MenuLib.add_element(vis_misc_main, "slider", "crosshair_gap", "Gap", { min = 0, max = 10, default = 3 })

MenuLib.add_element(vis_enemy_chams, "checkbox", "esp_chams_enemy", "Enable Chams")
    MenuLib.add_element(vis_enemy_chams, "colorpicker_button", "esp_chams_color_enemy", "Chams Color", { default = {255, 0, 0, 255} })

    -- [[ TEAM CHAMS ]]
    MenuLib.add_element(vis_team_chams, "checkbox", "team_chams_enabled", "Enable Chams")
    MenuLib.add_element(vis_team_chams, "colorpicker_button", "team_chams_color", "Chams Color", { default = {0, 255, 0, 255} })



local misc_general = MenuLib.add_group("misc", "General", 1)
local misc_indicators = MenuLib.add_group("misc", "Indicators", 1)
local misc_watermark = MenuLib.add_group("misc", "Watermark", 2)
local misc_crosshair = MenuLib.add_group("misc", "Crosshair", 2)
local misc_speclist = MenuLib.add_group("misc", "Spectator List", 2)



MenuLib.add_element(misc_general, "checkbox", "misc_speclist", "Spectator List")
MenuLib.add_element(misc_general, "checkbox", "misc_c4timer", "C4 Timer Panel")
MenuLib.add_element(misc_general, "checkbox", "misc_radar", "Radar")
MenuLib.add_element(misc_general, "checkbox", "misc_anti_flash", "Enable Anti-Flash")

MenuLib.add_element(misc_general, "checkbox", "misc_bhop", "Enable Bunnyhop", { default = true })

MenuLib.add_element(misc_indicators, "multiselect", "indicator_features", "Enabled Indicators", { items = INDICATOR_OPTIONS, default = {[1]=true,[2]=true} })
MenuLib.add_element(misc_indicators, "colorpicker_button", "indicator_accent_color", "Indicator Accent", { default = {255, 0, 0, 255} })

MenuLib.add_element(misc_indicators, "input_text", "pos_watermark", "Watermark Position", { default = "20,20" })
MenuLib.add_element(misc_indicators, "input_text", "pos_speclist", "Spectator List Position", { default = "100,120" })
MenuLib.add_element(misc_indicators, "input_text", "pos_bomb", "Bomb Timer Position", { default = "25,200" })

MenuLib.add_element(misc_watermark, "checkbox", "watermark_enabled", "Enable Watermark")
MenuLib.add_element(misc_watermark, "colorpicker_button", "watermark_bg_color", "Background Color", { default = {18, 18, 18, 255} })
MenuLib.add_element(misc_watermark, "colorpicker_button", "watermark_outline_color", "Outline Color", { default = {30, 30, 30, 255} })
MenuLib.add_element(misc_watermark, "colorpicker_button", "watermark_text_color", "Text Color", { default = {200, 200, 200, 255} })


MenuLib.add_element(misc_crosshair, "checkbox", "sniper_crosshair_enabled", "Sniper Crosshair", { default = true })

MenuLib.add_element(misc_crosshair, "checkbox", "misc_hitmarker", "Dynamic Hitmarker")
MenuLib.add_element(misc_crosshair, "colorpicker_button", "misc_hitmarker_color", "Hitmarker Color", { default = {255, 255, 255, 255} })


MenuLib.add_element(misc_speclist, "colorpicker_button", "speclist_bg_color", "Background Color", { default = {18, 18, 18, 255} })
MenuLib.add_element(misc_speclist, "colorpicker_button", "speclist_outline_color", "Outline Color", { default = {30, 30, 30, 255} })
MenuLib.add_element(misc_speclist, "colorpicker_button", "speclist_text_color", "Text Color", { default = {200, 200, 200, 255} })
MenuLib.add_element(misc_speclist, "colorpicker_button", "speclist_header_color", "Header Color", { default = {200, 200, 200, 255} })



local cfg_main = MenuLib.add_group("configs", "Manage Settings", 1)

MenuLib.add_element(cfg_main, "label", "cfg_info", "Select a config to load or overwrite.")
MenuLib.add_element(cfg_main, "singleselect", "cfg_list_select", "Saved Configs", {
    items = {"Click Refresh..."}
})
MenuLib.add_element(cfg_main, "label", "cfg_info_2", "Or type a name below to create a new config.")
MenuLib.add_element(cfg_main, "input_text", "cfg_name_input", "New Config Name", { default = "" })

MenuLib.add_element(cfg_main, "button", "cfg_load", "Load Selected Config", {
    callback = function()
        local list_element = Menu.elements["cfg_list_select"]
        if not list_element then return end
        
        local selected_index = MenuLib.get_value("cfg_list_select")
        local selected_name = list_element.items[selected_index]
        
        if selected_name and selected_name ~= "No configs found" and selected_name ~= "Click Refresh..." then
            MenuLib.load_config(selected_name)
        else
            engine.log("No config selected to load.", 255, 100, 100, 255)
        end
    end
})



MenuLib.add_element(cfg_main, "button", "cfg_export_clipboard", "Export to Clipboard (Base64)", {
    callback = function()
        local config_data = {}
        for id, value in pairs(Menu.values) do 
            config_data[id] = value 
        end
        
        local success, json_str = pcall(json.stringify, config_data)
        if not success then
            MenuLib.Notify.push("Failed to serialize config", 3)
            return
        end

        local b64 = net.base64_encode(json_str)
        
        if b64 then
            input.set_clipboard(b64)
            MenuLib.Notify.push("Config copied to clipboard!", 2)
            engine.log("Config exported to clipboard.", 100, 255, 100, 255)
        else
            MenuLib.Notify.push("Export failed", 3)
        end
    end
})

MenuLib.add_element(cfg_main, "button", "cfg_import_clipboard", "Import from Clipboard", {
    callback = function()
        local b64 = input.get_clipboard()
        if not b64 or b64 == "" then
            MenuLib.Notify.push("Clipboard is empty", 3)
            return
        end

        local json_str = net.base64_decode(b64)
        if not json_str or json_str == "" then
            MenuLib.Notify.push("Invalid Base64 string", 3)
            return
        end

        local success, config_data = pcall(json.parse, json_str)
        if not success or type(config_data) ~= "table" then
            MenuLib.Notify.push("Invalid Config format", 3)
            return
        end

        local count = 0
        for id, loaded_value in pairs(config_data) do
            if Menu.values[id] ~= nil then
                local current_value = Menu.values[id]
                
                if type(current_value) == "table" and current_value.key ~= nil then
                    if type(loaded_value) == "table" then
                        current_value.key = loaded_value.key
                        current_value.mode = loaded_value.mode
                    end
                elseif type(current_value) == "table" and current_value.h ~= nil then
                    if type(loaded_value) == "table" and loaded_value.h then
                        current_value.h = loaded_value.h
                        current_value.s = loaded_value.s
                        current_value.v = loaded_value.v
                        current_value.a = loaded_value.a
                    end
                else
                    Menu.values[id] = loaded_value
                end
                count = count + 1
            end
        end
        
        MenuLib.Notify.push("Applied " .. count .. " settings", 2)
        engine.log("Config imported from clipboard (Temporary). Save to file to keep.", 255, 200, 100, 255)
    end
})

MenuLib.add_element(cfg_main, "button", "cfg_save", "Save Config", {
    callback = function()
        local new_name_from_input = MenuLib.get_value("cfg_name_input")
        
        if new_name_from_input and new_name_from_input ~= "" then
            MenuLib.save_config(new_name_from_input)
            MenuLib.set_value("cfg_name_input", "") 
            MenuLib.refresh_config_list("cfg_list_select")
        
        else
            local list_element = Menu.elements["cfg_list_select"]
            if not list_element then return end
            
            local selected_index = MenuLib.get_value("cfg_list_select")
            local selected_name = list_element.items[selected_index]
            
            if selected_name and selected_name ~= "No configs found" and selected_name ~= "Click Refresh..." then
                MenuLib.save_config(selected_name)
            else
                engine.log("No config selected to save over, and no new name provided.", 255, 100, 100, 255)
            end
        end
    end
})

MenuLib.add_element(cfg_main, "button", "cfg_refresh", "Refresh List", {
    callback = function()
        MenuLib.refresh_config_list("cfg_list_select")
    end
})


MenuLib.refresh_config_list("cfg_list_select")

MenuLib.add_element(cfg_main, "keybind", "menu_open_key", "Menu Key", { default_key = 0x2E })

engine.log("SaikaidoSense UI Fully Loaded! Press INSERT to open.", 255, 0, 0, 255)


local config_logs = {}
local LayoutState = {
    dragging_id = nil, drag_offset_x = 0, drag_offset_y = 0,
    hitboxes = {},
    offsets = {
        name     = { x = 0, y = -100 },  -- Negative Y = Top Preference
        health   = { x = -100, y = 0 },
        armor    = { x = 0, y = 200 },
        weapon   = { x = 0, y = 100 },   -- Positive Y = Bottom Preference
        distance = { x = 0, y = 110 },   -- Slightly lower = Below weapon
        money    = { x = 100, y = -50 }, -- Right side, upper
        flags    = { x = 100, y = 0 },    -- Right side, middle
        c4_carrier = { x = 100, y = 25 }
    }
}


local PreviewAnim = {
    slide_progress = 0,      -- 0 to 1
    last_tab = "",           -- To reset anim on tab switch
    hover_timers = {},       -- Smooth fade for hovering elements
    pulse = 0                -- Breathing effect
}

local function draw_shook_style_bar(x, y, w, h, pct, color, orientation)
    render.draw_rectangle(x, y, w, h, 20, 22, 25, 150, 0, true)
    render.draw_rectangle(x, y, w, h, 0, 0, 0, 200, 1, false)

    if pct > 0.01 then
        local r, g, b, a = color[1], color[2], color[3], color[4]
        
        local PAD = 1
        
        if orientation == "vertical" then
            local max_h = h - (PAD*2)
            local fill_h = math.floor(max_h * pct)
            local fill_y = (y + h - PAD) - fill_h
            
            if fill_h > 0 then
                 render.draw_rectangle(x+PAD, fill_y, w-(PAD*2), fill_h, r, g, b, a, 0, true)
            end
        else
            local max_w = w - (PAD*2)
            local fill_w = math.floor(max_w * pct)
            
            if fill_w > 0 then
                render.draw_rectangle(x+PAD, y+PAD, fill_w, h-(PAD*2), r, g, b, a, 0, true)
            end
        end
    end
end
local function LogSuccess(msg)
    table.insert(config_logs, {
        text = msg,
        time = winapi.get_tickcount64(),
        color = {0, 255, 0, 255},
    })
end
local function LogError(msg)
    table.insert(config_logs, {
        text = msg,
        time = winapi.get_tickcount64(),
        color = {255, 0, 0, 255},
    })
end







-- local bombpanel_drag_x, bombpanel_drag_y = 25, 200
-- local bombpanel_dragging = false
-- local bombpanel_drag_offset_x, bombpanel_drag_offset_y = 0, 0

-- local hitlog_cache = {
--     health = {},
--     last_local_shots = -1,
--     last_shot_time = 0
-- }

local g_State = {
    DESIGN_MODE_APPEAR_TIME = 0.18,
 DESIGN_MODE_FADE_TIME = 0.18,
 WATERMARK_APPEAR_TIME = 0.18,
 WATERMARK_FADE_TIME = 0.18,
  skin = { 
        engine_dll = 0,
        force_update = false
    },
}
local skin_cfg = {
    [7]   = 433, -- AK-47
    [9]   = 344, -- AWP
    [61]  = 504, -- USP-S
    [4]   = 38,  -- Glock
    [1]   = 37,  -- Deagle
    [16]  = 430, -- M4A4
    [60]  = 430, -- M4A1-S
    [40]  = 222, -- SSG 08
}

local screen_size_x, screen_size_y = render.get_viewport_size()
local DisplaySystem = {
    config = {
        welcome_duration = 3,
        fade_duration = 0.5,
        box_padding = 8,
        blur_opacity = 0.8,
        username = get_user_name(),
        crosshair = {
            enabled = true,
            color = {255, 255, 255},
            size = 12,
            thickness = 2,
            gap = 3
        },
        watermark_enabled = true,
        -- watermark_position = ui_state.wtpos:get(),
        bg_color = {18, 18, 18},
        border_color = {100, 100, 255},
        text_color = {200, 200, 200},
        welcome_color = {255, 255, 255},
    },
    state = {
        phase = "welcome",
        start_time = winapi.get_tickcount64(),
        fade_out_start = 0,
        frame_count = 0,
        last_fps_time = winapi.get_tickcount64(),
        fps_value = render.get_fps(),
        _design_mode_start_time = 0,
        _design_mode_fade_start_time = 0,
        _design_mode_visible = false,
        _design_mode_fading_out = false,
        _watermark_start_time = 0,
        _watermark_fade_start_time = 0,
        _watermark_visible = false,
        _watermark_fading_out = false,
        _crosshair_start_time = 0,
        _crosshair_fade_start_time = 0,
        _crosshair_visible = false,
        _crosshair_fading_out = false,
    },
    fonts = {
        welcome = render.create_font("Arial", 48, 700),
        main = render.create_font("Verdana", 14, 500),
        icon = render.create_font("Arial", 18, 700),
        logo = render.create_font("Verdana", 12, 700) 
    }
}


local speclist_anim = {
    visible = false,
    anim_progress = 0,
    anim_time = 0.18,
    alpha = 0,
    slide_offset = 0,
    fading_out = false,
    last_state = false,
    last_tick = 0,
}


local nightmode_state = {
    has_saved_original_values = false,
    original_min_exposure = 1.0,
    original_max_exposure = 1.0,
}


local trigger_last_shot_time = 0
local trigger_pending_actions = {}
local last_trigger_delay = 0


local hitsound_path = "sounds/hitsound.mp3"
local total_damage = 0
local process = {
    is_open = false,
    client_dll = 0,
}


local TARGET_DESIGNER_NAME = "smokegrenade_projectile"
local _floating_damage_list = {}

local hitlog_messages = {}
local function add_hitlog_message(msg)
    table.insert(hitlog_messages, {
        text = msg,
        time = winapi.get_tickcount64(),
        alpha = 255
    })
end
local HITLOG_SHOW_TIME = 2.5
local HITLOG_FADE_TIME = 0.5
local hitlog_box_pad = 12
local hitlog_box_width = 0
local hitlog_box_height = 0
do
    local example_msgs = {
        "Hit an enemy for -100 damage",
        "Hit an enemy for -55 damage",
        "Hit an enemy for -1 damage",
        "Hit an enemy for -999 damage"
    }
    for _, msg in ipairs(example_msgs) do
        local tw, th = render.measure_text(DisplaySystem.fonts.main, msg)
        if tw > hitlog_box_width then hitlog_box_width = tw end
        if th > hitlog_box_height then hitlog_box_height = th end
    end
    hitlog_box_width = hitlog_box_width + hitlog_box_pad * 2
    hitlog_box_height = hitlog_box_height + hitlog_box_pad * 2
end

local configlog_box_pad = 6
local configlog_box_spacing = 8
local configlog_box_width, configlog_box_height = 0, 0
do
    local sample = "Config saved!"
    local tw, th = render.measure_text(DisplaySystem.fonts.main, sample)
    configlog_box_width = tw + configlog_box_pad * 2
    configlog_box_height = th + configlog_box_pad * 2
end

-- local watermark_drag_x, watermark_drag_y = 20, 20
-- local watermark_dragging = false
-- local watermark_drag_offset_x, watermark_drag_offset_y = 0, 0
-- local speclist_drag_x, speclist_drag_y = 100, 120
-- local speclist_dragging = false
-- local speclist_drag_offset_x, speclist_drag_offset_y = 0, 0

-- local function update_speclist_textfields()
--     if ui_state and ui_state.specpos then
--         ui_state.specpos:set(string.format("%d,%d", speclist_drag_x, speclist_drag_y))
--     end
-- end
-- local function update_watermark_textfields()
--     if ui_state and ui_state.wtpos then
--         ui_state.wtpos:set(string.format("%d,%d", watermark_drag_x, watermark_drag_y))
--     end
-- end

-- if bombpanel_dragging then
--     bombpanel_drag_x = mx - bombpanel_drag_offset_x
--     bombpanel_drag_y = my - bombpanel_drag_offset_y
--     if ui_state.bombpanelpos then
--         ui_state.bombpanelpos:set(string.format("%d,%d", bombpanel_drag_x, bombpanel_drag_y))
--     end
-- end
-- if ui_state and ui_state.bombpanelpos and not bombpanel_dragging then
--     local val = ui_state.bombpanelpos:get()
--     local x, y = string.match(val, "^(%-?%d+),(%-?%d+)$")
--     if x and y then
--         bombpanel_drag_x = tonumber(x)
--         bombpanel_drag_y = tonumber(y)
--     end
-- end

-- if ui_state and ui_state.specpos and ui_state.specpos.on_change then
--     ui_state.specpos:on_change(function(val)
--         local x, y = string.match(val, "^(%-?%d+),(%-?%d+)$")
--         if x and y then
--             speclist_drag_x = tonumber(x)
--             speclist_drag_y = tonumber(y)
--         end
--     end)
-- end

if watermark_dragging then
    watermark_drag_x = mx - watermark_drag_offset_x
    watermark_drag_y = my - watermark_drag_offset_y
    update_watermark_textfields()
end


local function draw_capsule_line(p1, p2, radius, r, g, b, a)
    local dx = p2.x - p1.x
    local dy = p2.y - p1.y
    local len = math.sqrt(dx*dx + dy*dy)

    if len <= 0 then return end

    local nx = -dy / len
    local ny = dx / len

    local ox = nx * radius
    local oy = ny * radius

    local points = {
        p1.x + ox, p1.y + oy,
        p2.x + ox, p2.y + oy,
        p2.x - ox, p2.y - oy,
        p1.x - ox, p1.y - oy
    }

    render.draw_polygon(points, r, g, b, a, 0, true)
    render.draw_circle(p1.x, p1.y, radius, r, g, b, a, 0, true)
    render.draw_circle(p2.x, p2.y, radius, r, g, b, a, 0, true)
end

if not _vis_cache then _vis_cache = {} end
local _last_neon_cache_clear = 0

function draw_neon_skeleton(bones_2d, col_hidden, h_box, bones_3d, local_eye, col_visible, ent_index)
    if not bones_2d then return end
    
    local now = winapi.get_tickcount64()
    
    if (now - _last_neon_cache_clear) > 2000 then 
        _vis_cache = {}
        _last_neon_cache_clear = now 
    end

    ent_index = ent_index or 999999
    if not _vis_cache[ent_index] then _vis_cache[ent_index] = {} end

    local can_trace = (bones_3d and local_eye and MapParser and MapParser.is_visible)
    local scale = math.max(0.3, (h_box or 200) / 400)
    
    local connections = {
        {"head", "neck_0"}, {"neck_0", "spine_1"}, {"spine_1", "spine_2"}, {"spine_2", "pelvis"},
        {"neck_0", "arm_upper_L"}, {"arm_upper_L", "arm_lower_L"}, {"arm_lower_L", "hand_L"},
        {"neck_0", "arm_upper_R"}, {"arm_upper_R", "arm_lower_R"}, {"arm_lower_R", "hand_R"},
        {"pelvis", "leg_upper_L"}, {"leg_upper_L", "leg_lower_L"}, {"leg_lower_L", "ankle_L"},
        {"pelvis", "leg_upper_R"}, {"leg_upper_R", "leg_lower_R"}, {"leg_lower_R", "ankle_R"}
    }

    local function is_vis(bone_name)
        if not can_trace or not bones_3d[bone_name] then return false end
        
        local entry = _vis_cache[ent_index][bone_name]
        if entry and (now - entry.time < 50) then return entry.visible end

        local res = MapParser.is_visible(local_eye, bones_3d[bone_name])
        _vis_cache[ent_index][bone_name] = { time = now, visible = res }
        return res
    end

    for _, pair in ipairs(connections) do
        local b1, b2 = pair[1], pair[2]
        local p1, p2 = bones_2d[b1], bones_2d[b2]
        
        if p1 and p2 then
            local segment_visible = is_vis(b1) or is_vis(b2)
            local current_col = segment_visible and (col_visible or {0, 255, 0, 255}) or col_hidden
            
            local r, g, b, a = current_col[1], current_col[2], current_col[3], current_col[4] or 255

            render.draw_line(p1.x, p1.y, p2.x, p2.y, r, g, b, math.floor(a * 0.08), 14 * scale)
            render.draw_line(p1.x, p1.y, p2.x, p2.y, r, g, b, math.floor(a * 0.2), 7 * scale)
            render.draw_line(p1.x, p1.y, p2.x, p2.y, r, g, b, math.floor(a * 0.5), 3.5 * scale)
            local cr = math.min(255, r + 100)
            local cg = math.min(255, g + 100)
            local cb = math.min(255, b + 100)
            render.draw_line(p1.x, p1.y, p2.x, p2.y, cr, cg, cb, a, 1.2 * scale)
        end
    end
end

function draw_capsule_skeleton(bones_2d, scale, color)
    if not color or type(color) ~= "table" then color = {255, 255, 255, 255} end
    
    local r, g, b, a = table.unpack(color)
    a = a or 255 
    
    local outline_a = math.max(0, a - 40)
    local base = 4.5 * scale 

    local connections = {
        {"pelvis",  "spine_1", 3.8}, 
        {"spine_1", "spine_2", 4.0}, 
        {"spine_2", "spine_3", 4.2}, 
        {"spine_3", "neck",    3.0}, 
        {"neck",    "head",    3.2}, 

        {"spine_3", "clavicle_L", 2.5}, {"spine_3", "clavicle_R", 2.5},
        {"clavicle_L", "arm_upper_L", 2.2}, {"arm_upper_L", "arm_lower_L", 1.9}, {"arm_lower_L", "hand_L", 1.6},
        {"clavicle_R", "arm_upper_R", 2.2}, {"arm_upper_R", "arm_lower_R", 1.9}, {"arm_lower_R", "hand_R", 1.6},
        {"pelvis", "leg_upper_L", 3.2}, {"leg_upper_L", "leg_lower_L", 2.6}, {"leg_lower_L", "ankle_L", 2.0},
        {"pelvis", "leg_upper_R", 3.2}, {"leg_upper_R", "leg_lower_R", 2.6}, {"leg_lower_R", "ankle_R", 2.0},
    }

    local outline_thickness = math.max(1.0, 1.5 * scale) 
    
    for _, bond in ipairs(connections) do
        local p1 = bones_2d[bond[1]]
        local p2 = bones_2d[bond[2]]
        if p1 and p2 then
            local radius = (base * bond[3]) + outline_thickness
            local safe_outline_alpha = math.floor(outline_a * 0.8)
            draw_capsule_line(p1, p2, radius, 0, 0, 0, safe_outline_alpha)
        end
    end
    
    for _, bond in ipairs(connections) do
        local p1 = bones_2d[bond[1]]
        local p2 = bones_2d[bond[2]]
        if p1 and p2 then
            local radius = base * bond[3]
            draw_capsule_line(p1, p2, radius, r, g, b, a)
        end
    end

    local function draw_foot_pass(ank, is_outline)
        local p = bones_2d[ank]
        if p then
            local foot_len = 5 * (scale / 0.8) 
            local foot_end = { x = p.x, y = p.y + foot_len }
            
            local radius = (1.8 * base)
            if is_outline then radius = radius + outline_thickness end
            
            local fr, fg, fb, fa = r, g, b, a
            if is_outline then 
                fr,fg,fb,fa = 0,0,0, math.floor(outline_a * 0.8) 
            end
            
            draw_capsule_line(p, foot_end, radius, fr, fg, fb, fa)
        end
    end

    draw_foot_pass("ankle_L", true); draw_foot_pass("ankle_R", true)
    draw_foot_pass("ankle_L", false); draw_foot_pass("ankle_R", false)
end


local function draw_preview_dummy(rect, alpha)
    local r, g, b = 60, 60, 70
    local outline_r, outline_g, outline_b = 80, 80, 90
    
    local x, y = rect.left, rect.top
    local w = rect.right - rect.left
    local h = rect.bottom - rect.top
    
    local function p(px, py)
        return {
            x + (w * px),
            y + (h * py)
        }
    end

    local body_points = {
        p(0.42, 0.06), -- Head Top Left
        p(0.58, 0.06), -- Head Top Right
        p(0.62, 0.15), -- Neck Right
        p(0.85, 0.19), -- Shoulder Right
        p(0.88, 0.40), -- Elbow Right (Outer)
        p(0.85, 0.58), -- Hand Right
        p(0.78, 0.40), -- Inner Arm Right
        p(0.68, 0.25), -- Armpit Right
        p(0.65, 0.50), -- Hip Right
        p(0.70, 0.75), -- Knee Right
        p(0.75, 0.98), -- Foot Right Outer
        p(0.58, 0.98), -- Foot Right Inner
        p(0.50, 0.60), -- Crotch
        p(0.42, 0.98), -- Foot Left Inner
        p(0.25, 0.98), -- Foot Left Outer
        p(0.30, 0.75), -- Knee Left
        p(0.35, 0.50), -- Hip Left
        p(0.32, 0.25), -- Armpit Left
        p(0.22, 0.40), -- Inner Arm Left
        p(0.15, 0.58), -- Hand Left
        p(0.12, 0.40), -- Elbow Left (Outer)
        p(0.15, 0.19), -- Shoulder Left
        p(0.38, 0.15), -- Neck Left
    }


    render.draw_polygon(body_points, r, g, b, alpha, 0, true)
    
    render.draw_polygon(body_points, outline_r, outline_g, outline_b, alpha, 1.5, false)

    local head_cy = y + (h * 0.10)
    local head_cx = x + (w * 0.5)
    
    render.draw_rectangle(head_cx - (w*0.08), head_cy, w*0.16, h*0.02, 30, 30, 35, alpha, 0, true, 2)
    
    render.draw_rectangle(head_cx - (w*0.12), y + (h*0.25), w*0.24, h*0.15, 45, 45, 50, math.floor(alpha * 0.5), 0, true, 4)
end

function draw_esp_placeholder()
    if not LayoutState.offsets then LayoutState.offsets = {} end
    
    LayoutState.hitboxes = {} 
    
    local now = winapi.get_tickcount64() / 1000 
    PreviewAnim.pulse = (math.sin(now * 4) + 1) * 0.5 

    local current_tab = Menu.active_sub_tab
    if PreviewAnim.last_tab ~= current_tab then
        PreviewAnim.slide_progress = 0
        PreviewAnim.last_tab = current_tab
    end
    PreviewAnim.slide_progress = math.lerp(PreviewAnim.slide_progress, 1.0, 0.15)
    
    local panel_alpha = math.floor(255 * PreviewAnim.slide_progress)
    if panel_alpha < 10 then return end

    local menu_x = Menu.window.x
    local menu_y = Menu.window.y
    local menu_w = Menu.window.w
    local menu_h = Menu.window.h
    
    local pw = 340 
    
    local target_x = menu_x + menu_w + 10
    local bx = target_x - (50 * (1.0 - PreviewAnim.slide_progress))
    local by = menu_y
    local bh = menu_h

    local c_bg = Menu.colors.bg_dark
    local c_acc = Menu.colors.accent
    render.draw_rectangle(bx, by, pw, bh, c_bg[1], c_bg[2], c_bg[3], panel_alpha, 0, true, 8)
    render.draw_rectangle(bx, by, pw, bh, 60, 60, 70, panel_alpha, 1, false, 8)
    render.draw_rectangle(bx + 15, by + 15, 2, 20, c_acc[1], c_acc[2], c_acc[3], panel_alpha, 0, true, 2)

    render.draw_text(Menu.fonts.title, "Visuals Preview", bx + 25, by + 10, 255, 255, 255, panel_alpha, 0, 0, 0, 0, 0)
    render.draw_text(Menu.fonts.main, "Drag text elements to reposition", bx + 25, by + 38, 130, 130, 140, panel_alpha, 0, 0, 0, 0, 0)
    render.draw_line(bx + 15, by + 60, bx + pw - 15, by + 60, 60, 60, 65, panel_alpha, 1)

    local view_x, view_y = bx + 20, by + 80
    local view_w, view_h = pw - 40, bh - 100
    
    local v_cx = view_x + view_w / 2
    local v_cy = view_y + view_h / 2
    
    local box_w, box_h = 140, 280
    
    local top, bot = v_cy - box_h/2, v_cy + box_h/2
    local left, right = v_cx - box_w/2, v_cx + box_w/2
    local rect = { top = top, bottom = bot, left = left, right = right }

    draw_preview_dummy(rect, panel_alpha)

    local prefix = (current_tab and string.find(current_tab, "vis_team")) and "team" or "esp"
    
    -- SAFETY FIX: Added 'index = 999999' to prevent skeleton crash
    local sim_ent = {
        index = 999999, 
        name = "Player",
        health = 92, armor = 100,
        weapon = "AK-47", distance = 18, money = 12000,
        is_scoped = true, is_flashed = true,
        has_c4 = true, 
        rect = rect
    }

    -- Populate hitboxes via render call
    if render_entity_info then
        render_entity_info(sim_ent, prefix, true) 
    end

    local sk_mode = MenuLib.get_value(prefix .. "_skeleton_mode")
    if sk_mode and sk_mode > 1 then
        local sk_col = MenuLib.get_value(prefix .. "_skeleton_color") or {255,255,255,255}
        local function get_bone(px, py)
            return vec2(left + (box_w * px), top + (box_h * py))
        end
        local bones = {
            head=get_bone(0.5, 0.08), neck=get_bone(0.5, 0.15),
            spine=get_bone(0.5, 0.35), pelvis=get_bone(0.5, 0.55),
            left_shoulder=get_bone(0.8, 0.2), left_elbow=get_bone(0.9, 0.35), left_hand=get_bone(0.85, 0.5),
            right_shoulder=get_bone(0.2, 0.2), right_elbow=get_bone(0.1, 0.35), right_hand=get_bone(0.15, 0.5),
            left_hip=get_bone(0.65, 0.55), left_knee=get_bone(0.7, 0.75), left_ankle=get_bone(0.65, 1.0),
            right_hip=get_bone(0.35, 0.55), right_knee=get_bone(0.3, 0.75), right_ankle=get_bone(0.35, 1.0)
        }
        local remap = {
             head="head", neck_0="neck", spine_1="spine", spine_2="pelvis", pelvis="pelvis",
             arm_upper_L="left_shoulder", arm_lower_L="left_elbow", hand_L="left_hand",
             arm_upper_R="right_shoulder", arm_lower_R="right_elbow", hand_R="right_hand",
             leg_upper_L="left_hip", leg_lower_L="left_knee", ankle_L="left_ankle",
             leg_upper_R="right_hip", leg_lower_R="right_knee", ankle_R="right_ankle"
        }
        local draw_bones = {}
        for k, v in pairs(remap) do draw_bones[k] = bones[v] end

        if sk_mode == 2 then 
            -- Normal Skeleton Preview (Pass dummy arguments to satisfy the safe draw_skeleton)
            draw_skeleton(draw_bones, sk_col, nil, nil, nil, 999999)
        elseif sk_mode == 3 then 
            draw_circular_skeleton(draw_bones, 0.8, sk_col)
        elseif sk_mode == 4 then 
            draw_capsule_skeleton(draw_bones, 0.9, sk_col) 
        end
    end

    local mx, my = input.get_mouse_position()
    local lmb_down = input.is_key_down(1)
    local lmb_pressed = input.is_key_pressed(1)

    -- Interaction Logic
    if lmb_pressed and not LayoutState.dragging_id and not Menu.click_consumed then
        for _, zone in ipairs(LayoutState.hitboxes) do
            if mx >= zone.x and mx <= zone.x + zone.w and my >= zone.y and my <= zone.y + zone.h then
                LayoutState.dragging_id = zone.id
                
                local elem_center_x = zone.x + (zone.w / 2)
                local elem_center_y = zone.y + (zone.h / 2)
                
                LayoutState.drag_offset_x = elem_center_x - mx
                LayoutState.drag_offset_y = elem_center_y - my
                
                Menu.click_consumed = true
                break
            end
        end
    end

    if not lmb_down then 
        LayoutState.dragging_id = nil 
    end

    if LayoutState.dragging_id then
        local id = LayoutState.dragging_id
        Menu.click_consumed = true
        
        local target_x = mx + LayoutState.drag_offset_x
        local target_y = my + LayoutState.drag_offset_y
        
        local rel_x = target_x - v_cx
        local rel_y = target_y - v_cy
        
        LayoutState.offsets[id] = { x = rel_x, y = rel_y }
        
        render.draw_line(v_cx, v_cy, target_x, target_y, c_acc[1], c_acc[2], c_acc[3], 150, 1)
        render.draw_circle(v_cx, v_cy, 2, c_acc[1], c_acc[2], c_acc[3], 255, 0, true)
    end
end

local hitmarker = { alpha = 0, last_hit_time = 0 }

local hitlog_health_cache = {}

-- engine.register_on_engine_tick(function()
--     if not IsCS2Active() then return end

--     local now = winapi.get_tickcount64()
--     local elapsed = (now - DisplaySystem.state.start_time) / 1000
--     local vw, vh = render.get_viewport_size()

--  if not watermark_dragging then
--         watermark_drag_x, watermark_drag_y = parse_pos(MenuLib.get_value("pos_watermark"))
--     end

--     do
--         local LOG_DURATION = 2.0
--         local LOG_FADE = 0.48
--         local SLIDE_IN = 36
--         local SCALE_IN = 0.98
--         local CORNER_RADIUS = 14
--         local OUTLINE_THICKNESS = 1.5
--         local ICON_SIZE = 32
--         local ICON_PAD = 18
--         local TITLE_FONT = DisplaySystem.fonts.welcome
--         local TEXT_FONT = DisplaySystem.fonts.main
--         local pad_x, pad_y = 22, 18
--         local timer_bar_height = 5
--         local timer_bar_radius = 3
--         local vw, vh = render.get_viewport_size()
--         local y = vh - 56

--         for i = #config_logs, 1, -1 do
--             local log = config_logs[i]
--             local elapsed_log = (now - log.time) / 1000
--             local alpha, slide, scale
--             if elapsed_log < LOG_FADE then
--                 local p = elapsed_log / LOG_FADE
--                 local ease = 1 - (1-p)^5
--                 alpha = math.floor(log.color[4] * ease)
--                 slide = SLIDE_IN * (1-ease)
--                 scale = SCALE_IN + (1-SCALE_IN)*ease + 0.01*math.sin(p*6.2832)
--             elseif elapsed_log > LOG_DURATION then
--                 local p = math.min((elapsed_log - LOG_DURATION) / LOG_FADE, 1)
--                 alpha = math.floor(log.color[4] * (1-p)^2)
--                 slide = 0
--                 scale = 1
--                 if p >= 1 then
--                     table.remove(config_logs, i)
--                     goto continue_configlog
--                 end
--             else
--                 alpha, slide, scale = log.color[4], 0, 1
--             end

--             local title = "SaikaidoSense"
--             local message = log.text

--             local tw_title, th_title = render.measure_text(TITLE_FONT, title)
--             local tw_msg, th_msg = render.measure_text(TEXT_FONT, message)

--             local content_w = math.max(tw_title, tw_msg)
--             local bw = ICON_PAD + ICON_SIZE + pad_x + content_w + pad_x
--             local bh = pad_y + th_title + 4 + th_msg + pad_y + timer_bar_height + 8

--             local ICON_FONT = DisplaySystem.fonts.icon
--             local bx = vw - bw * scale - 36 + slide
--             local by = y - bh * scale

--             render.draw_rectangle(bx + 6, by + 6, bw * scale, bh * scale, 0, 0, 0, alpha * 0.18, CORNER_RADIUS + 2, true)
--             render.draw_rectangle(bx, by, bw * scale, bh * scale, 18, 18, 22, alpha, CORNER_RADIUS, true)
--             render.draw_rectangle(bx, by, bw * scale, bh * scale, 60, 70, 90, alpha * 0.22, CORNER_RADIUS, false)
--             render.draw_rectangle(bx + ICON_PAD, by + pad_y, ICON_SIZE, ICON_SIZE, 40, 120, 255, alpha, ICON_SIZE/2, true)
--             render.draw_text(ICON_FONT, "S", bx + ICON_PAD + 6, by + pad_y - 2, 255, 255, 255, alpha, 1, 0, 0, 0, alpha * 0.22)
--             render.draw_text(TITLE_FONT, title, bx + ICON_PAD + ICON_SIZE + pad_x, by + pad_y, 255, 255, 255, alpha, 1, 0, 0, 0, alpha * 0.22)
--             render.draw_text(TEXT_FONT, message, bx + ICON_PAD + ICON_SIZE + pad_x, by + pad_y + th_title + 4, 200, 200, 200, alpha, 1, 0, 0, 0, alpha * 0.18)

--             if elapsed_log < LOG_DURATION then
--                 local timer_p = math.max(0, 1 - (elapsed_log / LOG_DURATION))
--                 local bar_w = (bw * scale - pad_x * 2) * timer_p
--                 local bar_x = bx + pad_x
--                 local bar_y = by + bh * scale - timer_bar_height - 8
--                 render.draw_rectangle(bar_x, bar_y, bar_w, timer_bar_height, 40, 120, 255, math.floor(alpha * 0.85), timer_bar_radius, true)
--             end

--             y = by - configlog_box_spacing - bh * (scale - 1) * 0.5
--             ::continue_configlog::
--         end
--     end

--     local watermark_active = MenuLib.get_value("watermark_enabled")
--     local watermark_visible = DisplaySystem.state._watermark_visible
--     local watermark_fading_out = DisplaySystem.state._watermark_fading_out

--     if watermark_active then
--         if not watermark_visible then
--             DisplaySystem.state._watermark_start_time = now
--             DisplaySystem.state._watermark_visible = true
--             DisplaySystem.state._watermark_fading_out = false
--         end
--     else
--         if watermark_visible and not watermark_fading_out then
--             DisplaySystem.state._watermark_fade_start_time = now
--             DisplaySystem.state._watermark_fading_out = true
--         end
--     end

--     local crosshair_active = MenuLib.get_value("crosshair_enabled")
--     local crosshair_visible = DisplaySystem.state._crosshair_visible
--     local crosshair_fading_out = DisplaySystem.state._crosshair_fading_out

--     if crosshair_active then
--         if not crosshair_visible then
--             DisplaySystem.state._crosshair_start_time = now
--             DisplaySystem.state._crosshair_visible = true
--             DisplaySystem.state._crosshair_fading_out = false
--         end
--     else
--         if crosshair_visible and not crosshair_fading_out then
--             DisplaySystem.state._crosshair_fade_start_time = now
--             DisplaySystem.state._crosshair_fading_out = true
--         end
--     end
local font = render.create_font("Tahoma", 13, 400)




local spec_font = render.create_font("Verdana", 12, 500)


-- [[ SPECTATOR SYSTEM ]]
-- [[ SPECTATOR SYSTEM ]]
local SpectatorSys = {
    list = {},
    last_update = 0
}

local function safe_get_name(controller)
    local status, name = pcall(function()
        local name_ptr = proc.read_int64(controller + offsets.m_sSanitizedPlayerName)
        if not name_ptr or name_ptr == 0 then return "Unknown" end
        return proc.read_string(name_ptr, 32)
    end)
    return (status and name and name ~= "") and name or "Spectator"
end

local function get_pawn_from_handle_ptr(entity_list, handle)
    if handle == 0 then return 0 end
    local index = handle & 0x7FFF
    local chunk = index >> 9
    local chunk_ptr = proc.read_int64(entity_list + 8 * chunk + 16)
    if chunk_ptr == 0 then return 0 end
    return proc.read_int64(chunk_ptr + 112 * (index & 0x1FF)) 
end

local function update_spectators_handle_based()
    local now = winapi.get_tickcount64()
    if now - SpectatorSys.last_update < 250 then return end
    SpectatorSys.last_update = now
    
    local temp_list = {} 
    
    if not proc.is_attached() then return end
    local client = proc.find_module("client.dll")
    if not client then return end
    
    local entity_list = proc.read_int64(client + offsets.dwEntityList)
    if entity_list == 0 then return end

    local local_controller = proc.read_int64(client + offsets.dwLocalPlayerController)
    if not local_controller or local_controller == 0 then return end

    local local_pawn_h = proc.read_int32(local_controller + offsets.m_hPawn)
    if not local_pawn_h or local_pawn_h == 0 then return end
    
    local function get_pawn_by_handle(handle)
        local index = handle & 0x7FFF
        local chunk = index >> 9
        local chunk_ptr = proc.read_int64(entity_list + 8 * chunk + 16)
        if chunk_ptr == 0 then return 0 end
        return proc.read_int64(chunk_ptr + 112 * (index & 0x1FF))
    end

    local my_pawn = get_pawn_by_handle(local_pawn_h)
    if not my_pawn or my_pawn == 0 then return end

    for i = 0, 64 do
        local list_entry = proc.read_int64(entity_list + 8 * ((i >> 9) & 0x7FFF) + 16)
        if list_entry ~= 0 then
            local controller = proc.read_int64(list_entry + 112 * (i & 0x1FF))
            
            if controller and controller ~= 0 and controller ~= local_controller then

                local pawn_h = proc.read_int32(controller + offsets.m_hPawn)

                if not pawn_h or pawn_h <= 0 or pawn_h == 0xFFFFFFFF then
                    pawn_h = proc.read_int32(controller + offsets.m_hObserverPawn)
                end

                if pawn_h and pawn_h > 0 and pawn_h ~= 0xFFFFFFFF then
                    local pawn = get_pawn_by_handle(pawn_h)
                    
                    if pawn and pawn ~= 0 then

                        local observer_svc = proc.read_int64(pawn + offsets.m_pObserverServices)
                        
                        if observer_svc ~= 0 then
                            local target_h = proc.read_int32(observer_svc + offsets.m_hObserverTarget)
                            
                            if target_h and target_h > 0 and target_h ~= 0xFFFFFFFF then
                                local target_pawn = get_pawn_by_handle(target_h)
                                
                                if target_pawn == my_pawn then
                                    local name = safe_get_name(controller)
                                    table.insert(temp_list, name)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    SpectatorSys.list = temp_list
end

local function draw_spectators()
    if not MenuLib.get_value("misc_speclist") then return end
    

    pcall(update_spectators_handle_based)

    local target_alpha = (#SpectatorSys.list > 0 or Menu.visible) and 255 or 0
    if not speclist_anim then speclist_anim = { alpha = 0 } end
    speclist_anim.alpha = math.lerp(speclist_anim.alpha, target_alpha, 0.1)
    
    if speclist_anim.alpha < 1 then return end
    local alpha = math.floor(speclist_anim.alpha)


    local count = #SpectatorSys.list
    local bw = 200
    local header_h = 32 
    local item_h = 22
    local padding = 10
    local bh = header_h + (math.max(1, count) * item_h) + (padding / 2)
    
    if not speclist_dragging then
        speclist_drag_x, speclist_drag_y = parse_pos(MenuLib.get_value("pos_speclist"))
    end
    local x, y = speclist_drag_x, speclist_drag_y

    local mx, my = input.get_mouse_position()
    local hover = mx >= x and mx <= x + bw and my >= y and my <= y + bh
    
    if Menu.visible and hover and input.is_key_pressed(1) and not speclist_dragging then
        speclist_dragging = true
        speclist_drag_offset_x = mx - x
        speclist_drag_offset_y = my - y
    end
    
    if speclist_dragging then
        if not input.is_key_down(1) then 
            speclist_dragging = false
        else
            local nx, ny = mx - speclist_drag_offset_x, my - speclist_drag_offset_y
            MenuLib.set_value("pos_speclist", string.format("%d,%d", nx, ny))
            speclist_drag_x, speclist_drag_y = nx, ny
            x, y = nx, ny
        end
    end

    local c_bg = Menu.colors.bg_dark      -- Main Menu Background
    local c_outline = Menu.colors.bg_light -- Menu Borders/Separators
    local c_text = Menu.colors.text_main   -- Main Text
    local c_dim = Menu.colors.text_dim     -- Dimmed Text
    local c_acc = Menu.colors.accent       -- Accent (for small details)

    render.draw_rectangle(x + 2, y + 2, bw, bh, 0, 0, 0, math.floor(alpha * 0.3), 6, true)

    render.draw_rectangle(x, y, bw, bh, c_bg[1], c_bg[2], c_bg[3], math.floor(alpha * 0.95), 0, true, 6)

    render.draw_rectangle(x, y, bw, bh, c_outline[1], c_outline[2], c_outline[3], alpha, 1, false, 6)
    render.draw_text(Menu.fonts.group, "Spectators", x + 12, y + 9, c_text[1], c_text[2], c_text[3], alpha, 0, 0, 0, 0, 0)
    render.draw_rectangle(x + 6, y + 10, 2, 12, c_acc[1], c_acc[2], c_acc[3], alpha, 0, true, 1)
    render.draw_line(x + 10, y + header_h - 2, x + bw - 10, y + header_h - 2, c_outline[1], c_outline[2], c_outline[3], alpha, 1)

    -- 7. The List
    local cur_y = y + header_h + 2
    if count == 0 then
        render.draw_text(Menu.fonts.main, "None", x + 14, cur_y, c_dim[1], c_dim[2], c_dim[3], alpha, 0, 0, 0, 0, 0)
    else
        for i, name in ipairs(SpectatorSys.list) do
            if #name > 24 then name = string.sub(name, 1, 22) .. ".." end
            render.draw_text(Menu.fonts.main, name, x + 14, cur_y, c_dim[1], c_dim[2], c_dim[3], alpha, 0, 0, 0, 0, 0)
            
            cur_y = cur_y + item_h
        end
    end
end

if not speclist_anim then
    speclist_anim = { visible = false, anim_progress = 0, alpha = 0, slide_offset = 0, last_tick = 0 }
end



local panel_pos_x = 25
local panel_pos_y = 200
local panel_width = 320
local panel_height = 110
local panel_rounding = 8
local panel_base_bg_alpha = 200
local animation_speed = 0.1

local font_main_name = "Verdana"
local font_main_size = 22
local font_main_weight = 700
local font_sub_name = "Verdana"
local font_sub_size = 14
local font_sub_weight = 700

local bomb_panel_font_main = render.create_font(font_main_name, font_main_size, font_main_weight)
local bomb_panel_font_sub = render.create_font(font_sub_name, font_sub_size, font_sub_weight)

local bomb_panel_alpha, bomb_panel_target_alpha = 0, 0
local bomb_panel_timer_bar_width, bomb_panel_target_bar_width = 0, 0
local bomb_panel_timer_bar_color = { r = 0, g = 255, b = 0 }
local bomb_panel_line1_text, bomb_panel_line2_text = "", ""
local bomb_panel_line1_color = { r = 255, g = 255, b = 255 }
local bomb_panel_bomb_plant_time_ms = nil
local bomb_panel_has_logged_site_id = false
local bomb_panel_client_dll = nil






-- ui_state.indicator_features_select:set(1, true) -- Rage Aimbot
-- ui_state.indicator_features_select:set(2, true) -- Legit Aimbot
-- ui_state.indicator_features_select:set(5, true) -- ESP
-- ui_state.indicator_features_select:set(6, true) -- Player Glow


local VK_NAMES = {
    [0x01]="Mouse1",[0x02]="Mouse2",[0x04]="Mouse3",[0x05]="Mouse4",[0x06]="Mouse5",[0x08]="Bsp",[0x09]="Tab",
    [0x0D]="Enter",[0x10]="Shift",[0x11]="Ctrl",[0x12]="Alt",[0x14]="Caps",[0x1B]="Esc",[0x20]="Space",
    [0x21]="PgUp",[0x22]="PgDn",[0x23]="End",[0x24]="Home",[0x25]="Left",[0x26]="Up",[0x27]="Right",[0x28]="Down",
    [0x2D]="Ins",[0x2E]="Del",[0x30]="0",[0x31]="1",[0x32]="2",[0x33]="3",[0x34]="4",[0x35]="5",[0x36]="6",
    [0x37]="7",[0x38]="8",[0x39]="9",[0x41]="A",[0x42]="B",[0x43]="C",[0x44]="D",[0x45]="E",[0x46]="F",[0x47]="G",
    [0x48]="H",[0x49]="I",[0x4A]="J",[0x4B]="K",[0x4C]="L",[0x4D]="M",[0x4E]="N",[0x4F]="O",[0x50]="P",[0x51]="Q",
    [0x52]="R",[0x53]="S",[0x54]="T",[0x55]="U",[0x56]="V",[0x57]="W",[0x58]="X",[0x59]="Y",[0x5A]="Z",
    [0x60]="Num0",[0x61]="Num1",[0x62]="Num2",[0x63]="Num3",[0x64]="Num4",[0x65]="Num5",[0x66]="Num6",
    [0x67]="Num7",[0x68]="Num8",[0x69]="Num9",[0x6A]="*",[0x6B]="+",[0x6D]="-",[0x6E]=".",[0x6F]="Num/",
    [0x70]="F1",[0x71]="F2",[0x72]="F3",[0x73]="F4",[0x74]="F5",[0x75]="F6",[0x76]="F7",[0x77]="F8",[0x78]="F9",
    [0x79]="F10",[0x7A]="F11",[0x7B]="F12",[0xBA]=";",[0xBB]="=",[0xBC]=",",[0xBD]="-",[0xBE]=".",[0xBF]="/",[0xC0]="`",
    [0xDB]="[",[0xDC]="\\",[0xDD]="]",[0xDE]="'"
}
local function get_key_name(vk) if vk and vk > 0 then return VK_NAMES[vk] or string.format("K:%d", vk) end return "NONE" end

-- local features_to_track = {
--     [1]={el=ui_state.rage_enabled,key_el=ui_state.aim_key,value_el=ui_state.fov_slider,prefix="FOV: ",suffix="",format="%.1f"},
--     [2]={el=ui_state.aim_enabled_checkbox,key_el=ui_state.aim_keybind,value_el=ui_state.aim_fov_slider,prefix="FOV: ",suffix=""},
--     [3]={el=ui_state.aa_enabled,key_el=ui_state.aim_keybind,value_el=ui_state.jitter_range,prefix="jitter: ",suffix="",format="%.1f"},
--     [4]={el=ui_state.trigger_bot_enable,key_el=ui_state.trigger_bot_key,value_el=ui_state.trigger_hitchance,prefix="HC: ",suffix="%"},
--     [5]={el=ui_state.enabledrcs,key_el=ui_state.aim_keybind,value_el=ui_state.start_bullet,prefix="Bullet: ",suffix=""},
-- }
-- for i=1, #features_to_track do features_to_track[i].anim = 0 end

local indicator_config = {
    x=15,y=520,padding=8,font=render.create_font("Verdana",13,700),
    bg={20,20,20,230},text={220,220,220,255},key_text={180,180,180,255},anim_speed=0.1
}




function handle_anti_flash()
    if not MenuLib.get_value("misc_anti_flash") then return end
    local client_dll = proc.find_module("client.dll")
    if not client_dll or client_dll == 0 then return end
    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if not local_pawn or local_pawn == 0 then return end
    local flash_address = local_pawn + offsets.m_flFlashDuration
    local current_flash_duration = proc.read_float(flash_address)
    if current_flash_duration > 0 then
        proc.write_float(flash_address, 0.0)
    end
end


local function handle_smoke_modulator()
    if not MenuLib.get_value("world_smoke_mod") then return end
    
    local client_dll = proc.find_module("client.dll")
    if not client_dll or client_dll == 0 then return end
    
    local r, g, b, _ = table.unpack(MenuLib.get_value("world_smoke_color"))
    local color_vec = vec3(r / 255.0, g / 255.0, b / 255.0)

    for i = 64, 2048 do
        local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
        if entity_list == 0 then return end

        local list_entry = proc.read_int64(entity_list + 0x8 * ((i >> 9) & 0x7F) + 0x10)
        if not list_entry or list_entry == 0 then goto continue_smoke_loop end
        
        local entity = proc.read_int64(list_entry + 112 * (i & 0x1FF))
        if not entity or entity == 0 then goto continue_smoke_loop end
        
        local item_info_ptr = proc.read_int64(entity + 0x10)
        if not item_info_ptr or item_info_ptr == 0 then goto continue_smoke_loop end

        local item_type_ptr = proc.read_int64(item_info_ptr + 0x20)
        if not item_type_ptr or item_type_ptr == 0 then goto continue_smoke_loop end
        
        local designer_name = proc.read_string(item_type_ptr, 128)

        if designer_name and designer_name == "smokegrenade_projectile" then
            local color_addr = entity + offsets.vSmokeColor
            vec3.write_float(color_addr, color_vec)
        end
        
        ::continue_smoke_loop::
    end
end



function handle_nightmode()
    local is_enabled = MenuLib.get_value("world_nightmode")



    local client_dll = proc.find_module("client.dll")
    if not client_dll or client_dll == 0 then return end
    
    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if not local_pawn or local_pawn == 0 then
        if nightmode_state.has_saved_original_values then
            nightmode_state.has_saved_original_values = false
        end
        return
    end

    local camera_services = proc.read_int64(local_pawn + offsets.m_pCameraServices)
    if not camera_services or camera_services == 0 then return end
    
    local post_processing_handle = proc.read_int32(camera_services + offsets.m_hPostProcessing)
    if not post_processing_handle or post_processing_handle == -1 then return end

    local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    local list_entry = proc.read_int64(entity_list + 0x8 * ((post_processing_handle & 0x7FFF) >> 9) + 0x10)
    if not list_entry or list_entry == 0 then return end
    local post_processing_entity = proc.read_int64(list_entry + 112 * (post_processing_handle & 0x1FF))
    if not post_processing_entity or post_processing_entity == 0 then return end

    local min_exposure_addr = post_processing_entity + offsets.m_flMinExposure
    local max_exposure_addr = post_processing_entity + offsets.m_flMaxExposure


    if is_enabled then
        if not nightmode_state.has_saved_original_values then
            nightmode_state.original_min_exposure = proc.read_float(min_exposure_addr)
            nightmode_state.original_max_exposure = proc.read_float(max_exposure_addr)
            nightmode_state.has_saved_original_values = true
        end
        
        local slider_val =  MenuLib.get_value("world_nightmode_intensity")
        local new_exposure_value = 0.1 - ((slider_val - 1.0) * 0.0010)
        
        if proc.read_float(min_exposure_addr) ~= new_exposure_value then
            proc.write_float(min_exposure_addr, new_exposure_value)
            proc.write_float(max_exposure_addr, new_exposure_value)
        end
    
    else
        if nightmode_state.has_saved_original_values then
            proc.write_float(min_exposure_addr, nightmode_state.original_min_exposure)
            proc.write_float(max_exposure_addr, nightmode_state.original_max_exposure)
            
            nightmode_state.has_saved_original_values = false
        end
    end
end



function trigger_schedule_action(ms, callback)
    table.insert(trigger_pending_actions, {
        execute_at = winapi.get_tickcount64() + ms,
        callback = callback
    })
end

function trigger_process_pending_actions()
    if #trigger_pending_actions == 0 then return end
    
    local current_time_ms = winapi.get_tickcount64()
    
    for i = #trigger_pending_actions, 1, -1 do
        local action = trigger_pending_actions[i]
        if current_time_ms >= action.execute_at then
            action.callback()
            table.remove(trigger_pending_actions, i)
        end
    end
end



function trigger_get_current_hitchance()
    local client_dll = proc.find_module("client.dll")
    if not client_dll then return 0 end
    
    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if local_pawn == 0 then return 0 end
    
    local velocity_vec = vec3.read_float(local_pawn + offsets.m_vecVelocity)
    local current_speed = velocity_vec:length_2d()

    local hitchance = math.map(current_speed, 0, 250.0, 100, 0)
    
    return math.clamp(hitchance, 0, 100)
end






local indicator_config = {
    x = 15,
    y = 520,
    padding = 8,
    font = render.create_font("Verdana", 13, 700),
    anim_speed = 0.15
}

local INDICATOR_MAPPINGS = {
    [1] = { name = "Rage Aimbot", enabled_id = "rage_enabled", keybind_id = "rage_key", anim = 0 },
    [2] = { 
        name = "Legit Aimbot", 
        per_weapon = true, 
        enabled_id = "_legit_enabled", 
        keybind_id = "_legit_key", 
        prediction_enabled_id = "_legit_prediction_enabled", 
        prediction_keybind_id = "_legit_prediction_key", 
        anim = 0 
    },
    [3] = { name = "Anti-Aim", enabled_id = "aa_enabled", keybind_id = "aa_disable_key", inverted_key = true, anim = 0 },
    [4] = { name = "Triggerbot", per_weapon = true, enabled_id = "_trigger_enabled", keybind_id = "_trigger_key", anim = 0 },
    [5] = { name = "RCS", per_weapon = true, enabled_id = "_rcs_enabled", anim = 0 }
}

local function draw_feature_indicators()
    local colors = Menu.colors
    local font = Menu.fonts.main
    if not font then return end

    local features_to_draw = {}
    local indicator_selection = MenuLib.get_value("indicator_features")

    if not indicator_selection then return end

    local weapon_category = nil
    local client_dll = proc.find_module("client.dll")
    if client_dll then
        local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
        if local_pawn and local_pawn ~= 0 then
            local weapon_id = get_active_weapon_id(local_pawn)
            weapon_category = get_weapon_category(weapon_id)
        end
    end

    for i = 1, #INDICATOR_OPTIONS do
        if indicator_selection[i] then
            local mapping = INDICATOR_MAPPINGS[i]
            if mapping then
                local is_active = false
                local display_value = "[READY]"
                local enabled_id, keybind_id = mapping.enabled_id, mapping.keybind_id
                
                if mapping.per_weapon then
                    if weapon_category then
                        enabled_id = weapon_category .. mapping.enabled_id
                        if keybind_id then keybind_id = weapon_category .. keybind_id end
                    else
                        goto continue_loop 
                    end
                end

                if MenuLib.get_value(enabled_id) then
                    is_active = keybind_id and is_keybind_active(keybind_id) or true
                    if mapping.inverted_key then is_active = not is_active end

                    if is_active then
                        display_value = "[ACTIVE]"
             
                        if mapping.name == "Legit Aimbot" and weapon_category then
                            local pred_enabled_id = weapon_category .. mapping.prediction_enabled_id
                            local pred_key_id = weapon_category .. mapping.prediction_keybind_id
                            if MenuLib.get_value(pred_enabled_id) and is_keybind_active(pred_key_id) then
                                display_value = "[PREDICTING]"
                            end
                        end
                    end
                else
                    is_active = false
                end
                
                local target = is_active and 1.0 or 0.0
                mapping.anim = math.lerp(mapping.anim or 0, target, 0.15)
                if mapping.anim < 0.01 then mapping.anim = 0 end

                if mapping.anim > 0 then
                    table.insert(features_to_draw, { name = mapping.name, value = display_value, anim = mapping.anim })
                end
            end
        end
        ::continue_loop::
    end

    if #features_to_draw == 0 then return end

    local max_name, max_val, text_h = 0, 0, 0
    for _, f in ipairs(features_to_draw) do
        local nw, h = render.measure_text(font, f.name); text_h = h
        local vw = render.measure_text(font, f.value)
        if nw > max_name then max_name = nw end
        if vw > max_val then max_val = vw end
    end
    
    local pad = 8
    local box_w = max_name + max_val + (pad * 3)
    local box_h = (#features_to_draw * text_h) + ((#features_to_draw + 1) * pad)
    
    local bg = colors.bg_dark
    render.draw_rectangle(indicator_config.x + 2, indicator_config.y + 2, box_w, box_h, 0, 0, 0, 100, 0, true, 5)
    render.draw_rectangle(indicator_config.x, indicator_config.y, box_w, box_h, bg[1], bg[2], bg[3], 230, 0, true, 4)
    
    local r, g, b, a = table.unpack(MenuLib.get_value("indicator_accent_color"))
    render.draw_gradient_rectangle(indicator_config.x, indicator_config.y, box_w, 2.5, {{r, g, b, a}, {r * 0.7, g * 0.7, b * 0.7, a}}, 4)

    local current_y = indicator_config.y + pad
    for _, f in ipairs(features_to_draw) do
        local p = f.anim
        local alpha = math.floor(255 * p)
        local slide = -20 * (1 - p)
        local main_text_color = { colors.text_main[1], colors.text_main[2], colors.text_main[3], alpha }
        local dim_text_color = { colors.text_dim[1], colors.text_dim[2], colors.text_dim[3], alpha }

        render.draw_text(font, f.name, indicator_config.x + pad + slide, current_y, main_text_color[1], main_text_color[2], main_text_color[3], main_text_color[4], 1, 0, 0, 0, alpha * 0.5)
        local val_w = render.measure_text(font, f.value)
        render.draw_text(font, f.value, indicator_config.x + box_w - pad - val_w, current_y, dim_text_color[1], dim_text_color[2], dim_text_color[3], dim_text_color[4], 1, 0, 0, 0, alpha * 0.5)
        
        current_y = current_y + text_h + pad
    end
end

-- local _chams_needs_reset = true
local _reset_timer = 0
local _script_load_time = winapi.get_tickcount64()


-- function UpdateChams(entity_ptr, color, bool)
--     if not entity_ptr or entity_ptr == 0 then return end

--     local m_bGunGameImmunity = 0x3D94
--     local m_flImmuneToGunGameDamageTime = 0x3D90
--     local m_GunGameImmunityColor = 0x2480
    

--     if (winapi.get_tickcount64() - _script_load_time) < 1000 then
--         proc.write_int8(entity_ptr + m_bGunGameImmunity, 0)
--         return
--     end

--     if bool then
--         if color then
--             local r, g, b, a = table.unpack(color)

--             proc.write_int8(entity_ptr + m_GunGameImmunityColor + 0, math.floor(r))
--             proc.write_int8(entity_ptr + m_GunGameImmunityColor + 1, math.floor(g))
--             proc.write_int8(entity_ptr + m_GunGameImmunityColor + 2, math.floor(b))
--             proc.write_int8(entity_ptr + m_GunGameImmunityColor + 3, 255) 
--         end

--         proc.write_int8(entity_ptr + m_bGunGameImmunity, 1) 
        

--         proc.write_float(entity_ptr + m_flImmuneToGunGameDamageTime, 4500000.0) 
--     else
--         proc.write_int8(entity_ptr + m_bGunGameImmunity, 0) 
--     end
-- end




local function draw_oof_arrow(local_yaw, target_pos, local_pos)
    local radius = MenuLib.get_value("esp_oof_radius") or 300
    local size = MenuLib.get_value("esp_oof_size") or 15
    local base_col = MenuLib.get_value("esp_oof_color") or {255, 50, 50, 200}
    
    local time = winapi.get_tickcount64() / 1000
    local pulse = (math.sin(time * 5) + 1) * 0.5 
    local alpha_pulse = math.floor(base_col[4] * (0.6 + (0.4 * pulse)))

    local sw, sh = render.get_viewport_size()
    local cx, cy = sw / 2, sh / 2

    local dx = target_pos.x - local_pos.x
    local dy = target_pos.y - local_pos.y
    
    local target_yaw = math.deg(math.atan(dy, dx))

    local yaw_diff = local_yaw - target_yaw 

    local rad = math.rad(yaw_diff - 90) 

    local ax = cx + math.cos(rad) * radius
    local ay = cy + math.sin(rad) * radius

    local width = size * 0.8
    local height = size
    local indent = size * 0.4 

    local raw_points = {
        {0, -height},         -- Tip
        {width, height},      -- Right Wing
        {0, height - indent}, -- Center Notch
        {-width, height}      -- Left Wing
    }

    local cos_r = math.cos(rad + math.pi/2) 
    local sin_r = math.sin(rad + math.pi/2)

    local function rotate_and_translate(px, py)
        return {
            x = ax + (px * cos_r - py * sin_r),
            y = ay + (px * sin_r + py * cos_r)
        }
    end

    local p1 = rotate_and_translate(raw_points[1][1], raw_points[1][2])
    local p2 = rotate_and_translate(raw_points[2][1], raw_points[2][2])
    local p3 = rotate_and_translate(raw_points[3][1], raw_points[3][2])
    local p4 = rotate_and_translate(raw_points[4][1], raw_points[4][2])

    local glow_layers = 3
    for i = glow_layers, 1, -1 do
        local expand = i * 2
        local glow_alpha = math.floor(alpha_pulse / (i * 2.5))
        
        render.draw_polygon(
            {p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y},
            base_col[1], base_col[2], base_col[3], glow_alpha, 
            expand,
            false 
        )
    end

    render.draw_polygon(
        {p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y},
        base_col[1], base_col[2], base_col[3], alpha_pulse, 
        0, 
        true 
    )
    
    render.draw_polygon(
        {p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y},
        255, 255, 255, math.floor(alpha_pulse * 0.8), 
        1, 
        false
    )
end


local function draw_dynamic_hitmarker()
    if not MenuLib.get_value("misc_hitmarker") then return end
    
    if not hitmarker or hitmarker.alpha <= 0 then return end

    hitmarker.alpha = math.lerp(hitmarker.alpha, 0, 0.05)

    local sw, sh = render.get_viewport_size()
    local cx, cy = sw / 2, sh / 2
    local size = 6
    local gap = 5
    
    local col = MenuLib.get_value("misc_hitmarker_color") or {255, 255, 255, 255}
    local r, g, b = col[1], col[2], col[3]
    local a = math.floor(hitmarker.alpha)

    render.draw_line(cx - gap, cy - gap, cx - gap - size, cy - gap - size, r, g, b, a, 1.5)
    render.draw_line(cx + gap, cy - gap, cx + gap + size, cy - gap - size, r, g, b, a, 1.5)
    render.draw_line(cx - gap, cy + gap, cx - gap - size, cy + gap + size, r, g, b, a, 1.5)
    render.draw_line(cx + gap, cy + gap, cx + gap + size, cy + gap + size, r, g, b, a, 1.5)
end


local function draw_general_crosshair(game)
    if not MenuLib.get_value("crosshair_enabled") then return end

    if game and game.local_pawn and game.local_pawn ~= 0 then
        local is_scoped = proc.read_int8(game.local_pawn + offsets.m_bIsScoped) > 0
        if is_scoped then return end


        local weapon_id = get_active_weapon_id(game.local_pawn, game.entity_list)
        local weapon_cat = get_weapon_category(weapon_id)
        
        if weapon_cat == "legit_sniper" then 
            return 
        end
    end

    local col = MenuLib.get_value("crosshair_color") or {0, 255, 0, 255}
    local outline_enabled = MenuLib.get_value("crosshair_outline")
    local dot_enabled = MenuLib.get_value("crosshair_dot")
    local t_style = MenuLib.get_value("crosshair_tstyle")
    
    local size = MenuLib.get_value("crosshair_size") or 6
    local thickness = MenuLib.get_value("crosshair_thickness") or 2
    local gap = MenuLib.get_value("crosshair_gap") or 3

    local sw, sh = render.get_viewport_size()
    local cx, cy = math.floor(sw / 2), math.floor(sh / 2)

    local r, g, b, a = col[1], col[2], col[3], col[4]

    local function draw_bar(x, y, w, h)
        if outline_enabled then
            render.draw_rectangle(x - 1, y - 1, w + 2, h + 2, 0, 0, 0, 255, 0, true) -- Black bg
        end
        render.draw_rectangle(x, y, w, h, r, g, b, a, 0, true) -- Colored fg
    end

    if dot_enabled then
        local dot_size = thickness
        local dx = cx - math.floor(dot_size / 2)
        local dy = cy - math.floor(dot_size / 2)
        draw_bar(dx, dy, dot_size, dot_size)
    end

    local thick_offset = math.floor(thickness / 2)
    
    draw_bar(cx - gap - size, cy - thick_offset, size, thickness)
    draw_bar(cx + gap, cy - thick_offset, size, thickness)
    draw_bar(cx - thick_offset, cy + gap, thickness, size)
    if not t_style then
        draw_bar(cx - thick_offset, cy - gap - size, thickness, size)
    end
end

local hitmarker = { alpha = 0, last_hit_time = 0 }


local VelGraph = {
    history = {},
    max_history = 60,
    w = 200, h = 60
}

function DrawVelocityGraph(local_pawn)
    if not MenuLib.get_value("misc_bhop") then return end 
    if not local_pawn or local_pawn == 0 then return end

    local vel = vec3.read_float(local_pawn + offsets.m_vecVelocity)
    local speed = math.sqrt(vel.x^2 + vel.y^2) -- 2D speed

    table.insert(VelGraph.history, speed)
    if #VelGraph.history > VelGraph.max_history then
        table.remove(VelGraph.history, 1)
    end

    local sw, sh = render.get_viewport_size()
    local x = sw / 2 - VelGraph.w / 2
    local y = sh - 150 

    -- Draw Background
    render.draw_rectangle(x, y, VelGraph.w, VelGraph.h, 20, 20, 20, 150, 0, true, 4)
    render.draw_rectangle(x, y, VelGraph.w, VelGraph.h, 60, 60, 60, 200, 1, false, 4)

    local max_speed = 320
    local step = VelGraph.w / VelGraph.max_history

    for i = 1, #VelGraph.history - 1 do
        local s1 = math.min(VelGraph.history[i], max_speed)
        local s2 = math.min(VelGraph.history[i+1], max_speed)

        local h1 = (s1 / max_speed) * VelGraph.h
        local h2 = (s2 / max_speed) * VelGraph.h

        local cur_x = x + (i * step)
        local next_x = x + ((i + 1) * step)
        
        -- Color turns red if > 250 (running speed)
        local r, g = 255, 255
        if s1 > 250 then r=0; g=255 else r=255; g=math.floor((s1/250)*255) end

        render.draw_line(cur_x, y + VelGraph.h - h1, next_x, y + VelGraph.h - h2, r, g, 0, 255, 2)
    end

    local txt = string.format("%d u/s", math.floor(speed))
    local tw, th = render.measure_text(Menu.fonts.group, txt)
    render.draw_text(Menu.fonts.group, txt, x + VelGraph.w/2 - tw/2, y - 15, 255, 255, 255, 255, 1, 0,0,0,150)
end






local EntityCache = {
    players = {},
    local_player = nil,
    mutex = false
}

local function UpdateEntityCache(game_ctx)
    EntityCache.players = {}
    
    if not game_ctx.entity_list or game_ctx.entity_list == 0 then return end
    
    EntityCache.local_player = {
        pawn = game_ctx.local_pawn,
        team = game_ctx.local_team,
        origin = nil 
    }

    local local_origin_node = proc.read_int64(game_ctx.local_pawn + offsets.m_pGameSceneNode)
    if local_origin_node and local_origin_node ~= 0 then
        EntityCache.local_player.origin = vec3.read_float(local_origin_node + offsets.m_vecAbsOrigin)
    end

    for i = 1, 64 do
        local list_entry = proc.read_int64(game_ctx.entity_list + 0x8 * ((i & 0x7FFF) >> 9) + 16)
        if list_entry and list_entry ~= 0 then
            local controller = proc.read_int64(list_entry + 112 * (i & 0x1FF))
            if controller and controller ~= 0 then
                local pawn_h = proc.read_int32(controller + offsets.m_hPlayerPawn)
                if pawn_h and pawn_h > 0 then
                    local list_entry2 = proc.read_int64(game_ctx.entity_list + 0x8 * ((pawn_h & 0x7FFF) >> 9) + 16)
                    local pawn = proc.read_int64(list_entry2 + 112 * (pawn_h & 0x1FF))
                    
                    if pawn and pawn ~= 0 and pawn ~= game_ctx.local_pawn then
                        local life = proc.read_int32(pawn + offsets.m_lifeState)
                        if life == 256 then -- Alive
                            local team = proc.read_int32(pawn + offsets.m_iTeamNum)
                            local hp = proc.read_int32(pawn + offsets.m_iHealth)
                            
                            if hp > 0 then
                                table.insert(EntityCache.players, {
                                    index = i,
                                    controller = controller,
                                    pawn = pawn,
                                    team = team,
                                    health = hp,
                                    dormant = proc.read_int32(pawn + offsets.m_bDormant),
                                    is_enemy = (team ~= game_ctx.local_team)
                                })
                            end
                        end
                    end
                end
            end
        end
    end
end




local debug_c4_timer = 0
local function debug_log(msg)
    local now = winapi.get_tickcount64()
    if now - debug_c4_timer > 2000 then 
        engine.log("[C4 DBG] " .. msg, 255, 255, 0, 255)
        debug_c4_timer = now
    end
end


local planted_bomb_state = { last_entity = 0, last_pos = nil, last_blow_time = 0, last_server_time = 0 }

local function is_valid_number(n)
    return n and n == n and n ~= math.huge and n ~= -math.huge
end

local function get_server_time(client_dll)
    local gvars_ptr = proc.read_int64(client_dll + offsets.dwGlobalVars)
    if gvars_ptr and gvars_ptr ~= 0 then
        local t = proc.read_float(gvars_ptr + 0x2C)
        if t and t > 10 then return t end
    end
    
    local local_controller = proc.read_int64(client_dll + offsets.dwLocalPlayerController)
    if local_controller and local_controller ~= 0 then
        local tick_base = proc.read_int32(local_controller + offsets.m_nTickBase)
        if tick_base and tick_base > 0 then
            return tick_base * 0.015625
        end
    end
    return 0
end

local function get_planted_bomb_info(client_dll)
    local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    if not entity_list or entity_list == 0 then return nil end

    local c4_address = 0
    local valid_c4 = false


    for i = 64, 1024 do 
        local chunk = i >> 9
        local chunk_ptr = proc.read_int64(entity_list + 8 * chunk + 16)
        if chunk_ptr ~= 0 then
            local ent = proc.read_int64(chunk_ptr + 112 * (i & 0x1FF))
            if ent and ent ~= 0 then

                local length = proc.read_float(ent + offsets.m_flTimerLength)
                
                if length > 29 and length < 61 then
                     local ticking = proc.read_int8(ent + offsets.m_bBombTicking)
                     local defused = proc.read_int8(ent + offsets.m_bBombDefused)
                     local blow = proc.read_float(ent + offsets.m_flC4Blow)

                     if (ticking == 1 or defused == 1) and blow > 0 then
                        c4_address = ent
                        valid_c4 = true
                        break
                     end
                end
            end
        end
    end

    if not valid_c4 then return nil end
    
    local server_time = get_server_time(client_dll)
    local blow_time = proc.read_float(c4_address + offsets.m_flC4Blow)
    local timer_length = proc.read_float(c4_address + offsets.m_flTimerLength)
    local defused = proc.read_int8(c4_address + offsets.m_bBombDefused)

    if defused == 1 then
        return { active = true, is_defused = true, time_left = 0, max_time = 1 } 
    end

    if server_time == 0 or blow_time == 0 then return nil end

    local time_left = blow_time - server_time

    if time_left > 100 or time_left < -2 then return nil end

    if not timer_length or timer_length <= 0 then timer_length = 40.0 end

    local is_defusing = proc.read_int8(c4_address + offsets.m_bBeingDefused) == 1
    local defuse_left = 0
    local defuse_max = 0

    if is_defusing then
        defuse_max = proc.read_float(c4_address + offsets.m_flDefuseLength)
        if defuse_max <= 0 then defuse_max = 10.0 end

        local defuse_end = proc.read_float(c4_address + offsets.m_flDefuseCountDown)
        if defuse_end > 0 then
            defuse_left = defuse_end - server_time
        end
    end

    local game_scene = proc.read_int64(c4_address + offsets.m_pGameSceneNode)
    local pos = {x=0, y=0, z=0}
    if game_scene ~= 0 then
        pos = vec3.read_float(game_scene + offsets.m_vecAbsOrigin)
    end
    
    local is_round_change = false
    if planted_bomb_state.last_pos and planted_bomb_state.last_entity == c4_address then
        local dx = pos.x - planted_bomb_state.last_pos.x
        local dy = pos.y - planted_bomb_state.last_pos.y
        if (dx*dx + dy*dy) > 250000 then is_round_change = true end 
    end

    if is_round_change then
        planted_bomb_state = { last_entity = 0, last_pos = nil, last_blow_time = 0, last_server_time = 0 }
        return nil
    end

    planted_bomb_state.last_entity = c4_address
    planted_bomb_state.last_pos = pos
    planted_bomb_state.last_blow_time = blow_time
    planted_bomb_state.last_server_time = server_time

    local site_id = proc.read_int32(c4_address + offsets.m_nBombSite)

    return {
        active = true,
        is_defused = false,
        site = (site_id == 1) and "B" or "A",
        time_left = math.max(0, time_left),
        max_time = timer_length,
        is_defusing = is_defusing,
        defuse_left = math.max(0, defuse_left),
        defuse_max = defuse_max,
        can_defuse = is_defusing and (defuse_left < time_left)
    }
end

function handle_c4data()
    if not MenuLib.get_value("misc_c4timer") then return end

    local client = proc.find_module("client.dll")
    if not client then return end
    
    local c4 = get_planted_bomb_info(client) 


    if (not c4 or not c4.active) and Menu.visible then
        c4 = {
            active = true,
            is_defused = false,
            site = "A",
            time_left = 32.5,     
            max_time = 40.0,
            is_defusing = true,  
            defuse_left = 4.5,
            defuse_max = 10.0,
            can_defuse = true,
            error = false
        }
    end
    
    if not c4 or not c4.active then return end
    
    if not Menu.visible and c4.is_defused and c4.time_left <= 0 then return end 


    if not bombpanel_dragging then
        bombpanel_drag_x, bombpanel_drag_y = parse_pos(MenuLib.get_value("pos_bomb"))
    end
    local bx, by = bombpanel_drag_x, bombpanel_drag_y
    local bw, bh = 220, 75

    local mx, my = input.get_mouse_position()
    

    if Menu.visible and input.is_key_pressed(1) and mx>=bx and mx<=bx+bw and my>=by and my<=by+bh and not bombpanel_dragging then
        bombpanel_dragging = true; bombpanel_drag_offset_x = mx - bx; bombpanel_drag_offset_y = my - by
    end
    if bombpanel_dragging then
        if not input.is_key_down(1) then bombpanel_dragging = false
        else 
            local nx,ny = mx - bombpanel_drag_offset_x, my - bombpanel_drag_offset_y
            MenuLib.set_value("pos_bomb", string.format("%d,%d", nx, ny))
            bx, by = nx, ny
        end
    end


    local c_bg = Menu.colors.bg_dark or {22, 23, 27}
    local c_out = Menu.colors.bg_light or {60, 60, 70}
    

    render.draw_rectangle(bx, by, bw, bh, c_bg[1], c_bg[2], c_bg[3], 240, 0, true, 6)
    render.draw_rectangle(bx, by, bw, bh, c_out[1], c_out[2], c_out[3], 255, 1, false, 6)
    
    local icon_col = {255, 50, 50}
    if c4.is_defusing then icon_col = c4.can_defuse and {100, 255, 100} or {255, 255, 100} end
    if c4.is_defused then icon_col = {0, 255, 0} end

    local title_txt = c4.is_defused and "Bomb Defused" or ("Planted - Site " .. c4.site)
    if c4.error then title_txt = "SYNC ERROR" end


    render.draw_circle(bx + 15, by + 15, 5, icon_col[1], icon_col[2], icon_col[3], 255, 0, true)
    

    render.draw_text(Menu.fonts.group, title_txt, bx + 28, by + 8, 255, 255, 255, 255, 0,0,0,0,0)

    if not c4.is_defused and not c4.error then

        local time_str = string.format("%.1fs", c4.time_left)
        local tw = render.measure_text(Menu.fonts.group, time_str)
        render.draw_text(Menu.fonts.group, time_str, bx + bw - tw - 12, by + 8, 255, 255, 255, 255, 0,0,0,0,0)


        local bar_x = bx + 12; local bar_y = by + 30; local bar_w = bw - 24; local bar_h = 6
        local pct = math.clamp(c4.time_left / c4.max_time, 0, 1)
        render.draw_rectangle(bar_x, bar_y, bar_w, bar_h, 40, 40, 45, 255, 0, true, 3)
        render.draw_rectangle(bar_x, bar_y, bar_w * pct, bar_h, icon_col[1], icon_col[2], icon_col[3], 255, 0, true, 3)
        

        if c4.is_defusing then
            local def_txt = c4.can_defuse and ("Defusing: " .. string.format("%.1f", c4.defuse_left) .. "s") or "NO TIME!"
            local d_col = c4.can_defuse and {150, 255, 150} or {255, 100, 100}
            render.draw_text(Menu.fonts.main, def_txt, bx + 12, by + 42, d_col[1], d_col[2], d_col[3], 255, 0,0,0,0,0)
            
            local dpct = math.clamp(1 - (c4.defuse_left / c4.defuse_max), 0, 1)
            render.draw_rectangle(bar_x, by+58, bar_w, bar_h, 40, 40, 45, 255, 0, true, 3)
            render.draw_rectangle(bar_x, by+58, bar_w * dpct, bar_h, d_col[1], d_col[2], d_col[3], 255, 0, true, 3)
        end
    end
end
local function draw_cham_segment(p1, p2, radius, r, g, b, a, outline_r, outline_g, outline_b, outline_a)
    local dx = p2.x - p1.x
    local dy = p2.y - p1.y
    local len = math.sqrt(dx*dx + dy*dy)

    if len <= 0 then return end

    local nx = -dy / len
    local ny = dx / len

    local outline_radius = radius + 2.0 
    local ox_o = nx * outline_radius
    local oy_o = ny * outline_radius

    local points_outline = {
        p1.x + ox_o, p1.y + oy_o,
        p2.x + ox_o, p2.y + oy_o,
        p2.x - ox_o, p2.y - oy_o,
        p1.x - ox_o, p1.y - oy_o
    }
    
    render.draw_polygon(points_outline, outline_r, outline_g, outline_b, outline_a, 0, true)
    render.draw_circle(p1.x, p1.y, outline_radius, outline_r, outline_g, outline_b, outline_a, 0, true)
    render.draw_circle(p2.x, p2.y, outline_radius, outline_r, outline_g, outline_b, outline_a, 0, true)

    local ox = nx * radius
    local oy = ny * radius

    local points_fill = {
        p1.x + ox, p1.y + oy,
        p2.x + ox, p2.y + oy,
        p2.x - ox, p2.y - oy,
        p1.x - ox, p1.y - oy
    }

    render.draw_polygon(points_fill, r, g, b, a, 0, true)
    render.draw_circle(p1.x, p1.y, radius, r, g, b, a, 0, true)
    render.draw_circle(p2.x, p2.y, radius, r, g, b, a, 0, true)
end

function draw_external_chams_body(bones_2d, scale, fill_color, outline_color)
    local r, g, b, a = table.unpack(fill_color)
    local or_, og, ob, oa = table.unpack(outline_color)

    local base = 5.5 * scale 

    local connections = {
        {"pelvis",  "spine_1", 3.8}, 
        {"spine_1", "spine_2", 4.0}, 
        {"spine_2", "spine_3", 4.2}, 
        {"spine_3", "neck",    3.0}, 
        {"neck",    "head",    3.5},
        {"spine_3", "clavicle_L", 2.5}, {"spine_3", "clavicle_R", 2.5},
        {"clavicle_L", "arm_upper_L", 2.2}, {"arm_upper_L", "arm_lower_L", 1.9}, {"arm_lower_L", "hand_L", 1.6},
        {"clavicle_R", "arm_upper_R", 2.2}, {"arm_upper_R", "arm_lower_R", 1.9}, {"arm_lower_R", "hand_R", 1.6},
        {"pelvis", "leg_upper_L", 3.2}, {"leg_upper_L", "leg_lower_L", 2.6}, {"leg_lower_L", "ankle_L", 2.0},
        {"pelvis", "leg_upper_R", 3.2}, {"leg_upper_R", "leg_lower_R", 2.6}, {"leg_lower_R", "ankle_R", 2.0},
    }

    for _, bond in ipairs(connections) do
        local p1 = bones_2d[bond[1]]
        local p2 = bones_2d[bond[2]]
        if p1 and p2 then
            draw_cham_segment(p1, p2, base * bond[3], r, g, b, a, or_, og, ob, oa)
        end
    end
end


local MapParser = require("polys.mapparser")

local _vis_cache = {} 
local _last_cache_clear = 0

local _RT_DBG = { acc = 0, calls = 0, last_log = 0 }
local _SKEL_IDS = {
    {"head", "neck_0"}, {"neck_0", "spine_1"}, {"spine_1", "spine_2"}, {"spine_2", "pelvis"},
    {"neck_0", "arm_upper_L"}, {"arm_upper_L", "arm_lower_L"}, {"arm_lower_L", "hand_L"},
    {"neck_0", "arm_upper_R"}, {"arm_upper_R", "arm_lower_R"}, {"arm_lower_R", "hand_R"},
    {"pelvis", "leg_upper_L"}, {"leg_upper_L", "leg_lower_L"}, {"leg_lower_L", "ankle_L"},
    {"pelvis", "leg_upper_R"}, {"leg_upper_R", "leg_lower_R"}, {"leg_lower_R", "ankle_R"}
}

local function _c(tbl, idx)
    if type(tbl) ~= "table" then return (idx == 4 and 255 or 0) end
    return tbl[idx] or 255
end

function draw_skeleton(bones_2d, col_hidden, bones_3d, local_eye, col_visible, ent_index)
    local t0 = winapi.get_tickcount64()

    if not bones_2d then return end

    if not col_hidden then col_hidden = {255, 0, 0, 255} end
    local safe_col_vis = col_visible
    if not safe_col_vis then safe_col_vis = {0, 255, 0, 255} end 

    -- SAFETY FIX: Ensure ent_index exists. Use 999999 for preview/dummy entities.
    if not ent_index then ent_index = 999999 end

    local do_trace = false
    if bones_3d and local_eye and MapParser and MapParser.is_visible then
        do_trace = true
    end

    if not _vis_cache then _vis_cache = {} end
    
    if (t0 - (_last_cache_clear or 0)) > 2000 then 
        _vis_cache = {}
        _last_cache_clear = t0 
    end

    if not _vis_cache[ent_index] then _vis_cache[ent_index] = {} end

    local function is_vis(bone)
        if not do_trace or not bones_3d[bone] then return false end
        if local_eye.x == 0 and local_eye.y == 0 then return false end

        local entry = _vis_cache[ent_index][bone]
        if entry and (t0 - entry.time < 50) then return entry.visible end

        local res = MapParser.is_visible(local_eye, bones_3d[bone])
        _vis_cache[ent_index][bone] = { time = t0, visible = res }
        return res
    end

    for _, bond in ipairs(_SKEL_IDS) do
        local b1, b2 = bond[1], bond[2]
        local p1, p2 = bones_2d[b1], bones_2d[b2]
        
        if p1 and p2 then
            if do_trace then
                local v1 = is_vis(b1)
                local v2 = is_vis(b2)
                
                local c1 = v1 and safe_col_vis or col_hidden
                local c2 = v2 and safe_col_vis or col_hidden
                
                if v1 == v2 then
                    render.draw_line(p1.x, p1.y, p2.x, p2.y, _c(c1,1), _c(c1,2), _c(c1,3), _c(c1,4), 1)
                else
                    local mx, my = (p1.x + p2.x) * 0.5, (p1.y + p2.y) * 0.5
                    render.draw_line(p1.x, p1.y, mx, my, _c(c1,1), _c(c1,2), _c(c1,3), _c(c1,4), 1)
                    render.draw_line(mx, my, p2.x, p2.y, _c(c2,1), _c(c2,2), _c(c2,3), _c(c2,4), 1)
                end
            else
                render.draw_line(p1.x, p1.y, p2.x, p2.y, _c(col_hidden,1), _c(col_hidden,2), _c(col_hidden,3), _c(col_hidden,4), 1)
            end
        end
    end
    
    local t1 = winapi.get_tickcount64()
    _RT_DBG.acc = _RT_DBG.acc + (t1 - t0)
    _RT_DBG.calls = _RT_DBG.calls + 1
end

function get_current_map_name()
    local client_dll = proc.find_module("client.dll")
    if not client_dll or client_dll == 0 then return nil end

    local global_vars = proc.read_int64(client_dll + offsets.dwGlobalVars)
    if not global_vars or global_vars == 0 then return nil end

    local map_ptr = proc.read_int64(global_vars + 0x180)
    
    if not map_ptr or map_ptr == 0 then
        map_ptr = proc.read_int64(global_vars + 0x180)
    end

    if map_ptr and map_ptr > 0 then
        local map_path = proc.read_string(map_ptr, 128)
        if map_path and map_path ~= "" then 
            return map_path 
        end
    end

    return nil
end


function draw_snaplines(rect)
    if not MenuLib.get_value("esp_snaplines") then return end

    local sw, sh = render.get_viewport_size()
    local bottom_x, bottom_y = sw / 2, sh

    -- Calculate bottom center of the player box
    local player_x = rect.left + (rect.right - rect.left) / 2
    local player_y = rect.bottom

    -- Draw line (White with slight transparency)
    render.draw_line(bottom_x, bottom_y, player_x, player_y, 255, 255, 255, 180, 1)
end





MainGameLoop = function()
    if not IsCS2Active() then return end
    if not proc.is_attached() or proc.did_exit() then return end

    local client_dll = proc.find_module("client.dll")
    if client_dll == 0 then return end

    local raw_map_path = get_current_map_name()
    if raw_map_path then
local clean_name = raw_map_path:gsub("maps[/\\]", ""):gsub("%.vpk", ""):match("^%s*(.-)%s*$")
        if _G.last_loaded_map ~= clean_name then
            local MapParser = require("polys.mapparser")
            MapParser.load_map(clean_name)
            _G.last_loaded_map = clean_name
        end
    end

    -- [[ 2. SETUP MATRIX & LOCAL PLAYER ]]
    local view_matrix = {}
    for i = 0, 15 do table.insert(view_matrix, proc.read_float(client_dll + offsets.dwViewMatrix + (i * 4))) end
    local local_player_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if local_player_pawn == 0 then return end
    local local_team = proc.read_int32(local_player_pawn + offsets.m_iTeamNum)
    local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    if entity_list == 0 then return end

    -- [[ 3. CALCULATE LOCAL EYE POSITION (Required for Trace) ]]
    local local_eye = {x=0, y=0, z=0}
    local local_node = proc.read_int64(local_player_pawn + offsets.m_pGameSceneNode)
    if local_node ~= 0 then
        local origin = vec3.read_float(local_node + offsets.m_vecAbsOrigin)
        local view_off = vec3.read_float(local_player_pawn + offsets.m_vecViewOffset)
        
        -- Fallback if ViewOffset is 0 (prevents floor trace)
       local z_off = view_off.z
if z_off == 0 then z_off = 64 end -- Force height if memory read fails
local_eye = {x = origin.x + view_off.x, y = origin.y + view_off.y, z = origin.z + z_off}
    end
    local game = { local_pawn = local_player_pawn, local_team = local_team, view_matrix = view_matrix, entity_list = entity_list, entities = {} }
    local weapon_id = get_active_weapon_id(game.local_pawn, game.entity_list)
    local weapon_category = get_weapon_category(weapon_id)

    -- [[ 4. ENTITY LOOP ]]
    local list_entry_head = proc.read_int64(entity_list + 0x10)
    if list_entry_head ~= 0 then
        for i = 1, 64 do
            local entity_controller = proc.read_int64(list_entry_head + 112 * (i & 0x1FF))
            if entity_controller == 0 then goto skip_ent end
            
            local pawn_handle = proc.read_int32(entity_controller + offsets.m_hPlayerPawn)
            if pawn_handle <= 0 then goto skip_ent end
            local list_entry2 = proc.read_int64(entity_list + 0x8 * ((pawn_handle & 0x7FFF) >> 9) + 16)
            if list_entry2 == 0 then goto skip_ent end
            local pawn_addr = proc.read_int64(list_entry2 + 112 * (pawn_handle & 0x1FF))
            if pawn_addr == 0 or pawn_addr == local_player_pawn then goto skip_ent end
            if proc.read_int32(pawn_addr + offsets.m_lifeState) ~= 256 then goto skip_ent end

 local entity = { 
                pawn_address = pawn_addr, 
                team = proc.read_int32(pawn_addr + offsets.m_iTeamNum), 
                bones = {}, 
                index = i, 
                pawn_index = pawn_handle_masked, 
                health = proc.read_int32(pawn_addr + offsets.m_iHealth) -- Cache health while we are here
            }
            local game_scene_node = proc.read_int64(pawn_addr + offsets.m_pGameSceneNode)

if game_scene_node ~= 0 then
    local bone_array_ptr = proc.read_int64(game_scene_node + offsets.m_modelState + offsets.m_boneArray)
    if bone_array_ptr ~= 0 then
        
        for name, index in pairs(BONE_MAP) do 
            entity.bones[name] = vec3.read_float(bone_array_ptr + index * 32) 
        end
                    local health = proc.read_int32(pawn_addr + offsets.m_iHealth)
                    local is_enemy = (entity.team ~= local_team)
                    local prefix = is_enemy and "esp" or "team"
                    local should_draw = (is_enemy and MenuLib.get_value("esp_enabled")) or (not is_enemy and MenuLib.get_value("team_esp_enabled"))

                    if should_draw and health > 0 then
                        -- Standard Visuals (Chams, OOF, etc.)
                        if is_enemy and MenuLib.get_value("esp_oof_arrows") then
                            local entity_pos = vec3.read_float(game_scene_node + offsets.m_vecAbsOrigin)
                            local scr = world_to_screen(view_matrix, entity_pos)
                            local scr_w, scr_h = render.get_viewport_size()
                            if not scr or scr.x < 0 or scr.x > scr_w or scr.y < 0 or scr.y > scr_h then
                                 local va = vec3.read_float(client_dll + offsets.dwViewAngles)
                                 draw_oof_arrow(va.y, entity_pos, vec3(local_eye.x, local_eye.y, local_eye.z))
                            end
                        end
                       

                        local head_top = {x=entity.bones.head.x, y=entity.bones.head.y, z=entity.bones.head.z + 12}
                        local origin = vec3.read_float(game_scene_node + offsets.m_vecAbsOrigin)
                        local feet_pos = {x=origin.x, y=origin.y, z=origin.z - 3}
                        local s_head = world_to_screen(view_matrix, head_top)
                        local s_feet = world_to_screen(view_matrix, feet_pos)
                        
                        if s_head and s_feet then
                            local h_box = math.abs(s_head.y - s_feet.y)
                            local w_box = h_box * 0.55
                            local cx = (s_head.x + s_feet.x) / 2
                            
                           local money_val = 0
local money_svc = proc.read_int64(entity_controller + offsets.m_pInGameMoneyServices)
if money_svc and money_svc ~= 0 then
    money_val = proc.read_int32(money_svc + offsets.m_iAccount)
end

local ent_info = {
    health = health, 
    team = entity.team,
    is_scoped = proc.read_int8(pawn_addr + offsets.m_bIsScoped) > 0,
    is_flashed = proc.read_float(pawn_addr + offsets.m_flFlashDuration) > 0,
    distance = get_distance_manual(origin, local_eye) / 39.37,
    armor = proc.read_int32(pawn_addr + offsets.m_ArmorValue),
    weapon = get_active_weapon_name(pawn_addr),
    rect = {top=s_head.y, bottom=s_feet.y, left=cx-w_box/2, right=cx+w_box/2},
    name = proc.read_string(proc.read_int64(entity_controller + offsets.m_sSanitizedPlayerName), 64),
    has_c4 = (_G.C4_Carrier_Handle ~= 0 and pawn_handle == _G.C4_Carrier_Handle),
    money = money_val
}
render_entity_info(ent_info, prefix)


                         if is_enemy then 
                                draw_snaplines(ent_info.rect) 
                            end
local skeleton_mode = MenuLib.get_value(prefix .. "_skeleton_mode")
if skeleton_mode > 1 then
    local bones_2d = {}
    for n, _ in pairs(BONE_MAP) do 
        if entity.bones[n] then 
            bones_2d[n] = world_to_screen(game.view_matrix, entity.bones[n]) 
        end 
    end
    
    local col_hid = MenuLib.get_value(prefix .. "_skeleton_color")
    local col_vis = MenuLib.get_value(prefix .. "_skeleton_color_vis")

    if skeleton_mode == 2 then 
        draw_skeleton(bones_2d, col_hid, entity.bones, local_eye, col_vis, entity.index)
    elseif skeleton_mode == 3 then 
        draw_circular_skeleton(bones_2d, 1.0, col_hid)
    elseif skeleton_mode == 4 then 
        if prefix == "esp" then
            draw_capsule_skeleton(bones_2d, math.max(0.1, h_box/300), col_hid) 
        else
                            draw_neon_skeleton(bones_2d, col_hid, h_box, bones_3d, local_eye, col_vis, i)
        end
    elseif skeleton_mode == 5 and prefix == "esp" then 
                            draw_neon_skeleton(bones_2d, col_hid, h_box, bones_3d, local_eye, col_vis, i)

    end
end
                        end
                    end
                end
            end
            table.insert(game.entities, entity)
            ::skip_ent::
        end
    end
end


function get_distance_manual(pos1, pos2)
    local dx = pos1.x - pos2.x
    local dy = pos1.y - pos2.y
    local dz = pos1.z - pos2.z
    return math.sqrt(dx*dx + dy*dy + dz*dz)
end

function world_to_screen(view_matrix, position)
    local screen_width, screen_height = render.get_viewport_size()
    local w = view_matrix[13] * position.x + view_matrix[14] * position.y + view_matrix[15] * position.z + view_matrix[16]
    
    if w < 0.01 then return nil end

    local screen_x = view_matrix[1] * position.x + view_matrix[2] * position.y + view_matrix[3] * position.z + view_matrix[4]
    local screen_y = view_matrix[5] * position.x + view_matrix[6] * position.y + view_matrix[7] * position.z + view_matrix[8]

    local inv_w = 1.0 / w
    screen_x = screen_x * inv_w
    screen_y = screen_y * inv_w

    local x = screen_width / 2.0 + (0.5 * screen_x * screen_width + 0.5)
    local y = screen_height / 2.0 - (0.5 * screen_y * screen_height + 0.5)

    if x < 0 or x > screen_width or y < 0 or y > screen_height then
        return nil
    end

    return vec2(x, y)
end

function get_active_weapon_name(entity_pawn)
    local status, result = pcall(function()
        if not entity_pawn or entity_pawn == 0 then return "UNKNOWN" end

        local clipping_weapon_ptr = proc.read_int64(entity_pawn + offsets.m_pClippingWeapon)
        if not clipping_weapon_ptr or clipping_weapon_ptr == 0 then return "UNKNOWN" end

        local item_definition_ptr = proc.read_int64(clipping_weapon_ptr + 0x10)
        if not item_definition_ptr or item_definition_ptr == 0 then return "UNKNOWN" end
        
        local designer_name_ptr = proc.read_int64(item_definition_ptr + 0x20)
        if not designer_name_ptr or designer_name_ptr == 0 then return "UNKNOWN" end

        local weapon_name_raw = proc.read_string(designer_name_ptr, 40)
        if not weapon_name_raw or weapon_name_raw == "" then return "UNKNOWN" end
        
        local _, _, weapon_name = string.find(weapon_name_raw, "weapon_(.+)")
        if weapon_name then
            return string.upper(weapon_name) 
        end
        return "WEAPON"
    end)

    if status then return result else return "UNKNOWN" end
end



-- local MapParser = require("polys.mapparser")

-- function draw_skeleton(bones_2d, col_hidden, bones_3d, local_eye, col_visible)
--     local function get_safe_color(c, default)
--         if type(c) ~= "table" then return table.unpack(default) end
--         return c[1] or default[1], c[2] or default[2], c[3] or default[3], c[4] or 255
--     end

--     local rh, gh, bh, ah = get_safe_color(col_hidden, {255, 0, 0, 255})
--     local rv, gv, bv, av = 0, 255, 0, 255 
    
--     local do_trace = false
--     if bones_3d and local_eye and col_visible and MapParser then
--         do_trace = true
--         rv, gv, bv, av = get_safe_color(col_visible, {0, 255, 0, 255})
--     end

--     local connections = {
--         {"head", "neck"}, {"neck", "spine_3"}, {"spine_3", "spine_2"}, {"spine_2", "spine_1"}, {"spine_1", "pelvis"},
--         {"spine_3", "clavicle_L"}, {"clavicle_L", "arm_upper_L"}, {"arm_upper_L", "arm_lower_L"}, {"arm_lower_L", "hand_L"},
--         {"spine_3", "clavicle_R"}, {"clavicle_R", "arm_upper_R"}, {"arm_upper_R", "arm_lower_R"}, {"arm_lower_R", "hand_R"},
--         {"pelvis", "leg_upper_L"}, {"leg_upper_L", "leg_lower_L"}, {"leg_lower_L", "ankle_L"},
--         {"pelvis", "leg_upper_R"}, {"leg_upper_R", "leg_lower_R"}, {"leg_lower_R", "ankle_R"}
--     }

--     local vis_cache = {}
--     local function check_vis(bone_name)
--         if not do_trace then return false end
--         if vis_cache[bone_name] ~= nil then return vis_cache[bone_name] end
--         if not bones_3d[bone_name] then return false end
        
--         local is_vis = MapParser.is_visible(local_eye, bones_3d[bone_name])
--         vis_cache[bone_name] = is_vis
--         return is_vis
--     end

--     for _, pair in ipairs(connections) do
--         local b1, b2 = pair[1], pair[2]
        
--         if bones_2d[b1] and bones_2d[b2] then
--             local r, g, b, a = rh, gh, bh, ah
            
--             if do_trace then
--                 if check_vis(b1) or check_vis(b2) then
--                     r, g, b, a = rv, gv, bv, av
--                 end
--             end
            
--             render.draw_line(bones_2d[b1].x, bones_2d[b1].y, bones_2d[b2].x, bones_2d[b2].y, r, g, b, a, 1)
--         end
--     end
-- end

function draw_circular_skeleton(bones_2d, scale, color)
    local r, g, b, a = table.unpack(color)

    local BONE_CONNECTIONS = {
        {"head", "neck_0"}, {"neck_0", "spine_1"}, {"spine_1", "pelvis"},
        {"spine_1", "arm_upper_L"}, {"arm_upper_L", "arm_lower_L"}, {"arm_lower_L", "hand_L"},
        {"spine_1", "arm_upper_R"}, {"arm_upper_R", "arm_lower_R"}, {"arm_lower_R", "hand_R"},
        {"pelvis", "leg_upper_L"}, {"leg_upper_L", "leg_lower_L"}, {"leg_lower_L", "ankle_L"},
        {"pelvis", "leg_upper_R"}, {"leg_upper_R", "leg_lower_R"}, {"leg_lower_R", "ankle_R"}
    }
    
    local function draw_bone_tube(p1, p2, radius)
        local delta = p2 - p1
        local dist = delta:length()
        local step = radius * 0.75

        if dist < step then
            render.draw_circle(p1.x, p1.y, radius, r, g, b, a, 1.5, false)
            render.draw_circle(p2.x, p2.y, radius, r, g, b, a, 1.5, false)
            return
        end

        for i = 0, dist, step do
            local point = p1 + (delta * (i / dist))
            render.draw_circle(point.x, point.y, radius, r, g, b, a, 1.5, false)
        end
    end

    for _, pair in ipairs(BONE_CONNECTIONS) do
        local pos1 = bones_2d[pair[1]]
        local pos2 = bones_2d[pair[2]]
        if pos1 and pos2 then
            draw_bone_tube(pos1, pos2, math.max(1.5, 3 * scale))
        end
    end
end


local function draw_filled_box(rect, r, g, b, a)
    local w = rect.right - rect.left
    local h = rect.bottom - rect.top
    local top_col = {r, g, b, 0}
    local bot_col = {r, g, b, math.floor(a * 0.4)} 
    render.draw_gradient_rectangle(rect.left, rect.top, w, h, {top_col, bot_col}, 0)
    render.draw_rectangle(rect.left, rect.top, w, h, r, g, b, a, 1, false)
    render.draw_rectangle(rect.left-1, rect.top-1, w+2, h+2, 0, 0, 0, math.floor(a*0.6), 1, false)
    render.draw_rectangle(rect.left+1, rect.top+1, w-2, h-2, 0, 0, 0, math.floor(a*0.6), 1, false)
end



function draw_outlined_text(font, text, x, y, r, g, b, a, alignment)
    if not text or text == "" then return end
    
    local text_w, text_h = render.measure_text(font, text)
    local draw_x = x
    local draw_y = y

    if alignment == "center" then
        draw_x = x - (text_w / 2)
    elseif alignment == "right" then
        draw_x = x - text_w
    end
    
    render.draw_text(font, text, draw_x, draw_y, r, g, b, a, 1, 0, 0, 0, a)
end




function draw_filled_box(rect, r, g, b, a, is_corner)
    local fill_alpha_top = math.floor(a * 0.05) 
    local fill_alpha_bot = math.floor(a * 0.15) 

    local top_color = { r, g, b, fill_alpha_top }
    local bottom_color = { r, g, b, fill_alpha_bot }

    local colors_table = { top_color, bottom_color }

    render.draw_gradient_rectangle(rect.left, rect.top, (rect.right - rect.left), (rect.bottom - rect.top), colors_table, 0)

    local outline_thickness = 1
    render.draw_rectangle(rect.left, rect.top, (rect.right - rect.left), (rect.bottom - rect.top), r, g, b, a, outline_thickness, false)
end


local function draw_shook_gradient_bar(x, y, w, h, value, max, color_c, is_vertical)
    local pct = math.clamp(value / max, 0, 1)
    local a = color_c[4]
    
    render.draw_rectangle(x, y, w, h, 20, 22, 27, 180, 0, true) 
    render.draw_rectangle(x, y, w, h, 0, 0, 0, a, 1, false)

    if is_vertical then
        local fill_h = math.floor(h * pct)
        local bar_y = y + (h - fill_h)
        
        if fill_h > 0 then
            local r, g, b = color_c[1], color_c[2], color_c[3]
            local dr, dg, db = math.floor(r*0.6), math.floor(g*0.6), math.floor(b*0.6)
            
            render.draw_gradient_rectangle(x + 1, bar_y + 1, w - 2, fill_h - 2, 
                {{r, g, b, a}, {dr, dg, db, a}}, 0) 
        end
    else
        local fill_w = math.floor(w * pct)
        
        if fill_w > 0 then
            local r, g, b = color_c[1], color_c[2], color_c[3]
            local dr, dg, db = math.floor(r*0.7), math.floor(g*0.7), math.floor(b*0.7)

            local grad_col = {{r,g,b,a}, {dr,dg,db,a}}
            render.draw_gradient_rectangle(x + 1, y + 1, fill_w - 2, h - 2, grad_col, 0)
        end
    end
end


local function draw_capsule_line(p1, p2, radius, r, g, b, a)
    local dx = p2.x - p1.x
    local dy = p2.y - p1.y
    local len = math.sqrt(dx*dx + dy*dy)

    if len <= 0 then return end

    local nx = -dy / len
    local ny = dx / len

    local ox = nx * radius
    local oy = ny * radius

    local points = {
        p1.x + ox, p1.y + oy,
        p2.x + ox, p2.y + oy,
        p2.x - ox, p2.y - oy,
        p1.x - ox, p1.y - oy
    }

    render.draw_polygon(points, r, g, b, a, 0, true)
    render.draw_circle(p1.x, p1.y, radius, r, g, b, a, 0, true)
    render.draw_circle(p2.x, p2.y, radius, r, g, b, a, 0, true)
end

function draw_capsule_skeleton(bones_2d, scale, color)
    local r, g, b, a = table.unpack(color)
    local outline_a = math.max(0, a - 40)

    local base = 4.5 * scale 

    local connections = {
        -- Torso (Thickest)
        {"pelvis",  "spine_1", 3.8}, 
        {"spine_1", "spine_2", 4.0}, 
        {"spine_2", "spine_3", 4.2}, 
        {"spine_3", "neck",    3.0}, 
        {"neck",    "head",    3.2}, 

        -- Shoulders
        {"spine_3", "clavicle_L", 2.5},
        {"spine_3", "clavicle_R", 2.5},

        -- Arms (Tapered)
        {"clavicle_L", "arm_upper_L", 2.2}, 
        {"arm_upper_L", "arm_lower_L", 1.9}, 
        {"arm_lower_L", "hand_L",      1.6},

        {"clavicle_R", "arm_upper_R", 2.2}, 
        {"arm_upper_R", "arm_lower_R", 1.9}, 
        {"arm_lower_R", "hand_R",      1.6},

        -- Legs (Athletic)
        {"pelvis", "leg_upper_L", 3.2}, 
        {"leg_upper_L", "leg_lower_L", 2.6}, 
        {"leg_lower_L", "ankle_L", 2.0},

        {"pelvis", "leg_upper_R", 3.2}, 
        {"leg_upper_R", "leg_lower_R", 2.6}, 
        {"leg_lower_R", "ankle_R", 2.0},
    }

    local outline_thickness = math.max(1.0, 1.5 * scale) 
    
    for _, bond in ipairs(connections) do
        local p1 = bones_2d[bond[1]]
        local p2 = bones_2d[bond[2]]
        if p1 and p2 then
            local radius = (base * bond[3]) + outline_thickness
            draw_capsule_line(p1, p2, radius, 0, 0, 0, math.floor(outline_a * 0.8))
        end
    end
    
    for _, bond in ipairs(connections) do
        local p1 = bones_2d[bond[1]]
        local p2 = bones_2d[bond[2]]
        if p1 and p2 then
            local radius = base * bond[3]
            draw_capsule_line(p1, p2, radius, r, g, b, a)
        end
    end

    -- Feet
    local function draw_foot_pass(ank, is_outline)
        local p = bones_2d[ank]
        if p then
            local foot_len = 5 * (scale / 0.8) 
            local foot_end = { x = p.x, y = p.y + foot_len }
            
            local radius = (1.8 * base)
            if is_outline then radius = radius + outline_thickness end
            
            local fr, fg, fb, fa = r, g, b, a
            if is_outline then fr,fg,fb,fa = 0,0,0, math.floor(outline_a * 0.8) end
            
            draw_capsule_line(p, foot_end, radius, fr, fg, fb, fa)
        end
    end

    draw_foot_pass("ankle_L", true); draw_foot_pass("ankle_R", true)
    draw_foot_pass("ankle_L", false); draw_foot_pass("ankle_R", false)
end



function render_entity_info(entity, prefix, is_preview)
    local rect = entity.rect
    local h = rect.bottom - rect.top
    if h <= 2 then return end
    local w = rect.right - rect.left
    local cx, cy = rect.left + (w/2), rect.top + (h/2)
    
    local default_col = {255, 255, 255, 255}
    local is_box = MenuLib.get_value(prefix .. "_box")
    local font_main = esp_fonts.name or Menu.fonts.group
    local font_small = esp_fonts.weapon or Menu.fonts.main

    -- [[ 1. BOX RENDERING ]]
    if is_box then
        local col = MenuLib.get_value(prefix.."_box_color") or default_col
        local bt = MenuLib.get_value(prefix.."_box_type")
        local r,g,b,a = col[1],col[2],col[3],col[4]

        if bt == 2 then -- Corner
            local L = math.max(6, h*0.2)
            local function c(x1,y1,x2,y2) render.draw_line(x1,y1,x2,y2,0,0,0,a*0.8,3); render.draw_line(x1,y1,x2,y2,r,g,b,a,1) end
            c(rect.left,rect.top, rect.left+L,rect.top); c(rect.left,rect.top, rect.left,rect.top+L)
            c(rect.right,rect.top, rect.right-L,rect.top); c(rect.right,rect.top, rect.right,rect.top+L)
            c(rect.left,rect.bottom, rect.left+L,rect.bottom); c(rect.left,rect.bottom, rect.left,rect.bottom-L)
            c(rect.right,rect.bottom, rect.right-L,rect.bottom); c(rect.right,rect.bottom, rect.right,rect.bottom-L)
        elseif bt == 3 then -- Filled
             render.draw_gradient_rectangle(rect.left,rect.top,w,h,{{r,g,b,0},{r,g,b,math.floor(a*0.3)}},0)
             render.draw_rectangle(rect.left-1,rect.top-1,w+2,h+2,0,0,0,a,1,false)
             render.draw_rectangle(rect.left,rect.top,w,h,r,g,b,a,1,false)
        else -- Standard
             render.draw_rectangle(rect.left-1,rect.top-1,w+2,h+2,0,0,0,a*0.8,1,false)
             render.draw_rectangle(rect.left+1,rect.top+1,w-2,h-2,0,0,0,a*0.8,1,false)
             render.draw_rectangle(rect.left,rect.top,w,h,r,g,b,a,1,false)
        end
    end

    -- Padding tracking for text placement (starts at 3px gap from box)
    local bar_padding = { l=3, r=3, t=3, b=3 }
    local bar_gap = 2 -- Gap between bars
    local bar_thickness = 4 -- Width of the bars

    -- [[ 2. DRAW BARS ]]
    -- Helper to get side preference
    local function get_layout_side(id)
        local off = LayoutState.offsets[id] or {x=0, y=0}
        if math.abs(off.x)*1.4 > math.abs(off.y) then
            return (off.x < 0) and "left" or "right"
        else
            return (off.y < 0) and "top" or "bottom"
        end
    end

    local function process_bar(id, val, max, col)
        if not MenuLib.get_value(prefix .. "_" .. id) then return end
        local side = get_layout_side(id)
        local pct = math.clamp(val / max, 0, 1)
        
        local bw, bh, bx, by = 0,0,0,0
        local orient = "vertical"

        if side == "left" then
            bw, bh = bar_thickness, h
            bx = rect.left - bar_padding.l - bw
            by = rect.top
            bar_padding.l = bar_padding.l + bw + bar_gap -- Push text further left
            orient = "vertical"
        elseif side == "right" then
            bw, bh = bar_thickness, h
            bx = rect.right + bar_padding.r
            by = rect.top
            bar_padding.r = bar_padding.r + bw + bar_gap
            orient = "vertical"
        elseif side == "bottom" then
            bw, bh = w, bar_thickness
            bx = rect.left
            by = rect.bottom + bar_padding.b
            bar_padding.b = bar_padding.b + bh + bar_gap
            orient = "horizontal"
        elseif side == "top" then
            bw, bh = w, bar_thickness
            bx = rect.left
            by = rect.top - bar_padding.t - bh
            bar_padding.t = bar_padding.t + bh + bar_gap
            orient = "horizontal"
        end

        draw_shook_style_bar(bx, by, bw, bh, pct, col, orient)
        
        if is_preview then
             -- Hitbox logic for drag preview
             table.insert(LayoutState.hitboxes, {id=id, x=bx-4, y=by-4, w=bw+8, h=bh+8})
        end
    end
    
    if MenuLib.get_value(prefix.."_health") then
        local hp = entity.health or 100
        local r, g = math.floor((100 - hp) * 2.55), math.floor(hp * 2.55)
        process_bar("health", hp, 100, {r, g, 0, 255})
    end
    if MenuLib.get_value(prefix.."_armor") then
        process_bar("armor", entity.armor or 0, 100, {0, 140, 255, 255})
    end

    -- [[ 3. TEXT STACKING ]]
    local text_groups = { top={}, bottom={}, left={}, right={} }

    local function queue_text(id, txt, col)
        local check_id = (id == "c4_carrier") and "c4_carrier" or id
        local key = prefix .. (check_id == "weapon" and "_player_weapon" or "_" .. check_id)
        if id == "flags" then key = nil end 
        if key and not MenuLib.get_value(key) then return end
        
        local s = get_layout_side(id)
        local off = LayoutState.offsets[id] or {x=0,y=0}
        table.insert(text_groups[s], {id=id, text=txt, col=col, y_order=off.y})
    end
    
    -- Queue Items
    if entity.name then queue_text("name", entity.name, MenuLib.get_value(prefix.."_name_color")or default_col) end
    if entity.weapon then queue_text("weapon", entity.weapon, default_col) end
    if MenuLib.get_value(prefix.."_distance") then 
        local dc=MenuLib.get_value(prefix.."_distance_color")or default_col
        queue_text("distance", math.floor(entity.distance).."m", dc)
    end
    if MenuLib.get_value(prefix.."_money") and entity.money then
        local mc=MenuLib.get_value(prefix.."_money_color")or{110,255,110,255}
        queue_text("money", "$"..entity.money, mc) 
    end

    local fs=""
    if entity.is_scoped and MenuLib.get_value(prefix.."_scoped_flag") then fs="ZOOM" end
    if entity.is_flashed and MenuLib.get_value(prefix.."_flashed_flag") then fs=fs..((fs~="" and "\n" or "").."BLIND") end
    if fs~="" then queue_text("flags", fs, {255,200,50,255}) end

    if entity.has_c4 then 
        queue_text("c4_carrier", "C4", {255, 50, 50, 255})
    end

    -- Draw Stacks
    for side, items in pairs(text_groups) do
        if #items > 0 then
            table.sort(items, function(a,b) return a.y_order < b.y_order end)
            local offset_stack = 0
            
            -- [FIX] Base start positions now respect the bars we just drew
            local ax, ay = 0, 0
            
            if side=="top" then 
                ay = rect.top - bar_padding.t - 1 -- Start above top bars
            elseif side=="bottom" then 
                ay = rect.bottom + bar_padding.b + 1 -- Start below bottom bars
            elseif side=="left" then 
                ax = rect.left - bar_padding.l - 2 -- Start left of left bars
            elseif side=="right" then 
                ax = rect.right + bar_padding.r + 2 -- Start right of right bars
            end

            for _, itm in ipairs(items) do
                for line in string.gmatch(itm.text.."\n", "(.-)\n") do
                    if line~="" then
                        local tw, th = render.measure_text(font_small, line)
                        local tx, ty = 0, 0
                        
                        if side=="top" then
                             tx=cx-tw/2; ty=ay - offset_stack - th
                             offset_stack = offset_stack + th + 1
                        elseif side=="bottom" then
                             tx=cx-tw/2; ty=ay + offset_stack
                             offset_stack = offset_stack + th + 1
                        elseif side=="left" then
                             tx=ax-tw; ty=rect.top + offset_stack
                             offset_stack = offset_stack + th + 1
                        elseif side=="right" then
                             tx=ax; ty=rect.top + offset_stack
                             offset_stack = offset_stack + th + 1
                        end
                        
                        -- Draw Shadow
                        render.draw_text(font_small, line, tx+1, ty+1, 0,0,0,180, 0,0,0,0,0)
                        -- Draw Main
                        render.draw_text(font_small, line, tx, ty, itm.col[1],itm.col[2],itm.col[3],itm.col[4], 0,0,0,0,0)

                        if is_preview then
                             table.insert(LayoutState.hitboxes, {id=itm.id, x=tx, y=ty, w=tw, h=th})
                        end
                    end
                end
            end
        end
    end
end

    local client_dll = proc.find_module("client.dll")
    if client_dll == 0 then return end
 local game = {}
    game.client_dll = client_dll
    game.view_matrix = {}
    for i = 0, 15 do table.insert(game.view_matrix, proc.read_float(client_dll + offsets.dwViewMatrix + (i * 4))) end
    
    game.local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if game.local_pawn == 0 then return end
    game.local_team = proc.read_int32(game.local_pawn + offsets.m_iTeamNum)
    game.entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    
    game.entities = {}




local function get_current_map_name()
    local raw_proc = proc.handle() 
    if not raw_proc then return nil end

    local client_base, _ = raw_proc:get_module("client.dll")
    if not client_base or client_base == 0 then return nil end

    local global_vars = raw_proc:r64(client_base + offsets.dwGlobalVars)
    if global_vars == 0 then return nil end

    local map_ptr_230 = raw_proc:r64(global_vars + 0x230)
    
    if map_ptr_230 > 0x10000 then
        local map_name = raw_proc:rs(map_ptr_230, 64)
        if map_name and map_name ~= "" then
            --engine.log("Map Found via 0x230: " .. map_name) -- Debug
            return map_name
        end
    end


    local map_ptr_180 = raw_proc:r64(global_vars + 0x180)
    
    if map_ptr_180 > 0x10000 then
        local map_name = raw_proc:rs(map_ptr_180, 64)
        if map_name and map_name ~= "" then
            -- engine.log("Map Found via 0x180: " .. map_name) -- Debug
            return map_name
        end
    end

    return nil
end



local radar = {
    x = 200, y = 200,
    size = 250,
    scale = 0.24,
    rotation_angle = 90,
    bg_color = {25, 25, 25, 180},
    outline_color = {150, 0, 255, 255},
    local_player_color = {255, 255, 255, 255},
    enemy_color = {255, 0, 0, 255},
    team_color = {0, 150, 255, 255},
    view_line_color = {255, 255, 0, 255},
    name_font = render.create_font("Verdana", 10, 500) -- Font for radar names
}

local g = {
    client_module = nil,
    entities = {},
    local_pos = {x=0, y=0},
    local_yaw = 0,
    is_dragging = false,
    drag_offset = {x=0, y=0}
}

local function read_vec3(address)
    return {
        x = proc.read_float(address),
        y = proc.read_float(address + 4),
        z = proc.read_float(address + 8)
    }
end

local C4_DEF_INDEX = 49

local function update_data()
    g.entities = {}
    g.c4 = nil 

    if not g.client_module then g.client_module = proc.find_module("client.dll") end
    if not g.client_module or g.client_module == 0 then return end

    -- 1. Map Name
    local raw_map_name = get_current_map_name()
    if raw_map_name then
        local clean_name = raw_map_name
        clean_name = string.gsub(clean_name, "maps/", "")
        clean_name = string.gsub(clean_name, "%.vpk", "")
        clean_name = string.gsub(clean_name, "^%s*(.-)%s*$", "%1")
        if clean_name == "_dust2" then clean_name = "de_dust2" end
        if string.sub(clean_name, 1, 1) == "_" then clean_name = "de" .. clean_name end
        g.current_map = clean_name
    else
        if not g.current_map then g.current_map = "de_mirage" end
    end

    -- 2. Local Player
    local lpawn_addr = proc.read_int64(g.client_module + offsets.dwLocalPlayerPawn)
    if not lpawn_addr or lpawn_addr == 0 then return end

    local lpawn_ctrl = proc.read_int64(g.client_module + offsets.dwLocalPlayerController)
    local local_money, local_name = 0, "ME"
    
    if lpawn_ctrl and lpawn_ctrl ~= 0 then
        local money_svc = proc.read_int64(lpawn_ctrl + offsets.m_pInGameMoneyServices)
        if money_svc ~= 0 then local_money = proc.read_int32(money_svc + offsets.m_iAccount) end
        local name_addr = proc.read_int64(lpawn_ctrl + offsets.m_sSanitizedPlayerName)
        if name_addr ~= 0 then local_name = proc.read_string(name_addr, 32) end
    end

    g.local_team = proc.read_int32(lpawn_addr + offsets.m_iTeamNum)
    local local_pos_vec = read_vec3(lpawn_addr + offsets.m_vOldOrigin)
    
    g.local_pos = {x = local_pos_vec.x, y = local_pos_vec.y}
    g.local_yaw = proc.read_float(g.client_module + offsets.dwViewAngles + 4) 
    g.local_info = { name = local_name, health = proc.read_int32(lpawn_addr + offsets.m_iHealth), money = local_money, weapon = get_active_weapon_name(lpawn_addr) }

    -- 3. Entities
    local entity_list_addr = proc.read_int64(g.client_module + offsets.dwEntityList)
    if not entity_list_addr or entity_list_addr == 0 then return end

    for i = 1, 64 do
        local entry_addr = proc.read_int64(entity_list_addr + 0x8 * (i >> 9) + 0x10)
        if entry_addr ~= 0 then
            local ctrl_addr = proc.read_int64(entry_addr + 112 * (i & 0x1FF))
            if ctrl_addr ~= 0 and ctrl_addr ~= lpawn_ctrl then
                local pawn_handle = proc.read_int32(ctrl_addr + offsets.m_hPlayerPawn)
                if pawn_handle and pawn_handle > 0 and (pawn_handle & 0x7FFF) > 0 then
                    local masked_h = pawn_handle & 0x7FFF
                    local pawn_entry_addr = proc.read_int64(entity_list_addr + 0x8 * (masked_h >> 9) + 0x10)
                    if pawn_entry_addr ~= 0 then
                        local pawn_addr = proc.read_int64(pawn_entry_addr + 112 * (masked_h & 0x1FF))
                        if pawn_addr ~= 0 then
                            local hp = proc.read_int32(pawn_addr + offsets.m_iHealth)
                            
                            -- [FIX] Removed "if hp > 0" check. We process dead players now too.
                            -- We check lifeState to ensure they haven't respawned or are spectating.
                            -- lifeState: 256 = Alive, 257 = Dying, 258 = Dead
                            local life_state = proc.read_int32(pawn_addr + offsets.m_lifeState)
                            
                            -- Process if alive OR recently dead (hp <= 0)
                            if life_state == 256 or hp <= 0 then
                                local team = proc.read_int32(pawn_addr + offsets.m_iTeamNum)
                                local pos = read_vec3(pawn_addr + offsets.m_vOldOrigin)
                                
                                -- [NEW] Read Eye Angles (Yaw)
                                local eye_yaw = proc.read_float(pawn_addr + offsets.m_angEyeAngles + 4)

                                local name_str = "?"
                                local name_addr = proc.read_int64(ctrl_addr + offsets.m_sSanitizedPlayerName)
                                if name_addr ~= 0 then name_str = proc.read_string(name_addr, 32) end
                                
                                local money = 0
                                local money_svc = proc.read_int64(ctrl_addr + offsets.m_pInGameMoneyServices)
                                if money_svc ~= 0 then money = proc.read_int32(money_svc + offsets.m_iAccount) end

                                local is_carrying_c4 = (_G.C4_Carrier_Handle ~= 0 and pawn_handle == _G.C4_Carrier_Handle)
                                
                                -- Internal Radar Colors
                                local dot_color = {255, 255, 255, 255}
                                if hp <= 0 then 
                                    dot_color = {100, 100, 100, 150} -- Grey for dead
                                elseif team ~= g.local_team then
                                    dot_color = {255, 50, 50, 255}
                                else
                                    dot_color = {50, 150, 255, 255}
                                end

                                table.insert(g.entities, {
                                    id = pawn_addr,
                                    pawn_address = pawn_addr,
                                    pos = {x=pos.x, y=pos.y}, 
                                    team = team,
                                    name = name_str,
                                    health = hp,
                                    money = money,
                                    weapon = get_active_weapon_name(pawn_addr),
                                    has_c4 = is_carrying_c4,
                                    color = dot_color,
                                    eye_yaw = eye_yaw -- [NEW] Sending Yaw
                                })
                            end
                        end
                    end
                end
            end
        end
    end
end

local radar_state = {
    x = 20, y = 350,
    size = 200,
    scale = 18.0, 
    dragging = false, drag_off_x = 0, drag_off_y = 0
}

local function draw_modern_radar(game)
    if not MenuLib.get_value("misc_radar") then return end

    local x, y = radar_state.x, radar_state.y
    local size = radar_state.size
    local cx, cy = x + (size / 2), y + (size / 2)
    local r_radius = (size / 2) - 3 

    local mx, my = input.get_mouse_position()
    if Menu.visible then 
        local hov = mx > x and mx < x + size and my > y and my < y + size
        if hov and input.is_key_pressed(1) and not radar_state.dragging then
            radar_state.dragging = true; radar_state.drag_off_x = mx - x; radar_state.drag_off_y = my - y
        end
    end
    if radar_state.dragging then
        if not input.is_key_down(1) then radar_state.dragging = false else
            radar_state.x = mx - radar_state.drag_off_x; radar_state.y = my - radar_state.drag_off_y
            x, y = radar_state.x, radar_state.y; cx, cy = x + (size/2), y + (size/2)
        end
    end

    render.draw_rectangle(x, y, size, size, 22, 22, 27, 240, 0, true, 8)
    render.draw_rectangle(x, y, size, size, 70, 70, 80, 255, 1.5, false, 8)
    
    render.draw_line(cx, y + 5, cx, y + size - 5, 255, 255, 255, 40, 1)
    render.draw_line(x + 5, cy, x + size - 5, cy, 255, 255, 255, 40, 1)

    local l_yaw = g.local_yaw
    local rad_yaw = math.rad(l_yaw) 
    local l_pos = g.local_pos

    render.draw_circle(cx, cy, 3, 255, 255, 255, 255, 0, true)

    local function world_to_radar(wx, wy)
        local dx = wx - l_pos.x
        local dy = wy - l_pos.y
        
        local rot_x = dx * math.sin(rad_yaw) - dy * math.cos(rad_yaw)
        local rot_y = dx * math.cos(rad_yaw) + dy * math.sin(rad_yaw)
        
        local map_x = rot_x / radar_state.scale
        local map_y = -rot_y / radar_state.scale 

        local dist = math.sqrt(map_x^2 + map_y^2)
        
        local is_clamped = false
        if dist > r_radius then
            map_x = (map_x / dist) * r_radius
            map_y = (map_y / dist) * r_radius
            is_clamped = true
        end

        return (cx + map_x), (cy + map_y), is_clamped
    end

    if g.c4 then
        local bx, by, clamped = world_to_radar(g.c4.pos.x, g.c4.pos.y)
        
        if g.c4.type == "planted" then
            local time = winapi.get_tickcount64() / 250
            local alpha = (math.sin(time) > 0) and 255 or 100
            
            render.draw_rectangle(bx - 3, by - 3, 6, 6, 255, 50, 50, alpha, 0, true)
            render.draw_rectangle(bx - 3, by - 3, 6, 6, 0, 0, 0, 255, 1, false)
            if not clamped then 
                render.draw_text(radar.name_font, "BOMB", bx - 10, by - 12, 255, 100, 100, 255, 0,0,0,0,0)
            end
        else
            render.draw_circle(bx, by, 3, 255, 255, 0, 255, 0, true)
            render.draw_circle(bx, by, 4, 0, 0, 0, 200, 1, false)
            if not clamped then 
                render.draw_text(radar.name_font, "C4", bx - 6, by - 12, 255, 255, 200, 255, 0,0,0,0,0)
            end
        end
    end

    for _, ent in ipairs(g.entities) do
        local rx, ry, is_clamped = world_to_radar(ent.pos.x, ent.pos.y)
        
        local r, g_val, b = table.unpack(ent.color)

        if ent.has_c4 then
            r, g_val, b = 255, 180, 0 
            
            render.draw_circle(rx, ry, 6, r, g_val, b, 255, 0, true) 
            render.draw_circle(rx, ry, 7, 0, 0, 0, 255, 1, false) 
            
            if not is_clamped then
                render.draw_text(radar.name_font, "BOMB", rx + 5, ry - 14, 255, 200, 100, 255, 1.0,0,0,0,150)
            end
        end

        if not is_clamped then
            local ent_yaw = proc.read_float(ent.pawn_address + offsets.m_angEyeAngles + 4) 
            if not ent_yaw then ent_yaw = 0 end
            
            local relative_yaw = math.rad(ent_yaw - l_yaw - 90) 
            local line_len = 12
            
            local lx = rx + math.cos(relative_yaw) * line_len
            local ly = ry + math.sin(relative_yaw) * line_len
            
            render.draw_line(rx, ry, lx, ly, 255, 255, 255, 180, 1)
        end

        if not ent.has_c4 then
            render.draw_circle(rx, ry, 4, r, g_val, b, 255, 0, true)
            render.draw_circle(rx, ry, 5, 0, 0, 0, 180, 1, false)
        end

        if ent.name and not ent.has_c4 then 
            local tw, th = render.measure_text(radar.name_font, ent.name)
            render.draw_text(radar.name_font, ent.name, rx - tw/2, ry - 14, 255, 255, 255, 230, 0,0,0,0,0)
        elseif ent.has_c4 and ent.name then
            local tw, th = render.measure_text(radar.name_font, ent.name)
            render.draw_text(radar.name_font, ent.name, rx - tw/2, ry + 6, 255, 200, 100, 230, 0,0,0,0,0)
        end
    end
end

local function update_dynamic_scale()
    local max_dist = 1
    for _, ent in ipairs(g.entities) do
        local dist = math.sqrt((ent.pos.x - g.local_pos.x)^2 + (ent.pos.y - g.local_pos.y)^2)
        if dist > max_dist then
            max_dist = dist
        end
    end
    local new_scale = (radar.size / 2) / max_dist
    radar.scale = math.max(0.01, math.min(new_scale, 0.5))
end

local function handle_dragging()
    local mx, my = input.get_mouse_position()
    if input.is_key_pressed(1) and (mx > radar.x and mx < radar.x + radar.size and my > radar.y and my < radar.y + radar.size) then
        g.is_dragging = true
        g.drag_offset = {x = mx - radar.x, y = my - radar.y}
    end

    if g.is_dragging then
        if input.is_key_down(1) then
            radar.x = mx - g.drag_offset.x
            radar.y = my - g.drag_offset.y
        else
            g.is_dragging = false
        end
    end
end

local function on_engine_tick()
    if not MenuLib.get_value("misc_radar") then
        return
    end

    if not g.client_module then return end
   
   

end

local function on_script_load_radar()
    if not proc.is_attached() then
        engine.log("Error: Attach to cs2.exe first.", 255, 0, 0, 255)
        return
    end

    g.client_module = proc.find_module("client.dll")
    if g.client_module and g.client_module > 0 then
        engine.log("Radar Script Loaded.", 0, 255, 0, 255)
        engine.register_on_engine_tick(on_engine_tick)
    else
        engine.log("Critical Error: Could not find client.dll.", 255, 0, 0, 255)
    end
end

on_script_load_radar()

local client_base = nil


function update_glow()
    local client_dll = proc.find_module("client.dll")
    if not client_dll or client_dll == 0 then return end
    
    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if not local_pawn or local_pawn == 0 then return end
    
    local local_team = proc.read_int32(local_pawn + offsets.m_iTeamNum)
    local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    if not entity_list or entity_list == 0 then return end

    local enemy_glow_on = MenuLib.get_value("esp_glow_enemy")
    local enemy_glow_color = MenuLib.get_value("esp_glow_color_enemy")
    

    local team_glow_on = false 
    local team_glow_color = {0, 1, 0, 1}

    if not enemy_glow_on and not team_glow_on then return end

    for i = 1, 64 do
        local list_entry = proc.read_int64(entity_list + (8 * (i & 0x7FFF) >> 9) + 16)
        if not list_entry or list_entry == 0 then goto continue_glow end

        local controller = proc.read_int64(list_entry + 112 * (i & 0x1FF))
        if not controller or controller == 0 then goto continue_glow end

        local pawn_handle = proc.read_int32(controller + offsets.m_hPlayerPawn)
        if not pawn_handle or pawn_handle == 0 then goto continue_glow end
        
        local list_entry2 = proc.read_int64(entity_list + 0x8 * ((pawn_handle & 0x7FFF) >> 9) + 16)
        if not list_entry2 or list_entry2 == 0 then goto continue_glow end
        
        local pawn = proc.read_int64(list_entry2 + 112 * (pawn_handle & 0x1FF))
        if not pawn or pawn == 0 or pawn == local_pawn then goto continue_glow end

        if proc.read_int32(pawn + offsets.m_lifeState) ~= 256 then goto continue_glow end

        local ent_team = proc.read_int32(pawn + offsets.m_iTeamNum)
        local is_enemy = (ent_team ~= local_team)

        local color_to_use = nil
        
        if is_enemy and enemy_glow_on then
            color_to_use = enemy_glow_color
        elseif not is_enemy and team_glow_on then
            color_to_use = team_glow_color
        end

        if color_to_use then
            local r, g, b, a = table.unpack(color_to_use)

            local packed_color = (math.floor(a) << 24) | (math.floor(b) << 16) | (math.floor(g) << 8) | math.floor(r)
            
            local glow_offset = offsets.m_Glow 
            

            proc.write_int32(pawn + glow_offset + offsets.m_bGlowing, 1)     
            proc.write_int32(pawn + glow_offset + offsets.m_iGlowType, 3)     -- Style
            proc.write_int32(pawn + glow_offset + offsets.m_glowColorOverride, packed_color)
        end

        ::continue_glow::
    end
end






local WEAPONS_MAP = {
    ["weapon_ak47"] = "AK-47", ["weapon_m4a1"] = "M4A4", ["weapon_awp"] = "AWP", ["weapon_deagle"] = "Desert Eagle",
    ["weapon_elite"] = "Dual Berettas", ["weapon_famas"] = "Famas", ["weapon_fiveseven"] = "Five-SeveN",
    ["weapon_g3sg1"] = "G3SG1", ["weapon_galilar"] = "Galil AR", ["weapon_glock"] = "Glock-18",
    ["weapon_m4a1_silencer"] = "M4A1-S", ["weapon_mac10"] = "MAC-10", ["weapon_mag7"] = "MAG-7",
    ["weapon_mp5sd"] = "MP5-SD", ["weapon_mp7"] = "MP7", ["weapon_mp9"] = "MP9", ["weapon_negev"] = "Negev",
    ["weapon_nova"] = "Nova", ["weapon_p90"] = "P90", ["weapon_p250"] = "P250",
    ["weapon_hkp2000"] = "P2000", ["weapon_sawedoff"] = "Sawed-Off", ["weapon_scar20"] = "SCAR-20",
    ["weapon_sg556"] = "SG 553", ["weapon_ssg08"] = "SSG 08", ["weapon_taser"] = "Zeus x27",
    ["weapon_tec9"] = "Tec-9", ["weapon_ump45"] = "UMP-45", ["weapon_usp_silencer"] = "USP-S",
    ["weapon_xm1014"] = "XM1014", ["weapon_aug"] = "AUG", ["weapon_bizon"] = "PP-Bizon",
    ["weapon_cz75a"] = "CZ75-Auto", ["weapon_m249"] = "M249", ["weapon_revolver"] = "R8 Revolver",
    ["weapon_c4"] = "C4", ["weapon_flashbang"] = "Flashbang", ["weapon_smokegrenade"] = "Smoke Grenade", ["weapon_molotov"] = "Molotov",
    ["weapon_decoy"] = "Decoy Grenade", ["weapon_hegrenade"] = "High Explosive Grenade"
}
local PROJECTILES_MAP = {
    ["smokegrenade_projectile"] = "Smoke", ["flashbang_projectile"] = "Flashbang",
    ["hegrenade_projectile"] = "HE Grenade", ["molotov_projectile"] = "Molotov Fire",
    ["incendiarygrenade_projectile"] = "Incendiary Fire", ["decoy_projectile"] = "Decoy"
}

local esp_font = render.create_font("verdana.ttf", 12)

local function world_to_screen(view_matrix, position_3d)
    local screen_w = view_matrix[13] * position_3d.x + view_matrix[14] * position_3d.y + view_matrix[15] * position_3d.z + view_matrix[16]
    if screen_w < 0.1 then return nil end
    local screen_x = view_matrix[1] * position_3d.x + view_matrix[2] * position_3d.y + view_matrix[3] * position_3d.z + view_matrix[4]
    local screen_y = view_matrix[5] * position_3d.x + view_matrix[6] * position_3d.y + view_matrix[7] * position_3d.z + view_matrix[8]
    local inv_w = 1.0 / screen_w
    local sx, sy = screen_x * inv_w, screen_y * inv_w
    local screen_width, screen_height = render.get_viewport_size()
    local x, y = (screen_width / 2.0) + (sx * screen_width) / 2.0, (screen_height / 2.0) - (sy * screen_height) / 2.0
    return vec2(x, y)
end

local function draw_text_with_outline(font, text, x, y, r, g, b, a)
    if not font then return end 
    local int_x, int_y = math.floor(x), math.floor(y)
    render.draw_text(font, text, int_x-1, int_y, 0, 0, 0, a, 0,0,0,0,0)
    render.draw_text(font, text, int_x+1, int_y, 0, 0, 0, a, 0,0,0,0,0)
    render.draw_text(font, text, int_x, int_y-1, 0, 0, 0, a, 0,0,0,0,0)
    render.draw_text(font, text, int_x, int_y+1, 0, 0, 0, a, 0,0,0,0,0)
    render.draw_text(font, text, int_x, int_y, r, g, b, a, 0,0,0,0,0)
end



local grenade_start_times = {}
local predicted_infernos = {}
local last_frame_grenades = {}
local grenade_anim_states = {} 

local theme = {
    bg       = {22, 23, 27},             
    outline  = {60, 60, 65},             
    text     = {255, 255, 255, 255},
    text_dim = {180, 180, 180, 255},
    
    smoke_acc = {255, 0, 0, 255},
    fire_acc  = {255, 75, 75, 255},
    flash_acc = {255, 215, 50, 255},
    decoy_acc = {100, 235, 100, 255},
    he_acc    = {235, 235, 235, 255}
}

local function lerp(a, b, t)
    return a + (b - a) * t
end


local function draw_dynamic_panel(screen_pos, name, dist_m, progress, accent_color, morph_factor)
    if not screen_pos then return end
    if morph_factor < 0.01 then morph_factor = 0 end 
    
    local dist_str = string.format("%dm", math.floor(dist_m))
    if morph_factor < 0.5 then dist_str = "[" .. dist_str .. "]" end 

    local font_main = esp_fonts.name or Menu.fonts.group or DisplaySystem.fonts.main
    local font_sub = esp_fonts.weapon or Menu.fonts.main or DisplaySystem.fonts.main

    local w_name, h_name = render.measure_text(font_main, name)
    local w_dist, h_dist = render.measure_text(font_sub, dist_str)
    

    local panel_alpha = math.floor(220 * morph_factor)     
    local outline_alpha = math.floor(255 * morph_factor)  
    local text_shadow = math.floor(200 * (1.0 - morph_factor))
    
    local pad_x = 12
    local pad_y = lerp(0, 6, morph_factor)         
    local bar_h = 2
    local bar_gap = 4
    
    local content_spacing = lerp(2, h_name + bar_gap + bar_h + 3, morph_factor)

    local min_width = 40
    local total_w = math.max(min_width, w_name + pad_x * 2)
    local total_h = pad_y * 2 + h_name + bar_gap + bar_h + 2 + h_dist 
    if morph_factor < 0.1 then total_h = h_name + h_dist + 4 end

    local bx = math.floor(screen_pos.x - total_w / 2)
    local by = math.floor(screen_pos.y)

    if panel_alpha > 5 then
        render.draw_rectangle(bx, by, total_w, total_h, theme.bg[1], theme.bg[2], theme.bg[3], panel_alpha, 0, true, 6)
        render.draw_rectangle(bx, by, total_w, total_h, theme.outline[1], theme.outline[2], theme.outline[3], outline_alpha, 1, false, 6)
    end

    local name_y_offset = lerp(-(h_name + 2), pad_y, morph_factor) 
    local name_x = math.floor(screen_pos.x - w_name / 2)
    local name_y = math.floor(by + name_y_offset)
    
    if morph_factor < 0.1 then 
        render.draw_text(font_main, name, name_x, name_y, accent_color[1], accent_color[2], accent_color[3], 255, 1, 0, 0, 0, 180)
    else
        render.draw_text(font_main, name, name_x, name_y, 255, 255, 255, 255, 0, 0, 0, 0, 0)
    end


    local bar_y = name_y + h_name + bar_gap
    if morph_factor > 0.3 and progress > 0 then
        local bar_max_w = total_w - 16
        local cur_bar_w = math.floor(bar_max_w * progress)
        local bar_x = bx + (total_w - bar_max_w) / 2
        local bar_alpha = math.floor(255 * ((morph_factor - 0.3) / 0.7)) 

        render.draw_rectangle(bar_x, bar_y, bar_max_w, bar_h, 40, 40, 45, math.min(200, bar_alpha), 0, true, 1)
        if cur_bar_w > 0 then
            render.draw_rectangle(bar_x, bar_y, cur_bar_w, bar_h, accent_color[1], accent_color[2], accent_color[3], bar_alpha, 0, true, 1)
        end
    end


    local dist_y_offset = lerp(1, pad_y + h_name + bar_gap + bar_h + 3, morph_factor) 
    if morph_factor < 0.1 then dist_y_offset = 1 end 

    local dist_x = math.floor(screen_pos.x - w_dist / 2)
    local dist_y = math.floor(by + dist_y_offset)
    
    render.draw_text(font_sub, dist_str, dist_x, dist_y, theme.text_dim[1], theme.text_dim[2], theme.text_dim[3], theme.text_dim[4], (morph_factor < 0.5 and 1 or 0), 0,0,0,150)
end

_G.C4_Carrier_Handle = 0
_G.WorldSoundRings = {}
_G.WorldSoundCooldowns = {}
_G.EntityShotsCache = {}



local function handle_inferno_esp(view_matrix)
    local draw_inferno = MenuLib.get_value("esp_projectiles")
    if not draw_inferno then return end

    local client_dll = proc.find_module("client.dll")
    if not client_dll then return end

    local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    if not entity_list or entity_list == 0 then return end

    local now = winapi.get_tickcount64() / 1000
    

    local flicker = 0.8 + (math.sin(now * 8) * 0.1) + (math.cos(now * 20) * 0.05)
    
    local breath = (math.sin(now * 2) + 1) * 0.5 

    local c_core = {255, 255, 150} 
    local a_core = math.floor(255 * flicker) 

    local c_body = {255, 100, 0}
    local a_body = math.floor(40 + (20 * breath)) 

    local c_glow = {255, 50, 0}
    local a_glow = math.floor(80 * flicker)

    local FIRE_RADIUS = 22.0
    local cell_offsets = {
        {x=FIRE_RADIUS, y=FIRE_RADIUS}, {x=-FIRE_RADIUS, y=FIRE_RADIUS},
        {x=FIRE_RADIUS, y=-FIRE_RADIUS}, {x=-FIRE_RADIUS, y=-FIRE_RADIUS}
    }

    for i = 64, 1024 do 
        local list_entry = proc.read_int64(entity_list + 0x8 * ((i >> 9) & 0x7F) + 0x10)
        if not list_entry or list_entry == 0 then goto continue_inf end
        
        local entity = proc.read_int64(list_entry + 112 * (i & 0x1FF))
        if not entity or entity == 0 then goto continue_inf end

        local fire_count = proc.read_int32(entity + offsets.m_fireCount)

        if fire_count > 0 and fire_count <= 64 then
            local hull_points = {}
            local has_points = false

            for f = 0, fire_count - 1 do
                local is_burning = proc.read_int8(entity + offsets.m_bFireIsBurning + f)
                if is_burning == 1 then
                    local pos_addr = entity + offsets.m_firePositions + (f * 12)
                    local cx, cy, cz = proc.read_float(pos_addr), proc.read_float(pos_addr + 4), proc.read_float(pos_addr + 8)

                    for _, off in ipairs(cell_offsets) do
                        local world_pos = { x = cx + off.x, y = cy + off.y, z = cz }
                        local scr = world_to_screen(view_matrix, world_pos)
                        if scr then
                            table.insert(hull_points, {x = scr.x, y = scr.y})
                            has_points = true
                        end
                    end
                end
            end

            if has_points and #hull_points > 2 then
                local hull = get_convex_hull(hull_points)
                
                local poly = {}
                for _, p in ipairs(hull) do
                    table.insert(poly, p.x); table.insert(poly, p.y)
                end

                render.draw_polygon(poly, c_body[1], c_body[2], c_body[3], a_body, 0, true)

                render.draw_polygon(poly, c_glow[1], c_glow[2], c_glow[3], a_glow, 6.0, false)
                
                render.draw_polygon(poly, c_body[1], c_body[2], c_body[3], 150, 3.0, false)

                render.draw_polygon(poly, c_core[1], c_core[2], c_core[3], a_core, 1.0, false)
            end
        end

        ::continue_inf::
    end
end

function handle_world_esp()
    local draw_weapons = MenuLib.get_value("esp_dropped_weapons")
    local draw_nades = MenuLib.get_value("esp_projectiles")
    local draw_bomb = MenuLib.get_value("esp_bomb")
    
    if not (draw_weapons or draw_nades or draw_bomb) then return end
    if not proc.is_attached() then return end

    local client_dll = proc.find_module("client.dll")
    if not client_dll or client_dll == 0 then return end
    
    local now = winapi.get_tickcount64()
    local fps = render.get_fps()
    local dt = 1.0 / math.max(30, fps)

    local view_matrix = {}
    for i = 0, 15 do table.insert(view_matrix, proc.read_float(client_dll + offsets.dwViewMatrix + (i * 4))) end

    local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
    if not entity_list or entity_list == 0 then return end

    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    local local_pos = vec3(0,0,0)
    if local_pawn ~= 0 then
        local scene = proc.read_int64(local_pawn + offsets.m_pGameSceneNode)
        if scene ~= 0 then local_pos = vec3.read_float(scene + offsets.m_vecAbsOrigin) end
    end

    local found_carrier_handle = 0
    local current_frame_grenades = {} 

    for i = 64, 2048 do
        local list_entry = proc.read_int64(entity_list + 0x8 * ((i >> 9) & 0x7F) + 0x10)
        if not list_entry or list_entry == 0 then goto next_item end
        
        local entity = proc.read_int64(list_entry + 112 * (i & 0x1FF)) 
        if not entity or entity == 0 then goto next_item end
        
        -- Check Owner (Dropped items have -1 owner)
        local owner = proc.read_int32(entity + offsets.m_hOwnerEntity)
        
        -- [[ 1. READ NAME (For C4 & Projectiles) ]]
        local item_info = proc.read_int64(entity + 0x10)
        if item_info == 0 then goto next_item end
        local item_type = proc.read_int64(item_info + 0x20)
        if item_type == 0 then goto next_item end
        local name = proc.read_string(item_type, 64)
        if not name or name == "" then goto next_item end

        -- [[ 2. READ ITEM ID (For Weapons) ]]
        -- This is the fix: Reading the ID (int16) to match your WEAPON_MAP keys
        local item_def_index = proc.read_int16(entity + offsets.m_AttributeManager + offsets.m_Item + offsets.m_iItemDefinitionIndex)

        -- Track Bomb Carrier
        if name == "weapon_c4" and owner ~= -1 then
            found_carrier_handle = owner
        end

        -- Filter: Must be dropped (owner -1) or a projectile
        if owner ~= -1 and not name:find("projectile") then goto next_item end

        local is_c4 = (name == "weapon_c4")
        local is_proj = name:find("projectile")
        
        -- Lookup weapon name using the ID we just read
        local weapon_name_str = g_State.WEAPON_MAP[item_def_index] 
        local is_weap = (weapon_name_str ~= nil)

        if not ((draw_bomb and is_c4) or (draw_nades and is_proj) or (draw_weapons and is_weap)) then 
            goto next_item 
        end

        -- [[ 3. PREDICT POSITION ]]
        local scene = proc.read_int64(entity + offsets.m_pGameSceneNode)
        if scene == 0 then goto next_item end
        
        local origin = vec3.read_float(scene + offsets.m_vecAbsOrigin)
        local vel = vec3.read_float(entity + offsets.m_vecVelocity)
        
        local pred_x = origin.x + (vel.x * dt)
        local pred_y = origin.y + (vel.y * dt)
        local pred_z = origin.z + (vel.z * dt)

        g_State.screen_pos = world_to_screen(view_matrix, {x=pred_x, y=pred_y, z=pred_z})
        
        if g_State.screen_pos then
            local dist = get_distance_manual({x=pred_x, y=pred_y, z=pred_z}, local_pos) / 39.37

            if is_c4 then
                g_State.bomb_color = MenuLib.get_value("esp_bomb_color") or {255, 50, 50, 255}
                draw_dynamic_panel(g_State.screen_pos, "Dropped C4", dist, 1, g_State.bomb_color, 1.0)

            elseif is_weap then
                -- Draw using the name found in the map
                draw_dynamic_panel(g_State.screen_pos, weapon_name_str, dist, 0, theme.text_dim, 0.0)

            elseif is_proj then
                current_frame_grenades[i] = { name = name, pos = origin, index = i }
                if not grenade_anim_states[i] then grenade_anim_states[i] = 0.0 end

                if name == "smokegrenade_projectile" then
                    local speed = math.sqrt(vel.x^2 + vel.y^2 + vel.z^2)
                    local is_landed = (speed < 15) or (grenade_start_times[entity] and speed < 100)
                    local target = is_landed and 1.0 or 0.0
                    
                    grenade_anim_states[i] = lerp(grenade_anim_states[i], target, 0.15) 

                    if is_landed then
                        local max_dur = 21.5
                        if not grenade_start_times[entity] then grenade_start_times[entity] = now end
                        local prog = math.max(0, math.min(1, 1 - ((now - grenade_start_times[entity]) / 1000.0 / max_dur)))
                        if prog > 0 then
                            draw_dynamic_panel(g_State.screen_pos, "Smoke", dist, prog, theme.smoke_acc, grenade_anim_states[i])
                        end
                    else
                        grenade_start_times[entity] = nil
                        draw_dynamic_panel(g_State.screen_pos, "Smoke", dist, 0, theme.smoke_acc, grenade_anim_states[i])
                    end

                elseif name == "molotov_projectile" or name == "incendiarygrenade_projectile" then
                    grenade_anim_states[i] = lerp(grenade_anim_states[i], 0.0, 0.2)
                    local label = (name == "molotov_projectile") and "Molotov" or "Incendiary"
                    draw_dynamic_panel(g_State.screen_pos, label, dist, 0, theme.fire_acc, grenade_anim_states[i])

                elseif name == "decoy_projectile" then
                    draw_dynamic_panel(g_State.screen_pos, "Decoy", dist, 1.0, theme.decoy_acc, 1.0)
                elseif name == "flashbang_projectile" then
                    draw_dynamic_panel(g_State.screen_pos, "Flash", dist, 0, theme.flash_acc, 1.0)
                elseif name == "hegrenade_projectile" then
                    draw_dynamic_panel(g_State.screen_pos, "HE", dist, 0, theme.he_acc, 1.0)
                end
            end
        end

        ::next_item::
    end

    _G.C4_Carrier_Handle = found_carrier_handle

    g_State.MOLOTOV_DURATION_MS = 7000 
    for idx, g_data in pairs(last_frame_grenades) do
        if not current_frame_grenades[idx] then
            if g_data.name == "molotov_projectile" or g_data.name == "incendiarygrenade_projectile" then
                predicted_infernos[idx] = {
                    pos = g_data.pos,
                    time = now,
                    expiration = now + g_State.MOLOTOV_DURATION_MS,
                    name = (g_data.name == "molotov_projectile") and "Molotov" or "Incendiary",
                    color = theme.fire_acc
                }
                grenade_anim_states[idx] = 0.0
            end
        end
    end
    last_frame_grenades = current_frame_grenades

    for idx, inferno in pairs(predicted_infernos) do
        if now > inferno.expiration then
            predicted_infernos[idx] = nil 
            grenade_anim_states[idx] = nil
        else
            if not grenade_anim_states[idx] then grenade_anim_states[idx] = 0.0 end
            grenade_anim_states[idx] = lerp(grenade_anim_states[idx], 1.0, 0.1)

            local screen_pos = world_to_screen(view_matrix, inferno.pos)
            if screen_pos then
                local dist_m = get_distance_manual(inferno.pos, local_pos) / 39.37
                local remaining = inferno.expiration - now
                local progress = math.max(0.0, math.min(1.0, remaining / g_State.MOLOTOV_DURATION_MS)) 
                draw_dynamic_panel(screen_pos, inferno.name, dist_m, progress, inferno.color, grenade_anim_states[idx])
            end
        end
    end

    if now % 100 == 0 then
        for k, v in pairs(grenade_anim_states) do
            if not current_frame_grenades[k] and not predicted_infernos[k] then
                grenade_anim_states[k] = nil
            end
        end
    end
end






g_State.WEAPON_MAP = {
    [32] = "P2000", [61] = "USP-S", [4] = "Glock", [2] = "Dual Berettas", [36] = "P250",
    [30] = "Tec-9", [63] = "CZ75-Auto", [1] = "Desert Eagle", [3] = "Five-SeveN",
    [64] = "R8", [35] = "Nova", [25] = "XM1014", [27] = "MAG-7", [29] = "Sawed-Off",
    [14] = "M249", [28] = "Negev", [17] = "MAC-10", [23] = "MP5-SD", [24] = "UMP-45",
    [19] = "P90", [26] = "Bizon", [34] = "MP9", [33] = "MP7", [10] = "FAMAS",
    [16] = "M4A4", [60] = "M4A1-S", [8] = "AUG", [43] = "Galil", [7] = "AK-47",
    [39] = "SG 553", [40] = "SSG 08", [9] = "AWP", [38] = "SCAR-20", [11] = "G3SG1",
    [44] = "HE Grenade", [45] = "Smoke", [46] = "Molotov", [47] = "Decoy", [49] = "C4",
    [42] = "Knife", [59] = "Knife", [500] = "Bayonet", [505] = "Flip Knife", [506] = "Gut Knife",
    [507] = "Karambit", [508] = "M9 Bayonet", [512] = "Falchion", [515] = "Butterfly", [520] = "Navaja"
}

g_State.PROJECTILES_MAP = {
    ["smokegrenade_projectile"] = "Smoke", 
    ["flashbang_projectile"] = "Flashbang",
    ["hegrenade_projectile"] = "HE Grenade", 
    ["molotov_projectile"] = "Molotov",
    ["incendiarygrenade_projectile"] = "Incendiary", 
    ["decoy_projectile"] = "Decoy"
}

g_State.BONE_MAP = {
    head = 6, neck = 5, spine_3 = 4, spine_2 = 3, spine_1 = 2, pelvis = 0,
    clavicle_L = 7, arm_upper_L = 8, arm_lower_L = 9, hand_L = 10,
    clavicle_R = 12, arm_upper_R = 13, arm_lower_R = 14, hand_R = 15,
    leg_upper_L = 22, leg_lower_L = 23, ankle_L = 24,
    leg_upper_R = 25, leg_lower_R = 26, ankle_R = 27
}

g_State.aimbot_state = {
    last_target_index = -1,
    last_switch_time = 0,
    current_target_index = -1
}


function is_player_visible(player_pawn, local_player_index)
    if not player_pawn or player_pawn == 0 or not local_player_index or local_player_index < 1 then
        return false
    end
    local spotted_by_mask_addr = player_pawn + offsets.m_entitySpottedState + offsets.m_bSpottedByMask
    local mask = proc.read_int64(spotted_by_mask_addr)

    return ((mask >> (local_player_index - 1)) & 1) == 1
end

function world_to_screen(view_matrix, position_3d)
    local screen_w = view_matrix[13] * position_3d.x + view_matrix[14] * position_3d.y + view_matrix[15] * position_3d.z +
    view_matrix[16]
    if screen_w < 0.01 then return nil end

    local screen_x = view_matrix[1] * position_3d.x + view_matrix[2] * position_3d.y + view_matrix[3] * position_3d.z +
    view_matrix[4]
    local screen_y = view_matrix[5] * position_3d.x + view_matrix[6] * position_3d.y + view_matrix[7] * position_3d.z +
    view_matrix[8]
    local inv_w = 1.0 / screen_w

    local sx = screen_x * inv_w
    local sy = screen_y * inv_w
    local screen_width, screen_height = render.get_viewport_size()

    local x = (screen_width / 2.0) + (sx * screen_width) / 2.0
    local y = (screen_height / 2.0) - (sy * screen_height) / 2.0

    return vec2(x, y)
end


local WEAPON_CATEGORIES = {
    legit_pistol = { 32, 61, 4, 2, 36, 30, 63, 3 }, -- Pistols (No Deagle/R8)
    legit_deagle = { 1, 64 },                       -- Deagle and R8
    legit_smg = { 17, 23, 24, 19, 26, 34, 33 },   -- SMGs
    legit_rifle = { 10, 16, 60, 8, 43, 7, 39 },   -- Rifles
    legit_shotgun = { 35, 25, 27, 29 },           -- Shotguns
    legit_sniper = { 40, 9, 38, 11 }             -- Snipers
}


function get_active_weapon_id(pawn, entity_list_addr)
    if not pawn or pawn == 0 or not entity_list_addr or entity_list_addr == 0 then 
        return -1 
    end

    local weapon_services = proc.read_int64(pawn + offsets.m_pWeaponServices)
    if not weapon_services or weapon_services == 0 then return -1 end

    local active_weapon_handle = proc.read_int32(weapon_services + offsets.m_hActiveWeapon)
    if not active_weapon_handle or active_weapon_handle == -1 then return -1 end

    local handle_masked = active_weapon_handle & 0x7FFF
    local list_entry = proc.read_int64(entity_list_addr + 0x8 * (handle_masked >> 9) + 16)
    if not list_entry or list_entry == 0 then return -1 end
    
    local weapon_entity = proc.read_int64(list_entry + 112 * (handle_masked & 0x1FF))
    if not weapon_entity or weapon_entity == 0 then return -1 end
    
    local weapon_id = proc.read_int16(weapon_entity + offsets.m_AttributeManager + offsets.m_Item + offsets.m_iItemDefinitionIndex)
    
    if not weapon_id then
        return -1
    end
    
    return weapon_id
end


local weapon_category_ids = {
    "legit_pistol", "legit_deagle", "legit_smg", 
    "legit_rifle", "legit_shotgun", "legit_sniper"
}

local function update_triggerbot_ui_visibility()
    for _, category_id in ipairs(weapon_category_ids) do
        local dynamic_checkbox_id = category_id .. "_trigger_dynamic_delay_enabled"
        local static_slider_id = category_id .. "_trigger_delay"
        local min_slider_id = category_id .. "_trigger_dynamic_delay_min"
        local max_slider_id = category_id .. "_trigger_dynamic_delay_max"

        local dynamic_checkbox = Menu.elements[dynamic_checkbox_id]
        local static_slider = Menu.elements[static_slider_id]
        local min_slider = Menu.elements[min_slider_id]
        local max_slider = Menu.elements[max_slider_id]

        if dynamic_checkbox and static_slider and min_slider and max_slider then
            local is_dynamic_enabled = MenuLib.get_value(dynamic_checkbox_id)
            
            static_slider.is_active = not is_dynamic_enabled
            min_slider.is_active = is_dynamic_enabled
            max_slider.is_active = is_dynamic_enabled
        end
    end
end
function get_weapon_category(weapon_id)
    if weapon_id == -1 then return nil end
    for category_id, id_list in pairs(WEAPON_CATEGORIES) do
        for _, id in ipairs(id_list) do
            if id == weapon_id then
                return category_id
            end
        end
    end
    return nil
end



function trigger_schedule_action(ms, callback)
    if type(ms) ~= "number" then
        engine.log("Error: Invalid delay passed to trigger_schedule_action. Must be a number.", 255, 100, 100, 255)
        return 
    end
    
    table.insert(trigger_pending_actions, {
        execute_at = winapi.get_tickcount64() + ms,
        callback = callback
    })
end

function trigger_process_pending_actions()
    if #trigger_pending_actions == 0 then return end
    
    local current_time_ms = winapi.get_tickcount64()
    
    for i = #trigger_pending_actions, 1, -1 do
        local action = trigger_pending_actions[i]
        if current_time_ms >= action.execute_at then
            action.callback()
            table.remove(trigger_pending_actions, i)
        end
    end
end

function trigger_click_mouse(weapon_category)
    local shot_delay = 0
    local dynamic_enabled_id = weapon_category .. "_trigger_dynamic_delay_enabled"

    if Menu.elements[dynamic_enabled_id] and MenuLib.get_value(dynamic_enabled_id) then
        local min_delay = MenuLib.get_value(weapon_category .. "_trigger_dynamic_delay_min")
        local max_delay = MenuLib.get_value(weapon_category .. "_trigger_dynamic_delay_max")
        if min_delay > max_delay then min_delay = max_delay end
        shot_delay = math.random(min_delay, max_delay)
    else
        shot_delay = MenuLib.get_value(weapon_category .. "_trigger_delay")
    end
    
    shot_delay = math.max(0, shot_delay) 
    last_trigger_delay = shot_delay 

    trigger_schedule_action(shot_delay, function()
        input.simulate_mouse(0, 0, 2)
    end)
end




function draw_triggerbot_debug_info()
    local client_dll = proc.find_module("client.dll")
    if not client_dll then return end
    
    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if not local_pawn or local_pawn == 0 then return end
    
    local weapon_id = get_active_weapon_id(local_pawn)
    local weapon_category = get_weapon_category(weapon_id)

    if not weapon_category then return end
    
    local enabled_id = weapon_category .. "_trigger_enabled"
    if MenuLib.get_value(enabled_id) then
        local debug_text = string.format("Active Trigger Delay: %dms", last_trigger_delay)
        
        local screen_width, screen_height = render.get_viewport_size()
        local y_pos = screen_height - 30
        local x_pos = 10                

        render.draw_text(Menu.fonts.main, debug_text, x_pos, y_pos, 255, 255, 255, 255, 1.5, 0, 0, 0, 200)
    end
end

function trigger_get_current_hitchance()
    local client_dll = proc.find_module("client.dll")
    if not client_dll then return 0 end
    
    local local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if local_pawn == 0 then return 0 end
    
    local velocity_vec = vec3.read_float(local_pawn + offsets.m_vecVelocity)
    local current_speed = velocity_vec:length_2d()

    local hitchance = math.map(current_speed, 0, 250.0, 100, 0)
    
    return math.clamp(hitchance, 0, 100)
end

local rcs_state = {
    old_punch = vec3(0, 0, 0)
}

local _aim_state = { current_target_index = -1, last_kill_time = 0 }

function handle_aimbot(game, local_player_index, current_weapon_category)
    if not current_weapon_category then return end
    
    local enabled_id = current_weapon_category .. "_legit_enabled"
    local key_id = current_weapon_category .. "_legit_key"
    
    if not MenuLib.get_value(enabled_id) or not is_keybind_active(key_id) then 
        _aim_state.current_target_index = -1
        return 
    end

    local fov = MenuLib.get_value(current_weapon_category .. "_legit_fov")
    local smoothing = math.max(1.0, MenuLib.get_value(current_weapon_category .. "_legit_smoothing"))
    local hitbox_id = current_weapon_category .. "_legit_hitbox"
    
    local priority_mode = MenuLib.get_value(current_weapon_category .. "_legit_target_mode") or 1 

    local sw, sh = render.get_viewport_size()
    local cx, cy = sw / 2, sh / 2

    if MenuLib.get_value(current_weapon_category .. "_legit_draw_fov") then
        render.draw_circle(cx, cy, fov, 255, 255, 255, 30, 1, false)
    end
    
    local BONE_LOOKUP = {
        [1] = "head",
        [2] = "neck",
        [3] = "spine_2", -- Chest
        [4] = "spine_1", -- Stomach
        [5] = "pelvis"
    }

    local DAMAGE_WEIGHTS = {
        [1] = 400, -- Head
        [2] = 100, -- Neck (treated as chest usually)
        [3] = 100, -- Chest
        [4] = 125, -- Stomach
        [5] = 75   -- Pelvis/Legs
    }

    local selected_hitboxes = MenuLib.get_value(hitbox_id)
    if not selected_hitboxes then selected_hitboxes = {[1]=true} end

    local best_target = nil
    local best_dist = fov
    local best_priority_score = -1

    for _, entity in ipairs(game.entities) do
        if entity.team ~= game.local_team and is_player_visible(entity.pawn_address, local_player_index) then
            
            for index, is_enabled in pairs(selected_hitboxes) do
                if is_enabled then
                    local bone_name = BONE_LOOKUP[index]
                    local bone_pos = entity.bones[bone_name]

                    if bone_pos then
                        local s_pos = world_to_screen(game.view_matrix, bone_pos)
                        if s_pos then
                            local dist = math.sqrt((s_pos.x - cx)^2 + (s_pos.y - cy)^2)
                            
                            if dist <= fov then
                                if priority_mode == 1 then
                                    if dist < best_dist then
                                        best_dist = dist
                                        best_target = { pos = s_pos, index = entity.index }
                                    end
                                elseif priority_mode == 2 then
                                    local current_score = DAMAGE_WEIGHTS[index] or 0
                                    
                                    if current_score > best_priority_score then
                                        best_priority_score = current_score
                                        best_dist = dist
                                        best_target = { pos = s_pos, index = entity.index }
                                    elseif current_score == best_priority_score then
                                        if dist < best_dist then
                                            best_dist = dist
                                            best_target = { pos = s_pos, index = entity.index }
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if best_target then
        local dx = best_target.pos.x - cx
        local dy = best_target.pos.y - cy
        
        local fps_scaling = 144 / math.max(30, render.get_fps())
        local final_smooth = smoothing * fps_scaling

        if not _aim_state.rnd_x or (winapi.get_tickcount64() % 15 == 0) then
            _aim_state.rnd_x = math.random(-2, 2)
            _aim_state.rnd_y = math.random(-2, 2)
        end

        local move_x = (dx + _aim_state.rnd_x) / final_smooth
        local move_y = (dy + _aim_state.rnd_y) / final_smooth

        if math.abs(dx) < 2 and math.abs(dy) < 2 then
            move_x = 0
            move_y = 0
        end

        if math.abs(move_x) >= 1 or math.abs(move_y) >= 1 then
            input.simulate_mouse(math.floor(move_x), math.floor(move_y), 1)
        end
    else
        _aim_state.current_target_index = -1
    end
end



function handle_rcs(weapon_category, game)
    if not weapon_category then return end 

    local enabled_id = weapon_category .. "_rcs_enabled"
    if not MenuLib.get_value(enabled_id) then 
        rcs_state.old_punch = vec3(0, 0, 0)
        rcs_state.pending_x = 0
        rcs_state.pending_y = 0
        return 
    end

    local strength_x_id = weapon_category .. "_rcs_strength_x"
    local strength_y_id = weapon_category .. "_rcs_strength_y"
    local start_bullet_id = weapon_category .. "_rcs_start_bullet"
    local smooth_id = weapon_category .. "_rcs_smooth"
    local humanize_id = weapon_category .. "_rcs_humanize"
    
    local shots_fired = proc.read_int32(game.local_pawn + offsets.m_iShotsFired)
    
    if shots_fired >= MenuLib.get_value(start_bullet_id) then
        local aim_punch = vec3.read_float(game.local_pawn + offsets.m_aimPunchAngle)
        
        local delta_pitch = (aim_punch.x - rcs_state.old_punch.x)
        local delta_yaw   = (aim_punch.y - rcs_state.old_punch.y)

        local strength_x = MenuLib.get_value(strength_x_id)
        local strength_y = MenuLib.get_value(strength_y_id)
        
        
        rcs_state.pending_x = rcs_state.pending_x + (delta_pitch * strength_x)
        rcs_state.pending_y = rcs_state.pending_y + (delta_yaw * strength_y)

        local smooth = math.max(1.0, MenuLib.get_value(smooth_id))
        local humanize = MenuLib.get_value(humanize_id)

      
        local move_x = rcs_state.pending_x / smooth
        local move_y = rcs_state.pending_y / smooth

       
        if humanize > 0 then
            local noise_x = (math.random(-100, 100) / 5000.0) * humanize
            local noise_y = (math.random(-100, 100) / 5000.0) * humanize
            move_x = move_x + noise_x
            move_y = move_y + noise_y
        end

        local current_view_angles = vec3.read_float(game.client_dll + offsets.dwViewAngles)
        
        local new_angles = vec3(
            current_view_angles.x - move_x, 
            current_view_angles.y - move_y, 
            0
        )
        
        new_angles.x = math.clamp(new_angles.x, -89.0, 89.0)
        new_angles.y = math.wrap(new_angles.y, -180.0, 180.0)
        new_angles.z = 0

        vec3.write_float(game.client_dll + offsets.dwViewAngles, new_angles)
        
        rcs_state.pending_x = rcs_state.pending_x - move_x
        rcs_state.pending_y = rcs_state.pending_y - move_y
        
        rcs_state.old_punch = aim_punch
    else
        rcs_state.old_punch = vec3(0, 0, 0)
        rcs_state.pending_x = 0
        rcs_state.pending_y = 0
    end
end


function handle_autostop(weapon_category, game)
    if not weapon_category then return end
    if not MenuLib.get_value(weapon_category .. "_autostop") then return end

    local mode = MenuLib.get_value(weapon_category .. "_autostop_mode") or 1
    local should_stop = false
    local now = winapi.get_tickcount64()

    if mode == 1 then 

        if input.is_key_down(0x01) or (now - (_G.last_fire_time or 0) < 150) then 
            should_stop = true 
        end
    elseif mode == 2 then 
        local key_id = weapon_category .. "_legit_key"
        if is_keybind_active(key_id) then should_stop = true end
    elseif mode == 3 then 
        should_stop = true
    end

    if not should_stop then return end

    local flags = proc.read_int32(game.local_pawn + offsets.m_fFlags)
    local is_on_ground = (flags & 1) == 1
    if not is_on_ground then return end

    local vel = vec3.read_float(game.local_pawn + offsets.m_vecVelocity)
    local speed = math.sqrt(vel.x * vel.x + vel.y * vel.y)

    if speed < 35.0 then return end


    local strength = MenuLib.get_value(weapon_category .. "_autostop_strength") or 50

    local view_angles = vec3.read_float(game.client_dll + offsets.dwViewAngles)
    local yaw_rad = math.rad(view_angles.y)
    
    local vel_fwd = vel.x * math.cos(yaw_rad) + vel.y * math.sin(yaw_rad)
    local vel_side = vel.y * math.cos(yaw_rad) - vel.x * math.sin(yaw_rad)


    
    if vel_fwd > 35.0 then 
        win_key_press(0x53, strength) -- Tap S
    elseif vel_fwd < -35.0 then 
        win_key_press(0x57, strength) -- Tap W
    end

    if vel_side > 35.0 then 
        win_key_press(0x44, strength) -- Tap D
    elseif vel_side < -35.0 then 
        win_key_press(0x41, strength) -- Tap A
    end
end

function handle_triggerbot(weapon_category, game)
    if not weapon_category then return end

    local enabled_id = weapon_category .. "_trigger_enabled"
    local key_id = weapon_category .. "_trigger_key"

    if not MenuLib.get_value(enabled_id) then return end
    if not is_keybind_active(key_id) then return end

    trigger_process_pending_actions()
    if (winapi.get_tickcount64() - trigger_last_shot_time) < 100 then return end

    local entityId = proc.read_int32(game.local_pawn + offsets.m_iIDEntIndex)
    
    if entityId <= 0 then return end 

    local targetIndex = entityId & 0x7FFF

    local target_entity = nil
    if game.entities then
        for _, ent in ipairs(game.entities) do
            if ent.pawn_index == targetIndex then
                target_entity = ent
                break
            end
        end
    end

    if not target_entity then 
        return 
    end

    if target_entity.health > 0 then
        local team_check = MenuLib.get_value(weapon_category .. "_trigger_team_check")
        if team_check and target_entity.team == game.local_team then 
            return 
        end

   
        local use_magnet = MenuLib.get_value(weapon_category .. "_trigger_magnet")
        
        if use_magnet then
            local hitbox_id = weapon_category .. "_legit_hitbox"
            local selected_hitboxes = MenuLib.get_value(hitbox_id)
            local filtering_bones = false

            if selected_hitboxes then
                for k, v in pairs(selected_hitboxes) do
                    if v then filtering_bones = true; break end
                end
            end

            if filtering_bones then
                local BONE_LOOKUP = { [1]="head", [2]="neck", [3]="spine_2", [4]="spine_1", [5]="pelvis" }
                local sw, sh = render.get_viewport_size()
                local cx, cy = sw / 2, sh / 2
                local is_valid_bone = false
                
                local hit_radius = 25 
                if target_entity.bones["head"] and target_entity.bones["neck"] then
                    local s1 = world_to_screen(game.view_matrix, target_entity.bones["head"])
                    local s2 = world_to_screen(game.view_matrix, target_entity.bones["neck"])
                    if s1 and s2 then
                        local dist = math.sqrt((s1.x - s2.x)^2 + (s1.y - s2.y)^2)
                        hit_radius = math.max(12, dist * 3.0) -- Adjusted for tighter magnet feel
                    end
                end

                for index, is_enabled in pairs(selected_hitboxes) do
                    if is_enabled then
                        local bone_name = BONE_LOOKUP[index]
                        local bone_pos = target_entity.bones[bone_name]
                        if bone_pos then
                            local s_pos = world_to_screen(game.view_matrix, bone_pos)
                            if s_pos then
                                local d = math.sqrt((s_pos.x - cx)^2 + (s_pos.y - cy)^2)
                                if d <= hit_radius then 
                                    is_valid_bone = true 
                                    break 
                                end
                            end
                        end
                    end
                end
                
                if not is_valid_bone then return end
            end
        end

        _G.last_fire_time = winapi.get_tickcount64()
        trigger_click_mouse(weapon_category)
        trigger_last_shot_time = winapi.get_tickcount64()
    end
end




function draw_recoil_crosshair(game)
    if not MenuLib.get_value("recoil_dot_enabled") then
        return
    end

    if game.local_pawn and game.local_pawn ~= 0 then
        local is_scoped = proc.read_int8(game.local_pawn + offsets.m_bIsScoped) > 0
        if is_scoped then return end
    end

    local shots_fired = proc.read_int32(game.local_pawn + offsets.m_iShotsFired)
    if not shots_fired or shots_fired < 1 then
        return
    end

    local screen_w, screen_h = render.get_viewport_size()
    local screen_center_x, screen_center_y = screen_w / 2, screen_h / 2
    
    local aim_punch = vec3.read_float(game.local_pawn + offsets.m_aimPunchAngle)
    if not aim_punch then return end

    local recoil_scale = 2.0
    local punch_x_pixels = aim_punch.y * recoil_scale * 11.4
    local punch_y_pixels = aim_punch.x * recoil_scale * 11.4
    
    local dot_x = screen_center_x - punch_x_pixels
    local dot_y = screen_center_y + punch_y_pixels
    
    local r, g, b, a = table.unpack(MenuLib.get_value("recoil_dot_color"))
    
    render.draw_circle(dot_x, dot_y, 3, 0, 0, 0, 255, 0, true)
    render.draw_circle(dot_x, dot_y, 2, r, g, b, a, 0, true)
end




function draw_sniper_crosshair(game_data)
    if not MenuLib.get_value("sniper_crosshair_enabled") then
        return
    end

    if not game_data or not game_data.local_pawn or game_data.local_pawn == 0 then
        return
    end

    local weapon_id = get_active_weapon_id(game_data.local_pawn, game_data.entity_list)
    local weapon_category = get_weapon_category(weapon_id)

    if weapon_category ~= "legit_sniper" then
        return 
    end

    local is_scoped = proc.read_int8(game_data.local_pawn + offsets.m_bIsScoped) > 0
    if is_scoped then
        return 
    end

    local r, g, b, a = table.unpack(MenuLib.get_value("crosshair_color"))
    local thickness = MenuLib.get_value("crosshair_thickness")
    local gap = MenuLib.get_value("crosshair_gap")
    local length = 10 

    local screen_w, screen_h = render.get_viewport_size()
    local center_x, center_y = screen_w / 2, screen_h / 2

    render.draw_line(center_x, center_y - gap, center_x, center_y - gap - length, r, g, b, a, thickness)
    render.draw_line(center_x, center_y + gap, center_x, center_y + gap + length, r, g, b, a, thickness)
    render.draw_line(center_x - gap, center_y, center_x - gap - length, center_y, r, g, b, a, thickness)
    render.draw_line(center_x + gap, center_y, center_x + gap + length, center_y, r, g, b, a, thickness)
end














local BONE_ID_HEAD = 6


function get_head_position(pawn_address)
    local game_scene = proc.read_int64(pawn_address + offsets.m_pGameSceneNode)
    if not game_scene or game_scene == 0 then return nil end
    
    local bone_array_ptr = proc.read_int64(game_scene + offsets.m_boneArray_aim)
    if not bone_array_ptr or bone_array_ptr == 0 then return nil end

    return vec3.read_float(bone_array_ptr + BONE_ID_HEAD * 32)
end


function world_to_screen_manual(view_matrix_addr, position)
    local screen_w, screen_h = render.get_viewport_size()
    local vm = {}
    for i=0,15 do table.insert(vm, proc.read_float(view_matrix_addr + (i*4))) end
    local w = vm[13]*position.x + vm[14]*position.y + vm[15]*position.z + vm[16]
    if w < 0.01 then return nil end
    local sx = vm[1]*position.x + vm[2]*position.y + vm[3]*position.z + vm[4]
    local sy = vm[5]*position.x + vm[6]*position.y + vm[7]*position.z + vm[8]
    local x = (screen_w/2) + (0.5 * (sx/w) * screen_w + 0.5)
    local y = (screen_h/2) - (0.5 * (sy/w) * screen_h + 0.5)
    return vec2(x, y)
end









local function get_planted_bomb_info(client_dll)
    if not is_bomb_planted_gamerules(client_dll) then
        planted_bomb_state.last_entity = 0; planted_bomb_state.last_pos = nil; return nil
    end

    local c4_ptr = proc.read_int64(client_dll + offsets.dwPlantedC4)
    if not c4_ptr or c4_ptr == 0 then return nil end
    
    local c4_entity = proc.read_int64(c4_ptr)
    if not c4_entity or c4_entity == 0 then return nil end

    if planted_bomb_state.last_entity ~= 0 and planted_bomb_state.last_entity ~= c4_entity then
        planted_bomb_state.last_entity = 0; return nil
    end

    local defused = proc.read_int8(c4_entity + offsets.m_bBombDefused)
    if defused == 1 then
   
         return { active=true, is_defused=true } 
    end

    local server_time = get_server_time(client_dll)
    if server_time <= 0 then return nil end

    local blow_time = proc.read_float(c4_entity + offsets.m_flC4Blow)
    if not is_valid_number(blow_time) or blow_time <= 0 then return nil end

    local time_left = blow_time - server_time
    if time_left > 65 then return nil end 

    local game_scene = proc.read_int64(c4_entity + offsets.m_pGameSceneNode)
    local pos = {x=0,y=0,z=0}
    if game_scene ~= 0 then
        pos = vec3.read_float(game_scene + offsets.m_vecAbsOrigin)
    end
    
    if planted_bomb_state.last_pos then
        local dx = pos.x - planted_bomb_state.last_pos.x
        local dy = pos.y - planted_bomb_state.last_pos.y
        local dist_sq = dx*dx + dy*dy
        if dist_sq > 250000 then
            planted_bomb_state.last_entity = 0
            return nil
        end
    end
    
    planted_bomb_state.last_entity = c4_entity
    planted_bomb_state.last_pos = pos
    planted_bomb_state.last_blow_time = blow_time

    local is_defusing = proc.read_int8(c4_entity + offsets.m_bBeingDefused) == 1
    local defuse_left, defuse_len = 0, 0
    if is_defusing then
        defuse_len = proc.read_float(c4_entity + offsets.m_flDefuseLength)
        local defuse_end = proc.read_float(c4_entity + offsets.m_flDefuseCountDown)
        defuse_left = math.max(0, defuse_end - server_time)
    end
    
    local timer_length = proc.read_float(c4_entity + offsets.m_flTimerLength)
    if timer_length <= 0 then timer_length = 40.0 end
    
    local site_id = proc.read_int32(c4_entity + offsets.m_nBombSite)
    
    return {
        active = true,
        site = (site_id == 1) and "B" or "A",
        time_left = math.max(0, time_left),
        max_time = timer_length,
        is_defusing = is_defusing,
        defuse_left = defuse_left,
        defuse_max = defuse_len > 0 and defuse_len or 10,
        can_defuse = is_defusing and (defuse_left < time_left),
        is_defused = false
    }
end

-- function handle_c4data()
--     local client = proc.find_module("client.dll")
--     if not client then return end
    
--     local c4 = get_planted_bomb_info(client) 
    
--     if not MenuLib.get_value("misc_c4timer") then return end
--     if not c4 or not c4.active then return end
--     if c4.is_defused and c4.time_left <= 0 then return end 

--     if not bombpanel_dragging then
--         bombpanel_drag_x, bombpanel_drag_y = parse_pos(MenuLib.get_value("pos_bomb"))
--     end
--     local bx, by = bombpanel_drag_x, bombpanel_drag_y
--     local bw, bh = 220, 75

--     local mx, my = input.get_mouse_position()
--     if input.is_key_pressed(1) and mx>=bx and mx<=bx+bw and my>=by and my<=by+bh and not bombpanel_dragging then
--         bombpanel_dragging = true; bombpanel_drag_offset_x = mx - bx; bombpanel_drag_offset_y = my - by
--     end
--     if bombpanel_dragging then
--         if not input.is_key_down(1) then bombpanel_dragging = false
--         else 
--             local nx,ny = mx - bombpanel_drag_offset_x, my - bombpanel_drag_offset_y
--             MenuLib.set_value("pos_bomb", string.format("%d,%d", nx, ny))
--             bx, by = nx, ny
--         end
--     end

--     render.draw_rectangle(bx, by, bw, bh, 22, 23, 27, 220, 0, true, 6)
--     render.draw_rectangle(bx, by, bw, bh, 60, 60, 70, 255, 1, false, 6)
    
--     local icon_col = {255, 50, 50}
--     if c4.is_defusing then icon_col = c4.can_defuse and {100, 255, 100} or {255, 255, 100} end
--     if c4.is_defused then icon_col = {0, 255, 0} end

--     local title_txt = c4.is_defused and "Bomb Defused" or ("Planted - Site " .. c4.site)
--     render.draw_circle(bx + 15, by + 15, 5, icon_col[1], icon_col[2], icon_col[3], 255, 0, true)
--     render.draw_text(Menu.fonts.group, title_txt, bx + 28, by + 8, 255, 255, 255, 255, 0,0,0,0,0)

--     if not c4.is_defused then
--         local time_str = string.format("%.1fs", c4.time_left)
--         local tw = render.measure_text(Menu.fonts.group, time_str)
--         render.draw_text(Menu.fonts.group, time_str, bx + bw - tw - 12, by + 8, 255, 255, 255, 255, 0,0,0,0,0)

--         local bar_x = bx + 12; local bar_y = by + 30; local bar_w = bw - 24; local bar_h = 6
--         local pct = math.clamp(c4.time_left / c4.max_time, 0, 1)
--         render.draw_rectangle(bar_x, bar_y, bar_w, bar_h, 40, 40, 45, 255, 0, true, 3)
--         render.draw_rectangle(bar_x, bar_y, bar_w * pct, bar_h, icon_col[1], icon_col[2], icon_col[3], 255, 0, true, 3)
        
--         if c4.is_defusing then
--             local def_txt = c4.can_defuse and ("Defusing: " .. string.format("%.1f", c4.defuse_left) .. "s") or "NO TIME!"
--             local d_col = c4.can_defuse and {150, 255, 150} or {255, 100, 100}
--             render.draw_text(Menu.fonts.main, def_txt, bx + 12, by + 42, d_col[1], d_col[2], d_col[3], 255, 0,0,0,0,0)
            
--             local dpct = math.clamp(1 - (c4.defuse_left / c4.defuse_max), 0, 1)
--             render.draw_rectangle(bar_x, by+58, bar_w, bar_h, 40, 40, 45, 255, 0, true, 3)
--             render.draw_rectangle(bar_x, by+58, bar_w * dpct, bar_h, d_col[1], d_col[2], d_col[3], 255, 0, true, 3)
--         end
--     end
-- end






local rcs_state = {
    old_punch = vec3(0, 0, 0)
}


local PLUS_JUMP, MINUS_JUMP = 65537, 256
local KEY_A, KEY_D, SPACE_BAR = 0x41, 0x44, 0x20


local state = { client_dll = nil }

local function handle_movement()
    if not proc.is_attached() then return end
    
    if not state.client_dll then state.client_dll = proc.find_module("client.dll"); if not state.client_dll then return end end
    
    local local_pawn = proc.read_int64(state.client_dll + offsets.dwLocalPlayerPawn); if not local_pawn or local_pawn == 0 then return end
    local force_jump_addr = state.client_dll + offsets.dwForceJump
    local flags = proc.read_int32(local_pawn + offsets.m_fFlags)
    local is_on_ground = (flags & 1) == 1

    if MenuLib.get_value("misc_bhop") and input.is_key_down(SPACE_BAR) then
        proc.write_int32(force_jump_addr, is_on_ground and PLUS_JUMP or MINUS_JUMP)
    end

end


function handle_world_sound_esp(game)
    if not MenuLib.get_value("esp_sound_world") then return end
    
    local now = winapi.get_tickcount64()
    local color = MenuLib.get_value("esp_sound_world_color") or {255, 50, 50, 255}
    local r, g, b = color[1], color[2], color[3]

    for _, entity in ipairs(game.entities) do
        if entity.team ~= game.local_team and entity.pawn_address and entity.pawn_address ~= 0 then
            
            local vel = vec3.read_float(entity.pawn_address + offsets.m_vecVelocity)
            local speed = math.sqrt(vel.x * vel.x + vel.y * vel.y)
            
            local flags = proc.read_int32(entity.pawn_address + offsets.m_fFlags)
            local in_air = (flags & 1) == 0

            local current_shots = proc.read_int32(entity.pawn_address + offsets.m_iShotsFired)
            local last_shots = _G.EntityShotsCache[entity.pawn_address] or -1
            local is_shooting = false

            if last_shots ~= -1 and current_shots > last_shots then
                is_shooting = true
            end
            
            _G.EntityShotsCache[entity.pawn_address] = current_shots

            if speed > 135 or in_air or is_shooting then
                local last_time = _G.WorldSoundCooldowns[entity.pawn_address] or 0
                
          
                local cooldown_ms = is_shooting and 200 or 350

                if (now - last_time) > cooldown_ms then
                    local game_scene = proc.read_int64(entity.pawn_address + offsets.m_pGameSceneNode)
                    if game_scene ~= 0 then
                        local origin = vec3.read_float(game_scene + offsets.m_vecAbsOrigin)
                        
                        table.insert(_G.WorldSoundRings, {
                            x = origin.x, y = origin.y, z = origin.z,
                            start_time = now
                        })
                        
                        _G.WorldSoundCooldowns[entity.pawn_address] = now
                    end
                end
            end
        end
    end

    local view_matrix = game.view_matrix
    local RING_DURATION = 1000 
    local MAX_RADIUS = 25.0 
    local SEGMENTS = 24 

    for i = #_G.WorldSoundRings, 1, -1 do
        local ring = _G.WorldSoundRings[i]
        local age = now - ring.start_time
        
        if age > RING_DURATION then
            table.remove(_G.WorldSoundRings, i)
        else
            local progress = age / RING_DURATION
            local current_radius = 15 + (MAX_RADIUS * math.sin(progress * math.pi / 2))
            local alpha = math.floor(color[4] * (1.0 - progress))
            
            local points_screen = {}

            for s = 0, SEGMENTS do
                local theta = math.rad((s / SEGMENTS) * 360)
                local wx = ring.x + current_radius * math.cos(theta)
                local wy = ring.y + current_radius * math.sin(theta)
                local wz = ring.z + 2.0 

                local scr = world_to_screen(view_matrix, {x=wx, y=wy, z=wz})
                
                if scr then
                    table.insert(points_screen, scr)
                end
            end

            if #points_screen > 1 then
                for p = 1, #points_screen - 1 do
                    local p1 = points_screen[p]
                    local p2 = points_screen[p+1]
                    render.draw_line(p1.x, p1.y, p2.x, p2.y, r, g, b, alpha, 2)
                end
                local pLast = points_screen[#points_screen]
                local pFirst = points_screen[1]
                render.draw_line(pLast.x, pLast.y, pFirst.x, pFirst.y, r, g, b, alpha, 2)
            end
        end
    end
end
local DEBUG_MODE = true

engine.register_on_engine_tick(function()

    if not IsCS2Active() then return end


     if _chams_needs_reset then
        if _reset_timer == 0 then
            _reset_timer = winapi.get_tickcount64()
        end
        
        if (winapi.get_tickcount64() - _reset_timer) < 200 then
            local client_dll = proc.find_module("client.dll")
            local entity_list = proc.read_int64(client_dll + offsets.dwEntityList)
            
            if entity_list and entity_list ~= 0 then
                for i = 1, 64 do
                    local list_entry = proc.read_int64(entity_list + 0x8 * ((i & 0x7FFF) >> 9) + 16)
                    if list_entry ~= 0 then
                        local controller = proc.read_int64(list_entry + 112 * (i & 0x1FF))
                        if controller ~= 0 then
                            local pawn_handle = proc.read_int32(controller + offsets.m_hPlayerPawn)
                            if pawn_handle ~= 0 then
                                local list_entry2 = proc.read_int64(entity_list + 0x8 * ((pawn_handle & 0x7FFF) >> 9) + 16)
                                if list_entry2 ~= 0 then
                                    local pawn = proc.read_int64(list_entry2 + 112 * (pawn_handle & 0x1FF))
                                    if pawn ~= 0 then
                                        proc.write_int8(pawn + 0x3D94, 0) 
                                    end
                                end
                            end
                        end
                    end
                end
            end
            return 
        else
            _chams_needs_reset = false 
            engine.log("Chams Reset Complete.", 0, 255, 0, 255)
        end
    end

    --draw_triggerbot_debug_info()
    update_triggerbot_ui_visibility()

    if not proc.is_attached() or proc.did_exit() then
        return
    end

    local client_dll = proc.find_module("client.dll")
    if client_dll == 0 then return end

    local game = {}
    game.client_dll = client_dll
    game.view_matrix = {}
    for i = 0, 15 do table.insert(game.view_matrix, proc.read_float(client_dll + offsets.dwViewMatrix + (i * 4))) end

    game.local_pawn = proc.read_int64(client_dll + offsets.dwLocalPlayerPawn)
    if game.local_pawn == 0 then return end
    game.local_team = proc.read_int32(game.local_pawn + offsets.m_iTeamNum)
    game.entity_list = proc.read_int64(client_dll + offsets.dwEntityList)

    game.entities = {}


local weapon_id = get_active_weapon_id(game.local_pawn, game.entity_list)
    local weapon_category = get_weapon_category(weapon_id)


    if game.entity_list and game.entity_list ~= 0 then
    local list_entry_head = proc.read_int64(game.entity_list + 0x10)
    if list_entry_head ~= 0 then
        for i = 1, 64 do
            local entity_controller = proc.read_int64(list_entry_head + 112 * (i & 0x1FF))
            if entity_controller == 0 then goto skip_ent end
            
            local pawn_handle = proc.read_int32(entity_controller + offsets.m_hPlayerPawn)
            if pawn_handle <= 0 then goto skip_ent end

            local pawn_handle_masked = pawn_handle & 0x7FFF

            local list_entry2 = proc.read_int64(game.entity_list + 0x8 * ((pawn_handle_masked >> 9) & 0x7F) + 16)
            if list_entry2 == 0 then goto skip_ent end
            local pawn_addr = proc.read_int64(list_entry2 + 112 * (pawn_handle_masked & 0x1FF))
            
            if pawn_addr == 0 or pawn_addr == local_player_pawn then goto skip_ent end
            if proc.read_int32(pawn_addr + offsets.m_lifeState) ~= 256 then goto skip_ent end

            local entity = { 
                pawn_address = pawn_addr, 
                team = proc.read_int32(pawn_addr + offsets.m_iTeamNum), 
                bones = {}, 
                index = i, -- Controller Index
                pawn_index = pawn_handle_masked, 
                health = proc.read_int32(pawn_addr + offsets.m_iHealth) 
            }
            
            local game_scene_node = proc.read_int64(pawn_addr + offsets.m_pGameSceneNode)

       if game_scene_node ~= 0 then
                local bone_array_ptr = proc.read_int64(game_scene_node + offsets.m_modelState + offsets.m_boneArray)
                if bone_array_ptr ~= 0 then
                    for name, index in pairs(BONE_MAP) do 
                        local b_pos = vec3.read_float(bone_array_ptr + index * 32)
                        if math.abs(b_pos.x) > 0.1 or math.abs(b_pos.y) > 0.1 or math.abs(b_pos.z) > 0.1 then
                            entity.bones[name] = b_pos
                        end
                    end
                end
            end
            table.insert(game.entities, entity)
            ::skip_ent::
        end
    end
end

    local local_player_index = nil
    local local_player_controller = proc.read_int64(client_dll + offsets.dwLocalPlayerController)
    if local_player_controller and local_player_controller ~= 0 and game.entity_list and game.entity_list ~= 0 then
        local list_entry_head_for_index = proc.read_int64(game.entity_list + 0x10)
        if list_entry_head_for_index and list_entry_head_for_index ~= 0 then
            for i = 1, 64 do
                local entity_controller_for_index = proc.read_int64(list_entry_head_for_index + 112 * (i & 0x1FF))
                if entity_controller_for_index == local_player_controller then
                    local_player_index = i
                    break
                end
            end
        end
    end

  if local_player_index then
        handle_aimbot(game, local_player_index, weapon_category)
    end

       handle_rcs(weapon_category, game)
    handle_triggerbot(weapon_category, game)
        handle_autostop(weapon_category, game)

        draw_recoil_crosshair(game)
    draw_sniper_crosshair(game)
    draw_general_crosshair(game)
    handle_world_esp()
    handle_movement()
    handle_dragging()
    update_data()
    handle_inferno_esp(game.view_matrix)
    handle_world_sound_esp(game)
    update_dynamic_scale()
    draw_modern_radar(game)
    handle_anti_flash() 
    handle_nightmode()
    handle_smoke_modulator()
    update_glow()
    draw_feature_indicators()
        draw_spectators()
        draw_dynamic_hitmarker() 
        DrawVelocityGraph(game.local_pawn)
        handle_c4data()

end)




local log_once = {}

return MenuLib
end

